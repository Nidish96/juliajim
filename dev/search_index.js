var documenterSearchIndex = {"docs":
[{"location":"c_jenkhb/#ex_c","page":"c_jenkhb","title":"Example c","text":"","category":"section"},{"location":"c_jenkhb/#Preamble:-Load-Packages","page":"c_jenkhb","title":"Preamble: Load Packages","text":"","category":"section"},{"location":"c_jenkhb/","page":"c_jenkhb","title":"c_jenkhb","text":"using GLMakie\nusing LaTeXStrings\nusing LinearAlgebra\nusing NonlinearSolve\nusing ForwardDiff\nusing DSP\nusing Infiltrator\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION","category":"page"},{"location":"c_jenkhb/#Residue-Function","page":"c_jenkhb","title":"Residue Function","text":"","category":"section"},{"location":"c_jenkhb/","page":"c_jenkhb","title":"c_jenkhb","text":"function RESFUN!(Uw, Fl, pars, h, Nt; R=nothing, dRdU=nothing, dRdw=nothing)\n    (; z0, w0, kt, fs, F) = pars;\n\n    Om = Uw[end];\n    Nhc = sum((h.==0)+2(h.!=0));\n\n    # Linear Portion\n    E, dEdw = HARMONICSTIFFNESS(1.0, 2z0*w0, w0^2, Om, h);\n\n    # AFT For nonlinear force\n    ut  = AFT(Uw[1:end-1], h, Nt, :f2t);\n\n    # Construct Residue\n    if !(R === nothing && dRdU === nothing)\n        ft = kt*ut;\n        if !(dRdU === nothing)\n            cst = AFT(eltype(Uw).(I(Nhc)), h, Nt, :f2t);\n            dfdat = kt.*cst;\n        end\n\n        for _ in 1:2\n            for (ti, tim1) in zip(1:Nt, circshift(1:Nt,1))\n                fsp = kt*(ut[ti]-ut[tim1]) + ft[tim1];  # stick prediction\n                ft[ti] = clamp(fsp, -fs, fs);\n                if !(dRdU === nothing)\n                    if (abs(fsp)<fs)\n                        dfdat[ti, :] = kt.*(cst[ti,:]-cst[tim1,:]) + dfdat[tim1,:];\n                    else\n                        dfdat[ti, :] .= 0.0;\n                    end\n                end\n            end\n        end\n        if !(R === nothing)\n            Fnl = AFT(ft, h, Nt, :t2f);\n            R[:] = E*Uw[1:end-1] + Fnl - Fl*F;\n        end\n        if !(dRdU === nothing)\n            Jnl    = AFT(dfdat, h, Nt, :t2f);\n            dRdU[:, :] = E + Jnl;\n        end\n    end\n    if !(dRdw === nothing)\n        dRdw[:] = dEdw*Uw[1:end-1];\n    end\n    return nothing;\nend","category":"page"},{"location":"c_jenkhb/#Setup","page":"c_jenkhb","title":"Setup","text":"","category":"section"},{"location":"c_jenkhb/","page":"c_jenkhb","title":"c_jenkhb","text":"pars = (z0 = 0.5e-2, w0 = 2., kt = 5.0, fs=1.0, F = 0.1);\n\n# h = (0:5);\nh = 1:2:5;\nOm = 0.1;\n\nNhc = sum((h.==0)+2(h.!=0));\nNt = 2^9;\n\nFl = zeros(Nhc);\n_,_,zinds,rinds,iinds = HINDS(1, h)\nFl[rinds[1]] = 1.0;\n\nfun = NonlinearFunction((r,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;R=r),\n    jac=(J,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdU=J),\n    paramjac=(Jp,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdw=Jp));\n\nE = zeros(Nhc, Nhc);\nHARMONICSTIFFNESS!(E, nothing, 1.0, 2pars.z0*pars.w0, pars.w0^2+pars.kt, Om, h);\nU0 = E\\ (Fl*pars.F);\n\nprob = NonlinearProblem(fun, U0, Om);\nsol = solve(prob, show_trace=Val(true))\n\nR = zeros(Nhc);\nJf = zeros(Nhc, Nhc+1);\nJ = @view Jf[:, 1:Nhc];\nJp = @view Jf[:, end];\nnothing #hide","category":"page"},{"location":"c_jenkhb/#Continuation","page":"c_jenkhb","title":"Continuation","text":"","category":"section"},{"location":"c_jenkhb/","page":"c_jenkhb","title":"c_jenkhb","text":"Om0 = 0.02pars.w0;\nOm1 = 2pars.w0;\n\nHARMONICSTIFFNESS!(E, nothing, 1.0, 2pars.z0*pars.w0, pars.w0^2+pars.kt, Om0, h);\nU0 = E\\ (Fl*pars.F);\n\nfun = NonlinearFunction((r,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;R=r),\n    jac=(J,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdU=J),\n    paramjac=(Jp,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdw=Jp));\n\ndOm = 0.04pars.w0;\n# dOm = 0.1;\ncpars = (parm=:riks, nmax=300, Dsc=:auto, minDsc=1e-2);\nsols, its, dss, xis, Dsc = CONTINUATE(U0, fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols));\nuh[h.+1, :] = hcat([[s.up[zinds]; s.up[rinds]+1im*s.up[iinds]] for s in sols]...);\nOms = [s.up[end] for s in sols];\nnothing #hide","category":"page"},{"location":"c_jenkhb/#Plot","page":"c_jenkhb","title":"Plot","text":"","category":"section"},{"location":"c_jenkhb/","page":"c_jenkhb","title":"c_jenkhb","text":"his = [1, 3, 5];\n\nfsz = 24;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\nax1s = [];\nax2s = [];\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :]));\n    push!(ax1s, ax)\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :])));\n    push!(ax2s, ax)\nend\nlinkxaxes!(vcat(ax1s, ax2s)...)\n\n    fig","category":"page"},{"location":"c_jenkhb/","page":"c_jenkhb","title":"c_jenkhb","text":"","category":"page"},{"location":"c_jenkhb/","page":"c_jenkhb","title":"c_jenkhb","text":"This page was generated using Literate.jl.","category":"page"},{"location":"d1_mdofgen_hystnl/#ex_d1","page":"d1mdofgenhystnl","title":"Example d1","text":"","category":"section"},{"location":"d1_mdofgen_hystnl/#Preamble:-Load-Packages","page":"d1mdofgenhystnl","title":"Preamble: Load Packages","text":"","category":"section"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"page"},{"location":"d1_mdofgen_hystnl/#System-Setup","page":"d1mdofgenhystnl","title":"System Setup","text":"","category":"section"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"M = I(2);\nK = [2 -1;-1 2];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\n\n# Nonlinearity\nkt = 1.0;\nfs = 1.0;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\nL = [0.0 1.0];\n\nmdl = ADDNL(mdl, :Hyst, fnl, L);\nnothing #hide","category":"page"},{"location":"d1_mdofgen_hystnl/#Trial","page":"d1mdofgenhystnl","title":"Trial","text":"","category":"section"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"h = HSEL(3, 1.0);\nh = 1:2:3;\nh = 0:5;\nN = 256;\nt = (0:N-1)*2π/N;\n\nNhc = sum(all(h.==0, dims=2) + 2any(h.!=0, dims=2));\n\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h)\nFl = zeros(Nhc*mdl.Ndofs);\nFl[rinds[1]] = 1.0;\n\nWst = 0.6;\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Wst, h);\n\nUw0 = [E\\Fl; Wst];\nnothing #hide","category":"page"},{"location":"d1_mdofgen_hystnl/#Nonlinear-Evaluation","page":"d1mdofgenhystnl","title":"Nonlinear Evaluation","text":"","category":"section"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"FNL = zeros(mdl.Ndofs*Nhc);\ndFNLdU = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\ndFNLdw = zeros(mdl.Ndofs*Nhc);\nNLEVAL!(2Uw0, mdl, h, N; FNL=FNL, dFNLdU=dFNLdU, dFNLdw=dFNLdw)","category":"page"},{"location":"d1_mdofgen_hystnl/#HB-Residue","page":"d1mdofgenhystnl","title":"HB Residue","text":"","category":"section"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"R = zeros(mdl.Ndofs*Nhc);\ndRdU = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\ndRdw = zeros(mdl.Ndofs*Nhc);\nHBRESFUN!(Uw0, mdl, Fl, h, N; R=R, dRdU=dRdU, dRdw=dRdw)\n\nFamp = 1.0;\n\nfun = NonlinearFunction((r,u,p)->HBRESFUN!([u;p], mdl, Famp*Fl, h, N; R=r),\n    jac=(J,u,p)->HBRESFUN!([u;p], mdl, Famp*Fl, h, N; dRdU=J),\n    paramjac=(Jp,u,p)->HBRESFUN!([u;p], mdl, Famp*Fl, h, N; dRdw=Jp));\n\nprob = NonlinearProblem(fun, Uw0[1:end-1], Uw0[end]);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"page"},{"location":"d1_mdofgen_hystnl/#Continuation","page":"d1mdofgenhystnl","title":"Continuation","text":"","category":"section"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"Om0 = 0.1;\nOm1 = 3;\ndOm = 0.2;\n\n# fun = NonlinearFunction((r,u,p)->HBRESFUN!([u;p], mdl, Famp*Fl, h, N; R=r));\ncpars = (parm=:arclength, nmax=1000, Dsc=:none);\nsols, its, dss, xis, Dsc = CONTINUATE(Uw0[1:end-1], fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols), 2);\nfor i in 1:2\n    uh[h.+1, :, i] = hcat([[s.up[zinds[i:2:end]];\n                            s.up[rinds[i:2:end]]+1im*s.up[iinds[i:2:end]]]\n                          for s in sols]...);\nend\nOms = [s.up[end] for s in sols];\nnothing #hide","category":"page"},{"location":"d1_mdofgen_hystnl/#Plot","page":"d1mdofgenhystnl","title":"Plot","text":"","category":"section"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"his = [1, 3, 5];\n\nfsz = 24;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n              ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    lines!(ax, Oms, abs.(uh[his[i].+1, :, 1]), label=\"x1\");\n    lines!(ax, Oms, abs.(uh[his[i].+1, :, 2]), label=\"x2\");\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n              ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    lines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    lines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\nend\n\n    fig","category":"page"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"","category":"page"},{"location":"d1_mdofgen_hystnl/","page":"d1mdofgenhystnl","title":"d1mdofgenhystnl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"d4_mdofgen_newmark/#ex_d4","page":"d4mdofgennewmark","title":"Example d4","text":"","category":"section"},{"location":"d4_mdofgen_newmark/#Preamble:-Load-Packages","page":"d4mdofgennewmark","title":"Preamble: Load Packages","text":"","category":"section"},{"location":"d4_mdofgen_newmark/","page":"d4mdofgennewmark","title":"d4mdofgennewmark","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"page"},{"location":"d4_mdofgen_newmark/#System-Setup","page":"d4mdofgennewmark","title":"System Setup","text":"","category":"section"},{"location":"d4_mdofgen_newmark/","page":"d4mdofgennewmark","title":"d4mdofgennewmark","text":"M = I(2);\nK = [2 -1;-1 2];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\n\n# Nonlinearity\nkt = 1.0;\nfs = 1.0;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\nL = [0.0 1.0];\nFv = [1.0, 0.0];\n\nmdl = ADDNL(mdl, :Hyst, fnl, L);\nnothing #hide","category":"page"},{"location":"d4_mdofgen_newmark/#Nonlinear-Force-Evaluation","page":"d4mdofgennewmark","title":"Nonlinear Force Evaluation","text":"","category":"section"},{"location":"d4_mdofgen_newmark/","page":"d4mdofgennewmark","title":"d4mdofgennewmark","text":"Fnl, dFnldU, dFnldUd, S = NLFORCE(mdl, 0, zeros(2), zeros(2))","category":"page"},{"location":"d4_mdofgen_newmark/#Transient-March","page":"d4mdofgennewmark","title":"Transient March","text":"","category":"section"},{"location":"d4_mdofgen_newmark/","page":"d4mdofgennewmark","title":"d4mdofgennewmark","text":"U0 = zeros(2);\nUd0 = zeros(2);\nfsamp = 10;\nOm = 0.6;\nFamp = 4;\nFex = t-> Famp*Fv*cos(Om*t);\nTmax = 2π/Om*100;\n\nt = 0:1/fsamp:Tmax;\n\nU, Ud, Udd, S = NEWMARKMARCH(mdl, 0, Tmax, 1/fsamp, U0, Ud0, Fex, verbosity=100)","category":"page"},{"location":"d4_mdofgen_newmark/#Plots","page":"d4mdofgennewmark","title":"Plots","text":"","category":"section"},{"location":"d4_mdofgen_newmark/","page":"d4mdofgennewmark","title":"d4mdofgennewmark","text":"set_theme!(theme_latexfonts())\nfsz = 20;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\nax1 = Axis(fig[1, 1:2], ylabel=\"Displacement (m)\", title=\"Complete Response\");\nfor i in 1:2\n    lines!(ax1, t, U[i,:])\nend\nax10 = Axis(fig[1, 3], title=\"Steady State\");\nfor i in 1:2\n    scatterlines!(ax10, t, U[i,:], label=\"x$(i)\")\nend\naxislegend(ax10, position=:ct)\nxlims!(ax10, Tmax-2π/Om, Tmax);\nylims!(ax10, -maximum(abs.(U)), maximum(abs.(U)));\n\nax2 = Axis(fig[2, 1:2], ylabel=\"Velocity (m/s)\");\nfor i in 1:2\n    lines!(ax2, t, Ud[i,:])\nend\nax20 = Axis(fig[2, 3]);\nfor i in 1:2\n    scatterlines!(ax20, t, Ud[i,:])\nend\nxlims!(ax20, Tmax-2π/Om, Tmax);\nylims!(ax20, -maximum(abs.(Ud)), maximum(abs.(Ud)));\n\nax3 = Axis(fig[3, 1:2], xlabel=\"Time (s)\", ylabel=\"Friction force (N)\")\nlines!(ax3, t, getindex.(S, 1)[:])\nax30 = Axis(fig[3, 3], xlabel=\"Time (s)\")\nscatterlines!(ax30, t, getindex.(S, 1)[:])\nxlims!(ax30, Tmax-2π/Om, Tmax);\n\nlinkxaxes!(ax1, ax2, ax3);\n\n   fig","category":"page"},{"location":"d4_mdofgen_newmark/","page":"d4mdofgennewmark","title":"d4mdofgennewmark","text":"","category":"page"},{"location":"d4_mdofgen_newmark/","page":"d4mdofgennewmark","title":"d4mdofgennewmark","text":"This page was generated using Literate.jl.","category":"page"},{"location":"d0_mdofgen_instnl/#ex_d0","page":"d0mdofgeninstnl","title":"Example d0","text":"","category":"section"},{"location":"d0_mdofgen_instnl/#Preamble:-Load-Packages","page":"d0mdofgeninstnl","title":"Preamble: Load Packages","text":"","category":"section"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"page"},{"location":"d0_mdofgen_instnl/#System-Setup","page":"d0mdofgeninstnl","title":"System Setup","text":"","category":"section"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"M = I(2);\nK = [2 -1;-1 2];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\n\n# Nonlinearity\nβ = 0.1;\nfnl = (t,u,ud)->return β.*u.^3, 3β.*u.^2, zeros(size(u));;\nL = [0.0 1.0];\n\nmdl = ADDNL(mdl, :Inst, fnl, L);\nnothing #hide","category":"page"},{"location":"d0_mdofgen_instnl/#Trial","page":"d0mdofgeninstnl","title":"Trial","text":"","category":"section"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"h = HSEL(3, 1.0);\n# h = 1:2:5;\nh = 0:5;\nN = 128;\nt = (0:N-1)*2π/N;\n\nNhc = sum(all(h.==0, dims=2) + 2any(h.!=0, dims=2));\n\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h)\nFl = zeros(Nhc*mdl.Ndofs, 1);\nFl[rinds[1]] = 1.0;\n\nWst = 0.6;\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Wst, h);\n\nUw0 = [E\\Fl; Wst];\nnothing #hide","category":"page"},{"location":"d0_mdofgen_instnl/#Nonlinear-Evaluation","page":"d0mdofgeninstnl","title":"Nonlinear Evaluation","text":"","category":"section"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"FNL = zeros(mdl.Ndofs*Nhc);\ndFNLdU = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\ndFNLdw = zeros(mdl.Ndofs*Nhc);\nNLEVAL!(Uw0, mdl, h, N; FNL=FNL, dFNLdU=dFNLdU, dFNLdw=dFNLdw)","category":"page"},{"location":"d0_mdofgen_instnl/#HB-Residue","page":"d0mdofgeninstnl","title":"HB Residue","text":"","category":"section"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"R = zeros(mdl.Ndofs*Nhc);\ndRdU = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\ndRdw = zeros(mdl.Ndofs*Nhc);\nHBRESFUN!(Uw0, mdl, Fl, h, N; R=R, dRdU=dRdU, dRdw=dRdw)\n\nfun = NonlinearFunction((r,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; R=r),\n    jac=(J,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; dRdU=J),\n    paramjac=(Jp,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; dRdw=Jp));\n\nprob = NonlinearProblem(fun, Uw0[1:end-1], Uw0[end]);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"page"},{"location":"d0_mdofgen_instnl/#Continuation","page":"d0mdofgeninstnl","title":"Continuation","text":"","category":"section"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"Om0 = 0.1;\nOm1 = 3;\ndOm = 0.01;\n\ncpars = (parm=:arclength, nmax=2000, Dsc=:auto, minDsc=1e-5);\nsols, its, dss, xis, Dsc = CONTINUATE(Uw0[1:end-1], fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols), 2);\nfor i in 1:2\n    uh[h.+1, :, i] = hcat([[s.up[zinds[i:2:end]];\n                            s.up[rinds[i:2:end]]+1im*s.up[iinds[i:2:end]]]\n                          for s in sols]...);\nend\nOms = [s.up[end] for s in sols];\nnothing #hide","category":"page"},{"location":"d0_mdofgen_instnl/#Plot","page":"d0mdofgeninstnl","title":"Plot","text":"","category":"section"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"his = [1, 3, 5];\n\nfsz = 24;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    lines!(ax, Oms, abs.(uh[his[i].+1, :, 1]), label=\"x1\");\n    lines!(ax, Oms, abs.(uh[his[i].+1, :, 2]), label=\"x2\");\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    lines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    lines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\nend\n\n    fig","category":"page"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"","category":"page"},{"location":"d0_mdofgen_instnl/","page":"d0mdofgeninstnl","title":"d0mdofgeninstnl","text":"This page was generated using Literate.jl.","category":"page"},{"location":"a_hworld/#ex_a","page":"a_hworld","title":"Example a: Introduction to the AFT Routines","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"This example is intended to showcase the Alternating Frequency Time (AFT) routines in juliajim.HARMONIC.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"At its core, it is just a bunch of utility routines that allow time-to-frequency and frequency-to-time transformations. These can also be used for Chebyshev polynomial expansions, as will be seen below.","category":"page"},{"location":"a_hworld/#Preamble:-Load-the-necessary-packages","page":"a_hworld","title":"Preamble: Load the necessary packages","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing Arpack\n\nusing juliajim.HARMONIC","category":"page"},{"location":"a_hworld/#Alternating-Frequency-Time-Transformation","page":"a_hworld","title":"Alternating Frequency Time Transformation","text":"","category":"section"},{"location":"a_hworld/#AFT-Single-Frequency-(Periodic-signal)","page":"a_hworld","title":"AFT - Single Frequency (Periodic signal)","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Here we will use the AFT routine to do a Fourier transform of a time-domain signal, yt, to compute its Fourier coefficients, yf. The general form assumed for a Fourier series is:","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"y = a_0 + sum_n=1^H a_n cos ntau + sin ntau","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"where (\\tau) is the scaled time such that the signal y(tau) is 2pi-periodic. For instance, if the excitation frequency is Omega and physical time is t (such that we have 2piOmega as the time period), the scaled time coordinate tau is defined as tau=Omega t.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"The AFT routine provides a convenience utility for transforming from a discrete time array to an array of the Fourier coefficients which is written as","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"beginbmatrix a_0  a_1  b_1  a_2  b_2  dots endbmatrix","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"The same routine may also be used to do the opposite transformation (frequency coefficients to time array).","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"We first discretize time by dividing the domain 0 2pi into 128 parts.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"N = 128;\nt = (0:N-1)*2π/N;\n# yt = cos.(t) + 3sin.(2t) .+ 4;\nyt = cos.(t) .+ 2;\nyt = [yt yt];\nnothing #hide","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"We have put two copies of the vector yt in columns to expose the fact that the AFT routine is vectorized: Having time series in M columns will return corresponding Fourier coefficients in M columns.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Now we set the list of harmonics of interest. This can also be an unordered list, but if you're including the zeroth harmonic, that should always be the first.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"h = 0:3\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nnothing #hide","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"The variable Nhc is the number of harmonic coefficients. For the zeroth harmonics we have only one coefficient ((a0) above) and for every non-zero harmonic we have two, correponding to the sine and cosine ((ai,b_i) above). The formula above looks more complicated than it must because this works even for the multi-frequency case.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Now we call the actual AFT routine. The first argument is the time series vector (or matrix of column vectors), the second argument is the harmonic indices of interest, third is the number of AFT samples (when inputting the time vector N has to be the same as the number of rows of yt), and the last argument is a Symbol. The last argument specifies if we're interested in a time-to-frequency (:t2f) or frequency-to-time (:f2t) transformation.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"yf = AFT(yt, h, N, :t2f);  # Time to Frequency\nYT = AFT(yf, h, N, :f2t);  # Frequency to Time\nnothing #hide","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"yf is the list of harmonics and YT is the time vector reconstructed from the harmonics. You should be able to verify that yt and YT are numerically the same.","category":"page"},{"location":"a_hworld/#AFT-2-Frequency-Case-(Quasi-periodic-signal)","page":"a_hworld","title":"AFT - 2 Frequency Case (Quasi-periodic signal)","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Now we show how the same AFT routine can be used for multi-frequency Fourier representations. Our Fourier series representation is written as","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"y(t) = a_0 + sum_n=1^H a_n cos( h1_n tau_1 + h2_n tau_2) + b_n sin( h1_n tau_1 + h2_ntau_2 )textwith  tau_i = Omega_i t","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Here, (h1, h2) are index arrays storing the harmonic coefficient corresponding to the two frequencies present. The scaled time coordinates (aka Torus coordinates) (\\tau1,\\tau2) are defined as above such that the signal y(t) can be written as the torus function Y(\\tau_1,\\tau_2), which is periodic on the 2D domain. Note that y(t) and Y(tau_1 tau_2) are not the same, although we can reconstruct (y(t)) from (Y(\\tau1,\\tau2)).","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"The usage of the routine is identical to before.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"ts = Iterators.product(t, t);\nyt = [cos(t1)+3sin(t2)+4 for (t1,t2) in ts];\nh = [0 0;1 0;0 1;1 1];\n\nyf = AFT([yt[:] yt[:]], h, N, :t2f);\nYT = AFT(yf, h, N, :f2t);\nyf","category":"page"},{"location":"a_hworld/#Convenience-Routine-for-Harmonic-Selection:-[HSEL](@ref)","page":"a_hworld","title":"Convenience Routine for Harmonic Selection: HSEL","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Since harmonic selection in the 2D (and general N-D) case is not as trivial as writing 0:3 for the 1D case (different combinations of the indices must be considered on the tensor-grid while accounting for redundancies. The convenience routine HSEL helps to do this - one can specify the maximum harmonic order (Nhmax below) and the number of components (C below) and obtain a (H\\times C) matrix of indices.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"C = 2;\nNhmax = 4;\n\nh = HSEL(Nhmax, 1:C);  # Second argument is the list of frequencies\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nnothing #hide","category":"page"},{"location":"a_hworld/#The-\"Harmonic\"-Stiffness","page":"a_hworld","title":"The \"Harmonic\" Stiffness","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Harmonic Balance is a numerical technique where the solution for a dynamical system (expressed in second order form) is expressed in terms of its Fourier series. The resulting algebraic system is solved numerically. For a linear system, however, the algebraic system can be simplified significantly and written in a succinct (\\mx{E} \\vc{u} = \\vc{f}) form.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Consider a linear dynamical system with (n) Degrees-of-Freedom of the form:","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"mxM ddotvcx + mxC dotvcx + mxK vcx = vcF(t)quad vcxinmathbbR^n","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"We expand out the vector of unknowns (\\vc{x}) as","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"vcx = vca_0 + sum_n=1^H vca_n cos ntau + vcb_n sin ntautextwith  vca_ivcb_iin mathbbR^n","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"and write the vector of harmonic coefficients (\\vc{u}) as","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"vcu = beginbmatrix vca_0 vca_1 vcb_1 vca_2 vcb_2 vdots endbmatrix","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Substituting the harmonic ansatz into the governing equations and projecting the resulting residue onto the Fourier basis functions leads to:","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"beginbmatrix\nmxK  \nmxK-Omega^2 mxM  Omega mxC  \n-Omega mxC  mxK-Omega^2 mxM \nK-(2Omega)^2 mxM  (2Omega) mxC\n -(2Omega) mxC\nendbmatrix\nbeginbmatrix vca_0 vca_1 vcb_1 vca_2 vcb_2 vdots endbmatrix =\nbeginbmatrix vcf_a0 vcf_a1 vcf_b1 vcf_a2 vcf_b2 vdots endbmatrix","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"The HARMONICSTIFFNESS function provides a convenience routine for just this. It works for arbitrary number of frequency components also. The usage is as follows. Since the frequency jacobian of this matrix is often necessary, this is also returned by the routine. There is also an in-place version of this in HARMONICSTIFFNESS!.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"M = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nC = 2;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C)\nws = [1, π];\nws = ws[1:C];\n\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\nE","category":"page"},{"location":"a_hworld/#Forced-Response-Computation-with-[HARMONIC](@ref)","page":"a_hworld","title":"Forced Response Computation with HARMONIC","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"We shall now use the above utilites to compute the forced response of a linear system. The code below should be self explanatory.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"C = 1;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C);\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nFl = zeros(Nhc, 1);\nFl[2] = 1.0;\nFl = kron(Fl, [1;0]);\n\nOmr, V = eigen(K, collect(M));\nOmr = sqrt.(Omr);\n\nΩs = LinRange(0.5, 2, 500);\nAs = zeros(ComplexF64, size(Ωs));\n\nfor i = eachindex(Ωs)\n    local E, dEdw\n    E, dEdw = HARMONICSTIFFNESS(M, D, K, [Ωs[i]], h);\n    U = E\\Fl;\n    As[i] = U[3]+im*U[5];\nend\n\nset_theme!(theme_latexfonts())\nfsz = 18;\nfig = Figure(fontsize=fsz);\nif !isdefined(Main, :scr) && Makie.current_backend()==GLMakie # src\n    scr = GLMakie.Screen(); # src\nend # src\n\nax = Axis(fig[1, 1],\n    xlabel=\"Excitation Frequency (rad/s)\",\n    ylabel=\"Response Amplitude (m)\",\n    xscale=Makie.pseudolog10,\n    yscale=Makie.pseudolog10);\nlines!(ax, Ωs, abs.(As))\n\n    fig","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"This page was generated using Literate.jl.","category":"page"},{"location":"b_duffhb/#ex_b","page":"b_duffhb","title":"Example b","text":"","category":"section"},{"location":"b_duffhb/#Preamble:-Load-packages","page":"b_duffhb","title":"Preamble: Load packages","text":"","category":"section"},{"location":"b_duffhb/","page":"b_duffhb","title":"b_duffhb","text":"using GLMakie\nusing LaTeXStrings\nusing LinearAlgebra\nusing NonlinearSolve\nusing ForwardDiff\nusing DSP\nusing Infiltrator\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION","category":"page"},{"location":"b_duffhb/#Residue-Function","page":"b_duffhb","title":"Residue Function","text":"","category":"section"},{"location":"b_duffhb/","page":"b_duffhb","title":"b_duffhb","text":"function RESFUN!(Uw, Fl, pars, h, Nt; R=nothing, dRdU=nothing, dRdw=nothing)\n    (; z0, w0, al, F) = pars;\n\n    Om = Uw[end];\n    Nhc = sum((h.==0)+2(h.!=0));\n\n    # Linear Portion\n    E, dEdw = HARMONICSTIFFNESS(1.0, 2z0*w0, w0^2, Om, h);\n\n    # AFT For nonlinear force\n    ut  = AFT(Uw[1:end-1], h, Nt, :f2t);\n\n    # Construct Residue\n    if !(R === nothing)\n        ft  = al*ut.^3;\n        Fnl = AFT(ft, h, Nt, :t2f);\n\n        R[:] = E*Uw[1:end-1] + Fnl - Fl*F;\n    end\n    if !(dRdU === nothing)\n        cst = AFT(Float64.(I(Nhc)), h, Nt, :f2t);\n        dfdat = (3al*ut.^2) .* cst;\n        Jnl    = AFT(dfdat, h, Nt, :t2f);\n\n        dRdU[:, :] = E + Jnl;\n    end\n    if !(dRdw === nothing)\n        dRdw[:] = dEdw*Uw[1:end-1];\n    end\n    return nothing;\nend","category":"page"},{"location":"b_duffhb/#Setup","page":"b_duffhb","title":"Setup","text":"","category":"section"},{"location":"b_duffhb/","page":"b_duffhb","title":"b_duffhb","text":"ξ = 1e0;\npars = (z0 = 0.5e-2, w0 = 2., al = 0.1*ξ^2, F = 0.1/ξ);\n\nh = (0:5);\n# h = 1:2:5;\nOm = 0.1;\n\nNhc = sum((h.==0)+2(h.!=0));\nNt = 2^9;\n\nFl = zeros(Nhc);\n_,_,zinds,rinds,iinds = HINDS(1, h)\nFl[rinds[1]] = 1.0;\n\nfun = NonlinearFunction((r,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;R=r),\n                        jac=(J,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdU=J),\n                        paramjac=(Jp,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdw=Jp));\n\nE = zeros(Nhc, Nhc);\nHARMONICSTIFFNESS!(E, nothing, 1.0, 2pars.z0*pars.w0, pars.w0^2, Om, h);\nU0 = E\\ (Fl*pars.F);\n\nprob = NonlinearProblem(fun, U0, Om);\nsol = solve(prob, show_trace=Val(true))\n\nR = zeros(Nhc);\nJf = zeros(Nhc, Nhc+1);\nJ = @view Jf[:, 1:Nhc];\nJp = @view Jf[:, end];\nnothing #hide","category":"page"},{"location":"b_duffhb/#Continuation","page":"b_duffhb","title":"Continuation","text":"","category":"section"},{"location":"b_duffhb/","page":"b_duffhb","title":"b_duffhb","text":"Om0 = 2pars.w0;\nOm1 = 0.02pars.w0;\n\nHARMONICSTIFFNESS!(E, nothing, 1.0, 2pars.z0*pars.w0, pars.w0^2, Om0, h);\nU0 = E\\ (Fl*pars.F);\n\nfun = NonlinearFunction((r,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;R=r),\n                        jac=(J,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdU=J),\n                        paramjac=(Jp,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdw=Jp));\n\ndOm = 0.04pars.w0;\ndOm = 0.1pars.w0;\ncpars = (parm=:arclength, nmax=2000);\nsols, its, dss, xis, Dsc = CONTINUATE(U0, fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols));\nuh[h.+1, :] = hcat([[s.up[zinds]; s.up[rinds]+1im*s.up[iinds]] for s in sols]...);\nOms = [s.up[end] for s in sols];\nnothing #hide","category":"page"},{"location":"b_duffhb/#Plotting","page":"b_duffhb","title":"Plotting","text":"","category":"section"},{"location":"b_duffhb/","page":"b_duffhb","title":"b_duffhb","text":"his = [1, 3, 5];\n\nfsz = 24;\nfig = Figure(fontsize=fsz, size = (1000, 600));\n\nax1s = [];\nax2s = [];\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i], ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :]));\n    push!(ax1s, ax);\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n              ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :])));\n    push!(ax2s, ax);\nend\nlinkxaxes!(vcat(ax1s, ax2s)...)\n\n    fig","category":"page"},{"location":"b_duffhb/","page":"b_duffhb","title":"b_duffhb","text":"","category":"page"},{"location":"b_duffhb/","page":"b_duffhb","title":"b_duffhb","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#juliajim.juliajim","page":"Reference","title":"juliajim.juliajim","text":"The main juliajim module\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.HARMONIC","page":"Reference","title":"juliajim.HARMONIC","text":"Useful routines for Harmonic Balance. Also includes Chebyshev Galerkin utilites.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.HARMONIC.ACT-NTuple{4, Any}","page":"Reference","title":"juliajim.HARMONIC.ACT","text":"ACT(yin, h::hTypes, N::Int64, dir::Symbol)\n\nRoutine for the alternating Chebyshev Transform. Uses AFT internally. \n\nArguments\n\nyin              : \nh::hTypes : \nN::Int64         : \ndir::Symbol      : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.AFT-NTuple{4, Any}","page":"Reference","title":"juliajim.HARMONIC.AFT","text":"AFT(yin, h::hTypes, N::Int64, dir::Symbol);\n\nRoutine to conduct Time-to-Frequency and Frequency-to-Time transforms for the general Multi frequency case.\n\nArguments\n\nyin::VecOrMat{Float64}: (N^C, Ny) if time data, and (Nhc, Ny) if frequency data.\nh::hTypes: (Nh, C) list of harmonics.\nN::Int64: Number of time samples for AFT.\ndir::Symbol: :t2f for time-to-frequency, and :f2t for frequency-to-time.\n\nExamples\n\nSingle Frequency Case:\n\n    N = 8;\n    t = (0:N-1)*2π/N;\n    yt = cos.(t) + 3sin.(2t) .+ 4;\n    yt = [yt yt];\n\n    h = collect(0:3)[:,:];\n    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\n    yf = AFT(yt, h, N, :t2f);\n    YT = AFT(yf, h, N, :f2t);\n\n2-Frequency Case:\n\n    t1 = repeat(t, 1, N);\n    t2 = repeat(t', N, 1);\n\n    yt = cos.(t1) + 3sin.(t2) .+ 4;\n    h = [0 0;1 0;0 1;1 1];\n    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\n    yf = AFT([yt[:] yt[:]], h, N, :t2f);\n    YT = AFT(yf, h, N, :f2t);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.DCHEB-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.HARMONIC.DCHEB","text":"DCHEB(h::hTypes)\n\nReturns the Chebyshev Differentiation matrix.\n\nArguments\n\nh::hTypes : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.DFOUR","page":"Reference","title":"juliajim.HARMONIC.DFOUR","text":"DFOUR(h::hTypes, ws=nothing)\n\nReturns the Fourier differentiation matrix (useful for HB representations).\n\nArguments\n\nh::hTypes : (H, C) Harmonic indices\nws::Array{Float64} : (C, 1) (optional) list of frequencies\n\nOutputs\n\nD : (Nhc, Nhc) Harmonic differentiation matrix\ndDdw : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.DFOUR!","page":"Reference","title":"juliajim.HARMONIC.DFOUR!","text":"DFOUR!(h::hTypes, D, dDdw=nothing, ws=nothing)\n\nBang version of DFOUR.\n\nArguments\n\nh::hTypes : (H, C) Harmonic indices\nD : (Nhc, Nhc) Harmonic differentiation matrix\ndDdw : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).\nws::Array{Float64} : (C, 1) (optional) list of frequencies\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.FSEVAL","page":"Reference","title":"juliajim.HARMONIC.FSEVAL","text":"FSEVAL(h::hTypes, t::Union{StepRangeLen{Float64}, VecOrMat{Float64}}, U::Union{Nothing,Matrix{Float64}}=nothing)\n\nDescription\n\nEvaluates the Fourier series at required time points. If Fourier coefficients are not provided, it returns the mapping matrix.\n\nArguments\n\nh::hTypes                      : \nt::Union{StepRangeLen{Float64} : \nVecOrMat{Float64}}             : \nU::Union{Nothing               : \nMatrix{Float64}}               : (default nothing)\n\nOutputs\n\nut\t: In case U is provided, this is outputted first.\nJ\t: The mapping matrix such that J*U gives the desired temporal evaluates.\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.HARMONICSTIFFNESS!-NTuple{7, Any}","page":"Reference","title":"juliajim.HARMONIC.HARMONICSTIFFNESS!","text":"HARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h)\n\nBang version of HARMONICSTIFFNESS (preallocate E, dEdw).\nAdvantage is that nothing can be passed to avoid needless computations.\n\nArguments\n\nE: (NdNhc, NdNhc) Harmonic Stiffness\ndEdw: C-Vector of (NdNhc, NdNhc) Representing Frequency-gradients of E\n'M, D, K': (Nd,Nd) Mass, Damping, Stiffness Matrices.\n'ws::Array{Float64}': (C,1) list of frequencies\n'h': (H, C) harmonic indices\n\nExamples\n\nSingle Frequency Case\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nh = [0;1;2;3];\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nE = zeros(2*Nhc, 2*Nhc);\ndEdw = zeros(2*Nhc, 2*Nhc);\nws = 1;\nHARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);\n\n2-Frequency Case\n\nNhmax = 3;\nws = [1; π];\nh = HSEL(Nhmax, ws);\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nE = zeros(2*Nhc, 2*Nhc);\ndEdw = zeros(2*Nhc, 2*Nhc);\nHARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HARMONICSTIFFNESS-NTuple{5, Any}","page":"Reference","title":"juliajim.HARMONIC.HARMONICSTIFFNESS","text":"HARMONICSTIFFNESS(M, D, K, ws::Array{Float64}, h)\n\nComputes the harmonic stiffness for HB simulations.\n\nArguments\n\n'M, D, K': (Nd,Nd) Mass, Damping, Stiffness Matrices.\n'ws::Array{Float64}': (C,1) list of frequencies\n'h': (H, C) harmonic indices\n\nOutputs\n\nE: (NdNhc, NdNhc) Harmonic Stiffness\ndEdw: C-Vector of (NdNhc, NdNhc) Representing Frequency-gradients of E\n\nExamples\n\nSingle Frequency Case\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nh = [0;1;2;3];\nws = 1;\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\n\n2-Frequency Case\n\nNhmax = 3;\nws = [1; π];\nh = HSEL(Nhmax, ws);\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.HARMONIC.HINDS","text":"HINDS(Ndofs::Int64, h::hTypes)\n\nArguments\n\nNdofs::Int64     : \nh::hTypes :\n\nOutputs\n\nzinds\nhinds\nrinds0\nrinds\niinds\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HSEL","page":"Reference","title":"juliajim.HARMONIC.HSEL","text":"HSEL(Nhmax::Int64, ws::Any=1, hcr::Int=1)\n\nSelection of Harmonic indices based on different criteria. First C+1 rows are [zeros(1,C); I(C)].\n\nImplemented criteria are,\n\nhcr=1: Σᵢ |hᵢ| < Nhmax & ∑ᵢ h_i ≥ 0\n\nArguments\n\nNhmax::Int64: Max harmonic for truncation.\nws=1: [opt] List of frequencies\nhcr::Int=1: [opt] Truncation criterion. See above.\n\nExamples\n\nC = 2;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.PRODMAT_CHEB","page":"Reference","title":"juliajim.HARMONIC.PRODMAT_CHEB","text":"Description\n\nArguments\n\nU    : \nh    : \nHmax : (default nothing)\nD    : (default nonothing)\nL    : (default nonothing)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.PRODMAT_FOUR","page":"Reference","title":"juliajim.HARMONIC.PRODMAT_FOUR","text":"PRODMAT_FOUR(U::VecOrMat{Float64}, h::hTypes, Hmax=nothing, D=nothing, L=nothing)\n\nDescription\n\nReturns the Fourier product matrix. Currently only implemented for C=1.\n\nArguments\n\nU::VecOrMat{Float64}\t\t: \nh::hTypes    \t\t\t: \nHmax \t\t\t\t: (default nothing)\nD    \t\t\t\t: (default nothing)\nLb   \t\t\t\t: (default nothing)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.CONTINUATION","page":"Reference","title":"juliajim.CONTINUATION","text":"Useful types and routines for numerical continuation.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.CONTINUATION.myNLSoln","page":"Reference","title":"juliajim.CONTINUATION.myNLSoln","text":"myNLSoln\n\nStruct storing the solution, Jacobian, and (unit) tangent.\n\nFields\n\nup::nvTypes: Solution point ([u;p])\nJ::nmTypes: Jacobian dr/du\nJp::nvTypes: Parameter Jacobian dr/dp\ndupds::nvTypes: Tangent vector (has to be vector only)  \n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.CONTINUATION.myNLSoln-2","page":"Reference","title":"juliajim.CONTINUATION.myNLSoln","text":"myNLSoln(up::nvTypes=nothing; J::nmTypes=nothing, Jp::nvTypes=nothing)\n\nConstructor for myNLSoln. Can specify one or all the arguments (point, jacobian, paramjac).\n\nArguments\n\nup::nvTypes       : (default nothing) Solution point\nJ::nmTypes        : (default nothing) Jacobian\nJp::nvTypes       : (default nothing) paramjac\nsave_jacs::Bool   : (default false) Whether or not to store the Jacobians.\n\nIf both J and Jp are provided, the unit tangent dupds is computed using nullspace([J Jp])[:,1].\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:--Tuple{myNLSoln, myNLSoln}","page":"Reference","title":"Base.:-","text":"Base.:-(v1::myNLSoln, v2::myNLSoln)\n\nOverloading the subtraction operator to take the difference between two myNLSoln \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, myNLSoln}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, p::myNLSoln)\n\nOverloading base show function to display myNLSoln object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.CONTINUATION.CONTINUATE-Tuple{Vector{Float64}, Any, Vector{Float64}, Float64}","page":"Reference","title":"juliajim.CONTINUATION.CONTINUATE","text":"CONTINUATE(u0, fun, ps, dp; kwargs...)\n\nContinuation routine. Solves the bordered problem with residue drawn from EXTRESFUN!.\n\nArguments\n\nu0::Vector{Float64}                          : Initial guess for first point\nfun                                          : NonlinearFunction object. Will call:\nfun.f(du, u, p) for residue r. p must be scalar.\nfun.jac(J, u, p) for jacobian dr/du. Uses ForwardDiff.jacobian! if fun.jac is nothing.\nfun.paramjac(Jp, u, p) for jacobian dr/dp. Uses ForwardDiff.jacobian! if fun.paramjac is nothing.\nps::Vector{Float64}                          : Specify range of p for continuation.\ndp::Float64                                  : Specify first step in Δp units. (will be rescaled if necessary)\n\nOptional Arguments\n\nparm::Symbol                                 : (default :arclength) Arclength parameterization. See EXTRESFUN!.\nnmax::Int64                                  : (default 1000) Maximum number of steps.\ndpbnds::Union{Nothing,Vector{Float64}}       : (default [dp/5,5dp]) Bounds for the step length dp. (Rescaled as appropriate)\nsave_jacs::Bool                              : (default false) Specify whether or not to save the Jacobians in the output. Only solution and (unit) tangent are saved if false.\nverbosity::Int                               : (default 1) Verbosity levels:\n0: Suppress all messages.\n1: Display Steps, Continuation Progress.\n2: Display Iteration Information for each step also.\n\nFor Scaling of Unknowns (recommended to get evenly spaced points on response curve)\n\nDsc::Union{Symbol,Nothing,Vector{Float64}}   : (default :none) \"Dscaling\" used to scale the unknowns. The arc length constraint is applied in the scaled space (uₛ=uₚₕ./Dsc).\nIf set to :auto, it uses the absolute of the first converged solution as the initial Dsc vector. Zero entries are replaced with minDsc.\nIf set to :none, it fixes Dsc to a vector of ones and doesn't dynamically adapt it. (this forces DynScale to false).\nIf set to :ones, it fixes Dsc to a vector of ones but dynamically continues to scale.\nDynScale::Bool                               : (default true) Whether or not to dynamically adapt the Dsc vector. Each entry is allowed to grow or shrink by a maximum factor of 2 in each step if true.\nminDsc::Float64                              : (default eps()^(4//5)=3e-13) Minimum value for Dscale.\n\nFor Step Length Adaptation. Currently set as dsₙ = dsₒ * xi, where xi = clamp((itopt/itns)^nxi, xirange[1], xirange[2]).\n\nitopt::Union{Symbol,Int}                     : (default :auto) Optimal number of  \nnxi::Float64                                 : (default 0.0) Switches off adaptation by default. \nxirange::Vector{Float64}                     : (default [0.5,2.])\n\nReturns\n\nvector{myNLsoln} representing solutions.\nvector{Int} representing iterations taken.\nvector{Float64} representing step sizes.\nvector{Float64} representing adaptation parameter ξ.\nvector{Float64} representing the final Dscale matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.CONTINUATION.EXTRESFUN!-NTuple{4, Any}","page":"Reference","title":"juliajim.CONTINUATION.EXTRESFUN!","text":"EXTRESFUN!(up::nvTypes, fun, sol0::myNLSoln, ds::Float64; parm::Symbol=:riks, Dsc::Vector{Float64}, dup::nvTypes=nothing, Jf::nmTypes=nothing)\n\nReturns the bordered/extended residue function. Appends residue with required arclength constraint.\n\nNote\n\nThe function involves very naive autodiff calls. Does not respect or try to detect jacobian sparsity. For now it is best to provide analytical jacobians for very large problems. \n\nArguments\n\nup::nvTypes: Solution point for evaluation\nfun: Nonlinear function specified in a fashion that can be called as\nfun.f(du,up[1:end-1],up[end]) for the residue.\nfun.jac(J,up[1:end-1],up[end]) for the jacobian (uses ForwardDiff.jacobian! if fun.jac is nothing)\nfun.paramjac(Jp,up[1:end-1],up[end]) for the parameter jacobian (uses ForwardDiff.jacobian! if fun.paramjac is nothing)\nDevelopment Done based on NonlinearFunction from NonlinearSolve\nsol0::myNLSoln: Previous solution point.\nds::Float64: Step size.\nparm::Symbol=:riks: Arclength parameterization. Defaults to :riks. Possible are:\n:riks: Riks' or normal parameterization.\n:arclength: Arclength parameterization.\nDsc::Vector{Float64}: Scaling vector. Recommended to be of the order of magnitude of the expected unknowns. Size same as up.\ndup::nvTypes=nothing: Residue vector (for iip evaluation)\nJf::nmTypes=nothing: Jacobian matrix (for iip evaluation)\n\nReturns\n\ndup::nvTypes=nothing: Residue vector (for iip evaluation)\nJf::nmTypes=nothing: Jacobian matrix (for iip evaluation)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS","page":"Reference","title":"juliajim.MDOFUTILS","text":"Useful types and routines for dynamic analyses of MDOF problems.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.MDOFUTILS.MDOFGEN","page":"Reference","title":"juliajim.MDOFUTILS.MDOFGEN","text":"MDOFGEN\n\nStruct storing the generic MDOF system.\n\nFields\n\nM::Matrix{Float64}: Mass matrix\nC::Matrix{Float64}: Damping Matrix\nK::Matrix{Float64}: Stiffness Matrix\nL: Displacement Transform Matrix (can be empty)\nNdofs::Int64: Number of DOFs\nNLTs::Vector{NONLINEARITY}: Vector of nonlinearities present (see NONLINEARITY)\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.MDOFUTILS.NONLINEARITY","page":"Reference","title":"juliajim.MDOFUTILS.NONLINEARITY","text":"NONLINEARITY\n\nStruct storing a nonlinearity.\n\nFields\n\ntype::Symbol: Type of nonlinearity. One of:\n:Inst (for instantaneous nonlinearity)\n:Hyst (for hysteretic nonlinearity)\n:Fdom (for nonlinearity defined in frequency domain)\nOut of these, only the first 2 can be used for transient simulations.\nfunc::Function: Function handle for evaluating nonlinearity. Has signature\n(t, u, udot) for :Inst\n(t, u, up, sp) for :Hyst, where s is some internal state (sp is s at t-Δt)\nL::Matrix{Float64}: Selection Matrix\nLf: Force shape matrix (can be empty)\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.MDOFUTILS.EPMCRESFUN!-Tuple{Any, MDOFGEN, Any, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.EPMCRESFUN!","text":"Description\n\nArguments\n\nUwxa                : \nm::MDOFGEN          :\nFl                  : (Nd*Nhc) Forcing vector. Zero harmonics are used as static loads. Harmonic portions are used to provide phase constraint.\nh                   : \nN::Int64            : \ntol::Float64        : (default eps()^(4//5))\natype::Symbol       : (default :H1)\nashape::Union{Int64 : \nVector{Float64}}    : (default 1)\nR                   : (default nothing)\ndRdUwx              : (default nothing)\ndRda                : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.HBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.HBRESFUN!","text":"Description\n\nResidue function that can be used for Harmonic Balance forced response analysis.\n\nArguments\n\nUw   : \nm    : \nFl   : \nh    : \nN    : \ntol  : \ndRdU : \ndRdw : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.HBRESFUN_A!-Tuple{Any, MDOFGEN, Float64, Any, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.HBRESFUN_A!","text":"Description\n\nHB residue with amplitude constraint.\n\nArguments\n\nUfw           : \nm::MDOFGEN    : \nA::Float64    : Amplitude level (also see atype below)\nFl            : \nh             : \nN::Int64      :\natype::Symbol : (default :H1) One of :H1, :RMS. Type of amplitude measure.\nashape        : (default 1) Shape to dof for applying amplitude. If Integer, interpreted as Dof. If vector, taken as shape.\ntol::Float64  : (default eps()^(4//5))\nR             : (default nothing)\ndRdUf         : (default nothing)\ndRdw          : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NEWMARKMARCH-Tuple{MDOFGEN, Vararg{Any, 6}}","page":"Reference","title":"juliajim.MDOFUTILS.NEWMARKMARCH","text":"Description\n\nArguments\n\nm::MDOFGEN : \nT0         : \nT1         : \ndt         : \nU0         : \nUd0        : \nFex        : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NLEVAL!-Tuple{Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, MDOFGEN, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.NLEVAL!","text":"Description\n\nEvaluate the nonlinearities (and Jacobian) for one period and return the harmonics\n\nArguments\n\nUw         : \nm::MDOFGEN :\nh          :\nN::Int64   : [optional]\ntol        :   \nFNL        : \ndFNLdU     : \ndFNLdw     : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NLFORCE-Tuple{MDOFGEN, Any, Any, Any}","page":"Reference","title":"juliajim.MDOFUTILS.NLFORCE","text":"Description\n\nArguments\n\nm::MDOFGEN : \nt          : \nU          : \nUd         : \ntp         : (default nothing)\nUp         : (default nothing)\nUdp        : (default nothing)\nSp         : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"d3_mdofgen_epmc/#ex_d3","page":"d3mdofgenepmc","title":"Example d3","text":"","category":"section"},{"location":"d3_mdofgen_epmc/#Preamble:-Load-Packages","page":"d3mdofgenepmc","title":"Preamble: Load Packages","text":"","category":"section"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"page"},{"location":"d3_mdofgen_epmc/#System-Setup","page":"d3mdofgenepmc","title":"System Setup","text":"","category":"section"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"M = I(2);\nK = [2 -1;-1 2];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\n\n# Nonlinearity\nkt = 1.0;\nfs = 1.0;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\nL = [0.0 1.0];\n\nmdl = ADDNL(mdl, :Hyst, fnl, L);\nnothing #hide","category":"page"},{"location":"d3_mdofgen_epmc/#Linear-Modal-Analysis","page":"d3mdofgenepmc","title":"Linear Modal Analysis","text":"","category":"section"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"Knl0 = L'kt*L;\nK0 = mdl.K+Knl0;\nD, V = eigen(K0, mdl.M)\nW0s = sqrt.(D);\nXis = diag(V'mdl.C*V)\n\nmi = 1;  # Mode of interest\nnothing #hide","category":"page"},{"location":"d3_mdofgen_epmc/#Trial","page":"d3mdofgenepmc","title":"Trial","text":"","category":"section"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"h = HSEL(3, 1.0);\nh = 1:2:3;\nh = 0:5;\nN = 256;\nt = (0:N-1)*2π/N;\n\nNhc = sum(all(h.==0, dims=2) + 2any(h.!=0, dims=2));\n\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h)\nFl = zeros(Nhc*mdl.Ndofs);\nFl[rinds[1]] = 1.0;\n\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, W0s[mi], h);\n\nU0 = zeros(mdl.Ndofs*Nhc);\nU0[iinds[1:mdl.Ndofs]] = V[:, mi];\nnothing #hide","category":"page"},{"location":"d3_mdofgen_epmc/#EPMC-Residue","page":"d3mdofgenepmc","title":"EPMC Residue","text":"","category":"section"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"R = zeros(mdl.Ndofs*Nhc+2);\ndRdU = zeros(mdl.Ndofs*Nhc+2, mdl.Ndofs*Nhc+2);\ndRda = zeros(mdl.Ndofs*Nhc+2);\n\nEPMCRESFUN!([U0; W0s[mi]; Xis[mi]; -2], mdl, Fl, h, N; R=R, dRdUwx=dRdU, dRda=dRda)","category":"page"},{"location":"d3_mdofgen_epmc/#","page":"d3mdofgenepmc","title":"","text":"","category":"section"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"A0 = -2.0;\n\nU0 = zeros(mdl.Ndofs*Nhc);\n# U0[rinds[1:mdl.Ndofs]] = (10^A0)*V[:, mi];\nU0[iinds[1:mdl.Ndofs]] = V[:, mi];\n\nfun = NonlinearFunction((r,uwx,p)->EPMCRESFUN!([uwx;p], mdl, Fl, h, N; R=r),\n    jac=(J,uwx,p)->EPMCRESFUN!([uwx;p], mdl, Fl, h, N; dRdUwx=J),\n    paramjac=(Jp,uwx,p)->EPMCRESFUN!([uwx;p], mdl, Fl, h, N; dRda=Jp));\n\nprob = NonlinearProblem(fun, [U0;W0s[mi];Xis[mi]], A0);\nsol = solve(prob, show_trace=Val(true), maxiters=100);\nnothing #hide","category":"page"},{"location":"d3_mdofgen_epmc/#Continuation","page":"d3mdofgenepmc","title":"Continuation","text":"","category":"section"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"A0 = -1.;\nA1 = 3.;\nda = 0.05;\n\ncpars = (parm=:arclength, nmax=1000, Dsc=:none, itopt=4, dpbnds=[da/5, 2da]);\nsols, its, dss, xis, Dsc = CONTINUATE([U0;W0s[mi];Xis[mi]], fun, [A0, A1], da; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols), 2);\nfor i in 1:2\n    uh[h.+1, :, i] = hcat([[s.up[zinds[i:2:end]];\n                            s.up[rinds[i:2:end]]+1im*s.up[iinds[i:2:end]]]\n                          for s in sols]...);\nend\nOms = [s.up[end-2] for s in sols];\nZts = [s.up[end-1] for s in sols]./2Oms;\nAs = [10^s.up[end] for s in sols];\nnothing #hide","category":"page"},{"location":"d3_mdofgen_epmc/#Plot","page":"d3mdofgenepmc","title":"Plot","text":"","category":"section"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"his = [1, 3, 5];\n\nset_theme!(theme_latexfonts());\nfsz = 20;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\naxs = [];\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m)\", xscale=log10, yscale=log10);\n    scatterlines!(ax, As, abs.(uh[his[i].+1, :, 1]), label=\"x1\");\n    scatterlines!(ax, As, abs.(uh[his[i].+1, :, 2]), label=\"x2\");\n    push!(axs, ax)\n\n    ax = Axis(fig[2, i], xlabel=L\"Modal Amplitude $a$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\", xscale=log10);\n    scatterlines!(ax, As, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    scatterlines!(ax, As, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\n    push!(axs, ax)\nend\nax = Axis(fig[1, length(his)+1],\n    ylabel=L\"Natural Frequency $\\omega_n$ (rad/s)\", xscale=log10);\nscatterlines!(ax, As, Oms);\npush!(axs, ax)\n\nax = Axis(fig[2, length(his)+1], xlabel=L\"Modal Amplitude $a$\",\n    ylabel=\"Damping Factor (%)\", xscale=log10);\nscatterlines!(ax, As, 100Zts);\npush!(axs, ax)\n\nlinkxaxes!(axs...)\n\n    fig","category":"page"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"","category":"page"},{"location":"d3_mdofgen_epmc/","page":"d3mdofgenepmc","title":"d3mdofgenepmc","text":"This page was generated using Literate.jl.","category":"page"},{"location":"d2_mdofgen_ahb/#ex_d2","page":"d2mdofgenahb","title":"Example d2","text":"","category":"section"},{"location":"d2_mdofgen_ahb/#Preamble:-Load-Packages","page":"d2mdofgenahb","title":"Preamble: Load Packages","text":"","category":"section"},{"location":"d2_mdofgen_ahb/","page":"d2mdofgenahb","title":"d2mdofgenahb","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"page"},{"location":"d2_mdofgen_ahb/#System-Setup","page":"d2mdofgenahb","title":"System Setup","text":"","category":"section"},{"location":"d2_mdofgen_ahb/","page":"d2mdofgenahb","title":"d2mdofgenahb","text":"M = I(2);\nK = [2 -1;-1 2];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\n\n# Nonlinearity\nkt = 1.0;\nfs = 1.0;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\nL = [0.0 1.0];\n\nmdl = ADDNL(mdl, :Hyst, fnl, L);\nnothing #hide","category":"page"},{"location":"d2_mdofgen_ahb/#Trial","page":"d2mdofgenahb","title":"Trial","text":"","category":"section"},{"location":"d2_mdofgen_ahb/","page":"d2mdofgenahb","title":"d2mdofgenahb","text":"h = HSEL(3, 1.0);\nh = 1:2:5;\n# h = 0:5;\nN = 256;\nt = (0:N-1)*2π/N;\n\nNhc = sum(all(h.==0, dims=2) + 2any(h.!=0, dims=2));\n\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h)\nFl = zeros(Nhc*mdl.Ndofs);\nFl[rinds[1]] = 1.0;\n\nWst = 0.6;\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Wst, h);\nU0 = E\\Fl;\nnothing #hide","category":"page"},{"location":"d2_mdofgen_ahb/#HB-Residue","page":"d2mdofgenahb","title":"HB Residue","text":"","category":"section"},{"location":"d2_mdofgen_ahb/","page":"d2mdofgenahb","title":"d2mdofgenahb","text":"R = zeros(mdl.Ndofs*Nhc+1);\ndRdUf = zeros(mdl.Ndofs*Nhc+1, mdl.Ndofs*Nhc+1);\ndRdw = zeros(mdl.Ndofs*Nhc+1);\nAmp = 1e0;\ndof = 1;\n\nHBRESFUN_A!([U0; 1.0; Wst], mdl, Amp, Fl, h, N; R=R, dRdUf=dRdUf, dRdw=dRdw)\n\nfun = NonlinearFunction((r,uf,p)->HBRESFUN_A!([uf;p], mdl, Amp, Fl, h, N; R=r),\n    jac=(J,uf,p)->HBRESFUN_A!([uf;p], mdl, Amp, Fl, h, N; dRdUf=J),\n    paramjac=(Jp,uf,p)->HBRESFUN_A!([uf;p], mdl, Amp, Fl, h, N; dRdw=Jp));\n\nprob = NonlinearProblem(fun, [U0;1.0], Wst);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"page"},{"location":"d2_mdofgen_ahb/#Continuation","page":"d2mdofgenahb","title":"Continuation","text":"","category":"section"},{"location":"d2_mdofgen_ahb/","page":"d2mdofgenahb","title":"d2mdofgenahb","text":"Om0 = 0.1;\nOm1 = 3;\ndOm = 0.1;\n\ncpars = (parm=:arclength, nmax=400, Dsc=:none, itopt=4);\nsols, its, dss, xis, Dsc = CONTINUATE([U0;1.0], fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols), 2);\nfor i in 1:2\n    uh[h.+1, :, i] = hcat([[s.up[zinds[i:2:end]];\n                            s.up[rinds[i:2:end]]+1im*s.up[iinds[i:2:end]]]\n                          for s in sols]...);\nend\nOms = [s.up[end] for s in sols];\nFs = [s.up[end-1] for s in sols];\nnothing #hide","category":"page"},{"location":"d2_mdofgen_ahb/#Plot","page":"d2mdofgenahb","title":"Plot","text":"","category":"section"},{"location":"d2_mdofgen_ahb/","page":"d2mdofgenahb","title":"d2mdofgenahb","text":"his = [1, 3, 5];\n\nset_theme!(theme_latexfonts())\nfsz = 24;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m/N)\", yscale=log10);\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :, 1])./Fs, label=\"x1\");\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :, 2])./Fs, label=\"x2\");\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\nend\n\n    fig","category":"page"},{"location":"d2_mdofgen_ahb/","page":"d2mdofgenahb","title":"d2mdofgenahb","text":"","category":"page"},{"location":"d2_mdofgen_ahb/","page":"d2mdofgenahb","title":"d2mdofgenahb","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"The examples are organized in an order of increasing complexity.","category":"page"},{"location":"examples/#Example-code-snippet","page":"Overview","title":"Example code snippet","text":"","category":"section"},{"location":"examples/","page":"Overview","title":"Overview","text":"using juliajim.HARMONIC\n\nN = 8\nt = (0:N-1)*2pi/N;\ny = cos.(t);\nh = 0:3;\nYh = AFT(y, h,N, :t2f);","category":"page"},{"location":"#Welcome-to-the-juliajim-Documentation!","page":"Home","title":"Welcome to the juliajim Documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation page. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Why should you be interested?\nHere's my vision for the package: I would like to use a singly specified dynamical system to subject it to different types of analyses. This includes transient simulations, steady-state periodic/quasi-periodic, etc.If this is interesting to you, you may find value in the project. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that this is still under heavy development. It is functional but the documentation needs a lot of work. Please reach out to me in case you're interested in contributing, share the vision, and have started loving Julia! :-)","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a set of Julia routines to help with computational research in nonlinear structural dynamics. Most of the content is derived from my earlier efforts (functional but badly maintained) with MATLAB/Octave at https://github.com/Nidish96/octave-jim.","category":"page"},{"location":"#Why-yet-another-package?","page":"Home","title":"Why yet another package?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each programming language/environment/specification you choose (MATLAB, Python, Julia, C/C++, etc.) has its own host of libraries that can do a lot of what juliajim sets out to do. Notable examples include Trilinos (C++) and the SciML ecosystem (Julia), which can do what juliajim sets out and (FAR!) more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"My vision for this tool is this: I'd like to be able to specify a system once and conduct different types of analysis on it. This mainly includes nonlinear static solves, transient time-marching (also shooting for periodic solutions), harmonic balance (for periodic and quasi periodic solutions), and variants therein (potentially more).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Although a lot of the existing tools come very close to acheiving this, they don't span nearly all the kinds of nonlinearities. For instance, it is presently quite non-trivial to use any existing code as is for simulating systems with something as simple as an elastic dry-friction element (a hysteretically saturated linear spring).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, very few tools provide a lot of convenience for harmonic balance simulations. A notable exception to this is the MATLAB tool NLvib (a very well designed set of minimal routines that work really well). The main reason that juliajim is not just a fork of NLvib is Julia - I'm convinced of the several advantages of Julia and want to ensure a useful package exists in Julia that I can throw myself behind. Furthermore, since I started using Julia MATLAB has started feeling really annoying (read: https://mateusaraujo.info/2024/04/03/matlab-is-dead-long-live-julia/ ).","category":"page"},{"location":"#Other-Projects-to-Look-at","page":"Home","title":"Other Projects to Look at","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NLvib: A Matlab toolbox for harmonic balance, shooting, and continuation.\ntmdsimpy: A Python package with very similar goals as juliajim.\noctave-jim: My old code - its a mess that works.\nHarmonicBalance.jl: A Julia toolbox for harmonic balance. \nBifurcationKit.jl: A great set of continuation and bifurcation routines.","category":"page"},{"location":"#Design-Philosophy","page":"Home","title":"Design Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I am taking care to ensure that the project is as small as possible in order to ensure that the routines developed here can be part of something bigger. Furthermore, the different parts of the package (Harmonic, Continuation) are written in order to be fully functional independently. For instance, the HB routines in the former portion of the toolbox can be used to write residue that can be used with BifurcationKit.jl for doing numerical continuation if the provided routines are deemed insufficient. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MDOFUTILS and its suite of routines (including frequency domain residues, time domain marchers, etc.) are my way of using the two main parts of the package to provide a functional interface for nonlinear dynamics research.","category":"page"},{"location":"#Conventions","page":"Home","title":"Conventions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All scripts are tagged by an alphabet. \nAll routines are upper case. ","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you're just here for the...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fourier Utilities, start by looking at AFT.\nContinuation Utilities, start by looking at CONTINUATE.\nIntegrated nonlinear dynamics, start by looking at MDOFUTILS.\nHarmonic Balance Utilities, start by looking at HBRESFUN!\nTransient Simulation Utilities, start by looking at NEWMARKMARCH\nAll of the above.","category":"page"}]
}
