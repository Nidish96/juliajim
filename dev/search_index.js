var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#juliajim.juliajim","page":"Reference","title":"juliajim.juliajim","text":"Simple dummy project module to demonstrate how a project can be organized.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.MDOFGEN","page":"Reference","title":"juliajim.MDOFGEN","text":"MDOFGEN\n\nStruct storing the generic MDOF system.\n\nFields\n\nM::Matrix{Float64}: Mass matrix\nC::Matrix{Float64}: Damping Matrix\nK::Matrix{Float64}: Stiffness Matrix\nL: Displacement Transform Matrix (can be empty)\nNdofs::Int64: Number of DOFs\nNLTs::Vector{NONLINEARITY}: Vector of nonlinearities present (see NONLINEARITY)\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.NONLINEARITY","page":"Reference","title":"juliajim.NONLINEARITY","text":"NONLINEARITY\n\nStruct storing a nonlinearity.\n\nFields\n\ntype::Symbol: Type of nonlinearity. One of:\n:Inst (for instantaneous nonlinearity)\n:Hyst (for hysteretic nonlinearity)\n:Fdom (for nonlinearity defined in frequency domain)\nOut of these, only the first 2 can be used for transient simulations.\nfunc::Function: Function handle for evaluating nonlinearity. Has signature\n(t, u, udot) for :Inst\n(t, u, up, sp) for :Hyst, where s is some internal state (sp is s at t-Δt)\nL::Matrix{Float64}: Selection Matrix\nLf: Force shape matrix (can be empty)\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.myNLSoln","page":"Reference","title":"juliajim.myNLSoln","text":"myNLSoln\n\nStruct storing the solution, Jacobian, and (unit) tangent.\n\nFields\n\nup::nvTypes: Solution point ([u;p])\nJ::nmTypes: Jacobian dr/du\nJp::nvTypes: Parameter Jacobian dr/dp\ndupds::nvTypes: Tangent vector (has to be vector only)  \n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.myNLSoln-2","page":"Reference","title":"juliajim.myNLSoln","text":"myNLSoln(up::nvTypes=nothing; J::nmTypes=nothing, Jp::nvTypes=nothing)\n\nConstructor for myNLSoln. Can specify one or all the arguments (point, jacobian, paramjac).\n\nArguments\n\nup::nvTypes       : (default nothing) Solution point\nJ::nmTypes        : (default nothing) Jacobian\nJp::nvTypes       : (default nothing) paramjac\nsave_jacs::Bool   : (default false) Whether or not to store the Jacobians.\n\nIf both J and Jp are provided, the unit tangent dupds is computed using nullspace([J Jp])[:,1].\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:--Tuple{myNLSoln, myNLSoln}","page":"Reference","title":"Base.:-","text":"Base.:-(v1::myNLSoln, v2::myNLSoln)\n\nOverloading the subtraction operator to take the difference between two myNLSoln \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, myNLSoln}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, p::myNLSoln)\n\nOverloading base show function to display myNLSoln object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.ACT-NTuple{4, Any}","page":"Reference","title":"juliajim.ACT","text":"ACT(yin, h::hTypes, N::Int64, dir::Symbol)\n\nRoutine for the alternating Chebyshev Transform. Uses AFT internally. \n\nArguments\n\nyin              : \nh::hTypes : \nN::Int64         : \ndir::Symbol      : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.AFT-NTuple{4, Any}","page":"Reference","title":"juliajim.AFT","text":"AFT(yin, h::hTypes, N::Int64, dir::Symbol);\n\nRoutine to conduct Time-to-Frequency and Frequency-to-Time transforms for the general Multi frequency case.\n\nArguments\n\nyin::VecOrMat{Float64}: (N^C, Ny) if time data, and (Nhc, Ny) if frequency data.\nh::hTypes: (Nh, C) list of harmonics.\nN::Int64: Number of time samples for AFT.\ndir::Symbol: :t2f for time-to-frequency, and :f2t for frequency-to-time.\n\nExamples\n\nSingle Frequency Case:\n\n    N = 8;\n    t = (0:N-1)*2π/N;\n    yt = cos.(t) + 3sin.(2t) .+ 4;\n    yt = [yt yt];\n\n    h = collect(0:3)[:,:];\n    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\n    yf = AFT(yt, h, N, :t2f);\n    YT = AFT(yf, h, N, :f2t);\n\n2-Frequency Case:\n\n    t1 = repeat(t, 1, N);\n    t2 = repeat(t', N, 1);\n\n    yt = cos.(t1) + 3sin.(t2) .+ 4;\n    h = [0 0;1 0;0 1;1 1];\n    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\n    yf = AFT([yt[:] yt[:]], h, N, :t2f);\n    YT = AFT(yf, h, N, :f2t);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.CONTINUATE-Tuple{Vector{Float64}, Any, Vector{Float64}, Float64}","page":"Reference","title":"juliajim.CONTINUATE","text":"CONTINUATE(u0, fun, ps, dp; kwargs...)\n\nContinuation routine. Solves the bordered problem with residue drawn from EXTRESFUN!.\n\nArguments\n\nu0::Vector{Float64}                          : Initial guess for first point\nfun                                          : NonlinearFunction object. Will call:\nfun.f(du, u, p) for residue r. p must be scalar.\nfun.jac(J, u, p) for jacobian dr/du. Uses ForwardDiff.jacobian! if fun.jac is nothing.\nfun.paramjac(Jp, u, p) for jacobian dr/dp. Uses ForwardDiff.jacobian! if fun.paramjac is nothing.\nps::Vector{Float64}                          : Specify range of p for continuation.\ndp::Float64                                  : Specify first step in Δp units. (will be rescaled if necessary)\n\nOptional Arguments\n\nparm::Symbol                                 : (default :arclength) Arclength parameterization. See EXTRESFUN!.\nnmax::Int64                                  : (default 1000) Maximum number of steps.\ndpbnds::Union{Nothing,Vector{Float64}}       : (default [dp/5,5dp]) Bounds for the step length dp. (Rescaled as appropriate)\nsave_jacs::Bool                              : (default false) Specify whether or not to save the Jacobians in the output. Only solution and (unit) tangent are saved if false.\nverbosity::Int                               : (default 1) Verbosity levels:\n0: Suppress all messages.\n1: Display Steps, Continuation Progress.\n2: Display Iteration Information for each step also.\n\nFor Scaling of Unknowns (recommended to get evenly spaced points on response curve)\n\nDsc::Union{Symbol,Nothing,Vector{Float64}}   : (default :auto) \"Dscaling\" used to scale the unknowns. The arc length constraint is applied in the scaled space (uₛ=uₚₕ./Dsc).\nIf set to :auto, it uses the absolute of the first converged solution as the initial Dsc vector. Zero entries are replaced with minDsc.\nIf set to :none, it fixes Dsc to a vector of ones and doesn't dynamically adapt it. (this forces DynScale to false).\nIf set to :ones, it fixes Dsc to a vector of ones but dynamically continues to scale.\nDynScale::Bool                               : (default true) Whether or not to dynamically adapt the Dsc vector. Each entry is allowed to grow or shrink by a maximum factor of 2 in each step if true.\nminDsc::Float64                              : (default eps()^(4//5)=3e-13) Minimum value for Dscale.\n\nFor Step Length Adaptation. Currently set as dsₙ = dsₒ * xi, where xi = clamp((itopt/itns)^nxi, xirange[1], xirange[2]).\n\nitopt::Union{Symbol,Int}                     : (default :auto) Optimal number of  \nnxi::Float64                                 : (default 0.0) Switches off adaptation by default. \nxirange::Vector{Float64}                     : (default [0.5,2.])\n\nReturns\n\nvector{myNLsoln} representing solutions.\nvector{Int} representing iterations taken.\nvector{Float64} representing step sizes.\nvector{Float64} representing adaptation parameter ξ.\nvector{Float64} representing the final Dscale matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.DCHEB-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.DCHEB","text":"DCHEB(h::hTypes)\n\nReturns the Chebyshev Differentiation matrix.\n\nArguments\n\nh::hTypes : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.DFOUR","page":"Reference","title":"juliajim.DFOUR","text":"DFOUR(h::hTypes, ws=nothing)\n\nReturns the Fourier differentiation matrix (useful for HB representations).\n\nArguments\n\nh::hTypes : (H, C) Harmonic indices\nws::Array{Float64} : (C, 1) (optional) list of frequencies\n\nOutputs\n\nD : (Nhc, Nhc) Harmonic differentiation matrix\ndDdw : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.DFOUR!","page":"Reference","title":"juliajim.DFOUR!","text":"DFOUR!(h::hTypes, D, dDdw=nothing, ws=nothing)\n\nBang version of DFOUR.\n\nArguments\n\nh::hTypes : (H, C) Harmonic indices\nD : (Nhc, Nhc) Harmonic differentiation matrix\ndDdw : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).\nws::Array{Float64} : (C, 1) (optional) list of frequencies\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.EPMCRESFUN!-Tuple{Any, MDOFGEN, Any, Any, Int64}","page":"Reference","title":"juliajim.EPMCRESFUN!","text":"Description\n\nArguments\n\nUwxa                : \nm::MDOFGEN          :\nFl                  : (Nd*Nhc) Forcing vector. Zero harmonics are used as static loads. Harmonic portions are used to provide phase constraint.\nh                   : \nN::Int64            : \ntol::Float64        : (default eps()^(4//5))\natype::Symbol       : (default :H1)\nashape::Union{Int64 : \nVector{Float64}}    : (default 1)\nR                   : (default nothing)\ndRdUwx              : (default nothing)\ndRda                : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.EXTRESFUN!-NTuple{4, Any}","page":"Reference","title":"juliajim.EXTRESFUN!","text":"EXTRESFUN!(up::nvTypes, fun, sol0::myNLSoln, ds::Float64; parm::Symbol=:riks, Dsc::Vector{Float64}, dup::nvTypes=nothing, Jf::nmTypes=nothing)\n\nReturns the bordered/extended residue function. Appends residue with required arclength constraint.\n\nNote\n\nThe function involves very naive autodiff calls. Does not respect or try to detect jacobian sparsity. For now it is best to provide analytical jacobians for very large problems. \n\nArguments\n\nup::nvTypes: Solution point for evaluation\nfun: Nonlinear function specified in a fashion that can be called as\nfun.f(du,up[1:end-1],up[end]) for the residue.\nfun.jac(J,up[1:end-1],up[end]) for the jacobian (uses ForwardDiff.jacobian! if fun.jac is nothing)\nfun.paramjac(Jp,up[1:end-1],up[end]) for the parameter jacobian (uses ForwardDiff.jacobian! if fun.paramjac is nothing)\nDevelopment Done based on NonlinearFunction from NonlinearSolve\nsol0::myNLSoln: Previous solution point.\nds::Float64: Step size.\nparm::Symbol=:riks: Arclength parameterization. Defaults to :riks. Possible are:\n:riks: Riks' or normal parameterization.\n:arclength: Arclength parameterization.\nDsc::Vector{Float64}: Scaling vector. Recommended to be of the order of magnitude of the expected unknowns. Size same as up.\ndup::nvTypes=nothing: Residue vector (for iip evaluation)\nJf::nmTypes=nothing: Jacobian matrix (for iip evaluation)\n\nReturns\n\ndup::nvTypes=nothing: Residue vector (for iip evaluation)\nJf::nmTypes=nothing: Jacobian matrix (for iip evaluation)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.FSEVAL","page":"Reference","title":"juliajim.FSEVAL","text":"FSEVAL(h::hTypes, t::Union{StepRangeLen{Float64}, VecOrMat{Float64}}, U::Union{Nothing,Matrix{Float64}}=nothing)\n\nDescription\n\nEvaluates the Fourier series at required time points. If Fourier coefficients are not provided, it returns the mapping matrix.\n\nArguments\n\nh::hTypes                      : \nt::Union{StepRangeLen{Float64} : \nVecOrMat{Float64}}             : \nU::Union{Nothing               : \nMatrix{Float64}}               : (default nothing)\n\nOutputs\n\nut\t: In case U is provided, this is outputted first.\nJ\t: The mapping matrix such that J*U gives the desired temporal evaluates.\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONICSTIFFNESS!-NTuple{7, Any}","page":"Reference","title":"juliajim.HARMONICSTIFFNESS!","text":"HARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h)\n\nBang version of HARMONICSTIFFNESS (preallocate E, dEdw).\nAdvantage is that nothing can be passed to avoid needless computations.\n\nArguments\n\nE: (NdNhc, NdNhc) Harmonic Stiffness\ndEdw: C-Vector of (NdNhc, NdNhc) Representing Frequency-gradients of E\n'M, D, K': (Nd,Nd) Mass, Damping, Stiffness Matrices.\n'ws::Array{Float64}': (C,1) list of frequencies\n'h': (H, C) harmonic indices\n\nExamples\n\nSingle Frequency Case\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nh = [0;1;2;3];\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nE = zeros(2*Nhc, 2*Nhc);\ndEdw = zeros(2*Nhc, 2*Nhc);\nws = 1;\nHARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);\n\n2-Frequency Case\n\nNhmax = 3;\nws = [1; π];\nh = HSEL(Nhmax, ws);\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nE = zeros(2*Nhc, 2*Nhc);\ndEdw = zeros(2*Nhc, 2*Nhc);\nHARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONICSTIFFNESS-NTuple{5, Any}","page":"Reference","title":"juliajim.HARMONICSTIFFNESS","text":"HARMONICSTIFFNESS(M, D, K, ws::Array{Float64}, h)\n\nComputes the harmonic stiffness for HB simulations.\n\nArguments\n\n'M, D, K': (Nd,Nd) Mass, Damping, Stiffness Matrices.\n'ws::Array{Float64}': (C,1) list of frequencies\n'h': (H, C) harmonic indices\n\nOutputs\n\nE: (NdNhc, NdNhc) Harmonic Stiffness\ndEdw: C-Vector of (NdNhc, NdNhc) Representing Frequency-gradients of E\n\nExamples\n\nSingle Frequency Case\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nh = [0;1;2;3];\nws = 1;\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\n\n2-Frequency Case\n\nNhmax = 3;\nws = [1; π];\nh = HSEL(Nhmax, ws);\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}","page":"Reference","title":"juliajim.HBRESFUN!","text":"Description\n\nResidue function that can be used for Harmonic Balance forced response analysis.\n\nArguments\n\nUw   : \nm    : \nFl   : \nh    : \nN    : \ntol  : \ndRdU : \ndRdw : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HBRESFUN_A!-Tuple{Any, MDOFGEN, Float64, Any, Any, Int64}","page":"Reference","title":"juliajim.HBRESFUN_A!","text":"Description\n\nHB residue with amplitude constraint.\n\nArguments\n\nUfw           : \nm::MDOFGEN    : \nA::Float64    : Amplitude level (also see atype below)\nFl            : \nh             : \nN::Int64      :\natype::Symbol : (default :H1) One of :H1, :RMS. Type of amplitude measure.\nashape        : (default 1) Shape to dof for applying amplitude. If Integer, interpreted as Dof. If vector, taken as shape.\ntol::Float64  : (default eps()^(4//5))\nR             : (default nothing)\ndRdUf         : (default nothing)\ndRdw          : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.HINDS","text":"HINDS(Ndofs::Int64, h::hTypes)\n\nArguments\n\nNdofs::Int64     : \nh::hTypes :\n\nOutputs\n\nzinds\nhinds\nrinds0\nrinds\niinds\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HSEL","page":"Reference","title":"juliajim.HSEL","text":"HSEL(Nhmax::Int64, ws::Any=1, hcr::Int=1)\n\nSelection of Harmonic indices based on different criteria. First C+1 rows are [zeros(1,C); I(C)].\n\nImplemented criteria are,\n\nhcr=1: Σᵢ |hᵢ| < Nhmax & ∑ᵢ h_i ≥ 0\n\nArguments\n\nNhmax::Int64: Max harmonic for truncation.\nws=1: [opt] List of frequencies\nhcr::Int=1: [opt] Truncation criterion. See above.\n\nExamples\n\nC = 2;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.NEWMARKMARCH-Tuple{MDOFGEN, Vararg{Any, 6}}","page":"Reference","title":"juliajim.NEWMARKMARCH","text":"Description\n\nArguments\n\nm::MDOFGEN : \nT0         : \nT1         : \ndt         : \nU0         : \nUd0        : \nFex        : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.NLEVAL!-Tuple{Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, MDOFGEN, Any, Int64}","page":"Reference","title":"juliajim.NLEVAL!","text":"Description\n\nEvaluate the nonlinearities (and Jacobian) for one period and return the harmonics\n\nArguments\n\nUw         : \nm::MDOFGEN :\nh          :\nN::Int64   : [optional]\ntol        :   \nFNL        : \ndFNLdU     : \ndFNLdw     : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.NLFORCE-Tuple{MDOFGEN, Any, Any, Any}","page":"Reference","title":"juliajim.NLFORCE","text":"Description\n\nArguments\n\nm::MDOFGEN : \nt          : \nU          : \nUd         : \ntp         : (default nothing)\nUp         : (default nothing)\nUdp        : (default nothing)\nSp         : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.PRODMAT_CHEB","page":"Reference","title":"juliajim.PRODMAT_CHEB","text":"Description\n\nArguments\n\nU    : \nh    : \nHmax : (default nothing)\nD    : (default nonothing)\nL    : (default nonothing)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.PRODMAT_FOUR","page":"Reference","title":"juliajim.PRODMAT_FOUR","text":"PRODMAT_FOUR(U::VecOrMat{Float64}, h::hTypes, Hmax=nothing, D=nothing, L=nothing)\n\nDescription\n\nReturns the Fourier product matrix. Currently only implemented for C=1.\n\nArguments\n\nU::VecOrMat{Float64}\t\t: \nh::hTypes    \t\t\t: \nHmax \t\t\t\t: (default nothing)\nD    \t\t\t\t: (default nothing)\nLb   \t\t\t\t: (default nothing)\n\n\n\n\n\n","category":"function"},{"location":"#Welcome-to-the-juliajim-Documentation!","page":"Home","title":"Welcome to the juliajim Documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation page. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Quick-Glimpse Tutorial\nThis tutorial just offered a quick glimpse on Julia's built-in documentation system, make sure to read the docs for more.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Hello world.","category":"page"},{"location":"#Conventions","page":"Home","title":"Conventions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All scripts are tagged by an alphabet. \nAll routines are upper case. ","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you're just here for the...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fourier Utilities (start by looking at AFT)\nContinuation Utilities (start by looking at CONTINUATE)\nIntegrated nonlinear dynamics (start by looking at MDOFGEN)\nHarmonic Balance Utilities (start by looking at HBRESFUN!)\nTransient Simulation Utilities (start by looking at NEWMARKMARCH)\nAll of the above.","category":"page"},{"location":"#Examples-with-Documentation","page":"Home","title":"Examples with Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Few examples of increasing complexity. Find them in examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using juliajim\n\nN = 8\nt = (0:N-1)*2pi/N;\ny = cos.(t);\nh = 0:3;\nYh = AFT(y, h,N, :t2f);","category":"page"}]
}
