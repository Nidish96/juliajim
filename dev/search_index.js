var documenterSearchIndex = {"docs":
[{"location":"c3_mdofgen_ahb/#ex_c3","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"Example C3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","text":"It is sometimes the case that it is necessary to conduct forced response simulations where the response amplitude is kept fixed. In fact, experimentally it is significantly easier to achieve response-controlled forced response measurements (in the context of, say, stepped sine testing) than force-controlled measurements. While there are several reasons for this (large displacement effects on the exciter at resonance, low SNR at anti-resonance points, etc.), we will not go into this here.\n\nMDOFUTILS provides HBRESFUN_A!, a routine that returns the harmonic balance residue along with an amplitude constraint. The usage of this is only slightly different from HBRESFUN! (which we have already encountered in Examples C1 and C2 for forced response analysis).\n\nThe same system as before will be studied here:\n\nunderbracebeginbmatrix 1001 endbmatrix_mxM beginbmatrix ddotx_1 ddotx_2 endbmatrix +\nleft( 001 mxM + 0001 mxKright) beginbmatrix dotx_1 dotx_2 endbmatrix + underbracebeginbmatrix 2-1-12 endbmatrix_mxK beginbmatrix x_1x_2 endbmatrix + beginbmatrix 0 f_fr(x_2) endbmatrix = beginbmatrix 10 endbmatrixcosOmega t","category":"section"},{"location":"c3_mdofgen_ahb/#Preamble:-Load-Packages","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"Preamble: Load Packages","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"section"},{"location":"c3_mdofgen_ahb/#exc3_setup","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"System Setup","text":"MCK matrices and nonlinearity setup: identical to Example C2.\n\nM = [1. 0.;0. 1.];\nK = [2. -1.;-1. 2.];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\n\n# Nonlinearity\nkt = 1.0;\nfs = 1.0;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\nL = [0. 1.];\n\nmdl = ADDNL(mdl, :Hyst, fnl, L);\nnothing #hide","category":"section"},{"location":"c3_mdofgen_ahb/#exc3_hbsetup","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"Setup HB","text":"HB setup: identical to Example C2.\n\nh = 1:2:5;\n# h = 0:5;\nN = 256;\nt = (0:N-1)*2π/N;\n\nNhc = sum(all(h.==0, dims=2) + 2any(h.!=0, dims=2));\n\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h)\nFl = zeros(Nhc*mdl.Ndofs);\nFl[rinds[1]] = 1.0;\n\nWst = 0.6;\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Wst, h);\nU0 = E\\Fl;\nnothing #hide","category":"section"},{"location":"c3_mdofgen_ahb/#exc3_testhb","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"Test HB Residue","text":"The residue function HBRESFUN_A! expects a vector of the form (\\begin{bmatrix} \\vc{u}& F& \\Omega \\end{bmatrix}^T), where (\\vc{u}) is the vector of harmonics, (F) is the (scalar) excitation amplitude (also an unknown), and (\\Omega) is the (scalar) excitation frequency. Apart from the same arguments as HBRESFUN!, the required response amplitude Amp must also be provided here. By default, this amplitude is interpreted as the first harmonic amplitude of the first DoF. This can be customized by supplying optional keywords atype (one of :H1 or :RMS, specifying type of amplitude measure) and ashape (either DoF index or vector of weights to DoFs); see the documentation. Here we set this up using NonlinearSolve.jl and solve for a single point.\n\nR = zeros(mdl.Ndofs*Nhc+1);\ndRdUf = zeros(mdl.Ndofs*Nhc+1, mdl.Ndofs*Nhc+1);\ndRdw = zeros(mdl.Ndofs*Nhc+1);\nAmp = 1e0;\ndof = 1;\n\nHBRESFUN_A!([U0; 1.0; Wst], mdl, Amp, Fl, h, N; R=R, dRdUf=dRdUf, dRdw=dRdw)\n\nfun = NonlinearFunction((r,uf,p)->HBRESFUN_A!([uf;p], mdl, Amp, Fl, h, N; R=r),\n    jac=(J,uf,p)->HBRESFUN_A!([uf;p], mdl, Amp, Fl, h, N; dRdUf=J),\n    paramjac=(Jp,uf,p)->HBRESFUN_A!([uf;p], mdl, Amp, Fl, h, N; dRdw=Jp));\n\nprob = NonlinearProblem(fun, [U0;1.0], Wst);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"section"},{"location":"c3_mdofgen_ahb/#exc3_cont","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"Continuation","text":"Now we continue as before with continuation. In fact this piece of code is exactly the same as in Example C2.\n\nOm0 = 0.1;\nOm1 = 3;\ndOm = 0.2;\n\ncpars = (parm=:arclength, nmax=400, Dsc=:none, itopt=4);  # Autoscaling is not working\nsols, its, dss, xis, Dsc = CONTINUATE([U0;1.0], fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols), 2);\nfor i in 1:2\n    uh[h.+1, :, i] = hcat([[s.up[zinds[i:2:end]];\n                            s.up[rinds[i:2:end]]+1im*s.up[iinds[i:2:end]]]\n                          for s in sols]...);\nend\nOms = sols.p;\nFs = [s.up[end-1] for s in sols];\nnothing #hide","category":"section"},{"location":"c3_mdofgen_ahb/#exc3_plot","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"Plotting","text":"We plot first just the responses, to demonstrate how the amplitude constraint has been effective.","category":"section"},{"location":"c3_mdofgen_ahb/#Amplitude-Responses","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"Amplitude Responses","text":"his = [1, 3, 5];\n\nset_theme!(theme_latexfonts())\nfsz = 24;\nfig1 = Figure(fontsize=fsz, size=(1000, 600));\n\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig1[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :, 1]), label=\"x1\");\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :, 2]), label=\"x2\");\n    if i==1\n        axislegend(ax)\n    end\n\n    ax = Axis(fig1[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\nend\n\n    fig1\n\nIt can be observed that the first harmonic of the first DoF is always fixed to the value of Amp (10 here), while the other DoF's amplitude changes, showing that we have a fixed amplitude forced response here.","category":"section"},{"location":"c3_mdofgen_ahb/#Forced-Responses","page":"3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator","title":"Forced Responses","text":"In order to visualize the nonlinear forced response function, we plot the response over force next. Here the resonances are clearly visible, albeit very different from what was seen in Example C2.\n\nhis = [1, 3, 5];\n\nset_theme!(theme_latexfonts())\nfsz = 24;\nfig2 = Figure(fontsize=fsz, size=(1000, 600));\n\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig2[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m/N)\", yscale=log10);\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :, 1]./Fs), label=\"x1\");\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :, 2]./Fs), label=\"x2\");\n\n    ax = Axis(fig2[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\nend\n\n    fig2\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"c5_mdofgen_newmark/#ex_c5","page":"5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme","title":"Example C5: Transient Response of a 2DoF Hysteretic Oscillator using A Newmark Scheme","text":"In this example we show how the MDOFUTILS suite can also be used for conducting transient analysis. A natural question may be why not just use SciML's DifferentialEquations.jl. The answer lies in hysteretic nonlinearities implemented in the incremental formalism. It is not trivial to use existing methods for integrating these systems without additional complexity (computational as well as conceptual).\n\nHowever, classical second order methods (central difference, linear acceleration, Newmark-(\\beta), Wilson-(\\theta), HHT-(\\alpha), etc.) naturally lend themselves to hysterestic systems! This is because these integrators require the difference in force between the previous and the next time instants, which is the most convenient way of specifying an incremental hysteretic nonlinearity.\n\nHere we analyze the same 2DoF oscillator as in the last few examples:\n\nunderbracebeginbmatrix 1001 endbmatrix_mxM beginbmatrix ddotx_1 ddotx_2 endbmatrix +\nleft( 001 mxM + 0001 mxKright) beginbmatrix dotx_1 dotx_2 endbmatrix + underbracebeginbmatrix 2-1-12 endbmatrix_mxK beginbmatrix x_1x_2 endbmatrix + beginbmatrix 0 f_fr(x_2) endbmatrix = beginbmatrix 10 endbmatrixcosOmega t\n\nThe steps followed in the example are:\n\nFirst we setup the system and the nonlinearity (and also check the nonlinear force evaluation).\nThen we setup the initial conditions and transient analysis parameters and do the actual analysis.\nFinally we visualize the results.","category":"section"},{"location":"c5_mdofgen_newmark/#Preamble:-Load-Packages","page":"5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme","title":"Preamble: Load Packages","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"section"},{"location":"c5_mdofgen_newmark/#exc5_setup","page":"5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme","title":"System Setup","text":"M = collect(1.0I(2));\nK = [2. -1.;-1. 2.];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\n\n# Nonlinearity\nkt = 1.0;\nfs = 1.0;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\nL = [0.0 1.0];\nFv = [1.0, 0.0];\n\nmdl = ADDNL(mdl, :Hyst, fnl, L);\nnothing #hide","category":"section"},{"location":"c5_mdofgen_newmark/#Nonlinear-Force-Evaluation","page":"5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme","title":"Nonlinear Force Evaluation","text":"Here we test the nonlinear force evaluation using the NLFORCE routine, which is used internally to compute the nonlinear forces in time domain. This function requires, at minimum, the time and displacement-velocity states. But it also accepts the states at the previous instant for the computation (very much relevant for hysteretic nonlinearities). If these are not provided, they are all defaulted to zero. Apart from the nonlinear force and its Jacobians, the routine also outputs S, which is a Vector as long as the number of nonlinearities present. Each element of the vector is a vector of the forces of the nonlinearity. These are relevant for hysteretic nonlinearities where explicit history dependence is very important.\n\nFnl, dFnldU, dFnldUd, S = NLFORCE(mdl, 0, zeros(2), zeros(2))","category":"section"},{"location":"c5_mdofgen_newmark/#exc5_trans","page":"5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme","title":"Transient March","text":"Now we are ready to conduct the transient simulation. We set trivial initial conditions and provide periodic excitation at a point well below the first resonance (which is at (1) rad/s).\n\nU0 = zeros(2);\nUd0 = zeros(2);\nfsamp = 10;\nOm = 0.6;  # rad/s\nFamp = 4;\nFex = t-> Famp*Fv*cos(Om*t);\nTmax = 2π/Om*100;\n\nt = 0:1/fsamp:Tmax;\n\nU, Ud, Udd, S = NEWMARKMARCH(mdl, 0, Tmax, 1/fsamp, U0, Ud0, Fex, verbosity=100)","category":"section"},{"location":"c5_mdofgen_newmark/#exc5_plot","page":"5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme","title":"Plotting","text":"Now we plot all the results. We plot them in terms of the states (displacements and velocities from U, Ud) as well as the slider internal forces from S. A strongly nonlinear response can be observed with the steady-state zoom-in (to the last cycle) showing highly non-smooth behavior. The displacement and velocity plots also show a significant presence of higher harmonics, underlying the same.\n\nset_theme!(theme_latexfonts())\nfsz = 20;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\nax1 = Axis(fig[1, 1:2], ylabel=\"Displacement (m)\", title=\"Complete Response\");\nfor i in 1:2\n    lines!(ax1, t, U[i,:])\nend\nax10 = Axis(fig[1, 3], title=\"Steady State\");\nfor i in 1:2\n    scatterlines!(ax10, t, U[i,:], label=\"x$(i)\")\nend\naxislegend(ax10, position=:ct)\nxlims!(ax10, Tmax-2π/Om, Tmax);\nylims!(ax10, -maximum(abs.(U)), maximum(abs.(U)));\n\nax2 = Axis(fig[2, 1:2], ylabel=\"Velocity (m/s)\");\nfor i in 1:2\n    lines!(ax2, t, Ud[i,:])\nend\nax20 = Axis(fig[2, 3]);\nfor i in 1:2\n    scatterlines!(ax20, t, Ud[i,:])\nend\nxlims!(ax20, Tmax-2π/Om, Tmax);\nylims!(ax20, -maximum(abs.(Ud)), maximum(abs.(Ud)));\n\nax3 = Axis(fig[3, 1:2], xlabel=\"Time (s)\", ylabel=\"Friction force (N)\")\nlines!(ax3, t, getindex.(S, 1)[:])\nax30 = Axis(fig[3, 3], xlabel=\"Time (s)\")\nscatterlines!(ax30, t, getindex.(S, 1)[:])\nxlims!(ax30, Tmax-2π/Om, Tmax);\n\nlinkxaxes!(ax1, ax2, ax3);\n\n   fig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"d3_normalform/#ex_d3","page":"3: Branch Switching Using Normal Forms","title":"Example D3: Branch Switching Using Normal Forms","text":"This example is a direct continuation of Example D2. In that example we did a branch switching analysis by arbitrarily choosing the amplitude of perturbation. Here, we use the NORMALFORMFIT function to fit the system to a cubic nonlinear \"normal form\" (through a similarity transformation eliminating certain terms).\n\nThe normal form can easily be interpreted to provide an estimate for the bifurcated branch amplitudes. It can be seen that the normal form approach provides a near exact estimate of the bifurcated branch amplitude in the end of this example.","category":"section"},{"location":"d3_normalform/#Preamble:-Load-Packages","page":"3: Branch Switching Using Normal Forms","title":"Preamble: Load Packages","text":"using GLMakie\n\nusing LinearAlgebra\nusing SparseArrays\nusing NonlinearSolve\nusing DSP\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS\nusing juliajim.NLDYN","category":"section"},{"location":"d3_normalform/#System-Setup","page":"3: Branch Switching Using Normal Forms","title":"System Setup","text":"Here we setup the system with parameters.\n\npars = (c=0.02, k=4., F=1., eta=0.1);\n\nmdl = MDOFGEN(1.0, -pars.c, pars.k);\nfnl = (t,u,ud) -> return pars.eta.*u.^2 .*ud, 2pars.eta.*u.*ud, pars.eta.*u.^2;\nmdl = ADDNL(mdl, :Inst, fnl, 1.0);\nnothing #hide","category":"section"},{"location":"d3_normalform/#Setup-HB","page":"3: Branch Switching Using Normal Forms","title":"Setup HB","text":"h = 0:5;\nN = 128;\nt = range(0, 2π, N+1)[1:N];\n\nNhc = NHC(h);\n\ninds0, hinds, zinds, rinds, iinds = HINDS(mdl.Ndofs, h);\nFl = zeros(Nhc*mdl.Ndofs, 1);\nFl[rinds[1]] = pars.F;\n\nOm0 = 0.1;\nOm1 = 2.0;\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Om0, h);\n\nUw0 = [E\\Fl; Om0];\nnothing #hide","category":"section"},{"location":"d3_normalform/#Setup-HB-Residue,-Get-First-Point","page":"3: Branch Switching Using Normal Forms","title":"Setup HB Residue, Get First Point","text":"fun = NonlinearFunction((r,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; R=r),\n    jac=(J,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; dRdU=J),\n    paramjac=(Jp,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; dRdw=Jp));\n\nprob = NonlinearProblem(fun, Uw0[1:end-1], Uw0[end]);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"section"},{"location":"d3_normalform/#Continuation","page":"3: Branch Switching Using Normal Forms","title":"Continuation","text":"Om0 = 0.1;\nOm1 = 4.0;\ndOm = 0.1;\ncpars = (parm=:arclength, nmax=200, save_jacs=true);\n\nsols, _, _, _, _ = CONTINUATE(Uw0[1:end-1], fun, [Om0, Om1], dOm; cpars...);\nnothing #hide\n\nObtain Harmonics\n\nuh = zeros(Complex, maximum(h)+1, length(sols));\nuh[[inds0; hinds], :] = hcat([[up[zinds];up[rinds,:]+1im*up[iinds,:]] for up in sols.up]...);\nOms = sols.p;\nnothing #hide","category":"section"},{"location":"d3_normalform/#Stability-Analysis","page":"3: Branch Switching Using Normal Forms","title":"Stability Analysis","text":"E0, _ = HARMONICSTIFFNESS(0., -2mdl.M, 0, 1, h);\nE0 = collect(E0);\nstab = zeros(length(Oms));\nfor (i,(J,Om)) in enumerate(zip(sols.J, Oms))\n    evs = eigvals(J[2:3,2:3], Om*E0[2:3,2:3]);\n    stab[i] = sum(real(evs).>=0);\nend","category":"section"},{"location":"d3_normalform/#Bifurcation-Analysis","page":"3: Branch Switching Using Normal Forms","title":"Bifurcation Analysis","text":"","category":"section"},{"location":"d3_normalform/#Setup-QPHB-for-Branch-Switching","page":"3: Branch Switching Using Normal Forms","title":"Setup QPHB for Branch Switching","text":"Nhmax = 3;\nhq = HSEL(Nhmax, [1.,1.]);\n\ninds0q,hindsq, zindsq,rindsq,iindsq = HINDS(1, hq);\nNhcq = NHC(hq);\nNq = 32;\n\nh01 = findall(vec(all(hq.==0, dims=2)));\nhq1s = setdiff(findall(hq[:,2].==0), h01).-length(h01);  # w1 alone\nhq2s = setdiff(findall(hq[:,1].==0), h01).-length(h01);  # w2 alone\n\nFlq = zeros(Nhcq);\nFlq[rindsq[hq2s[1]]] = pars.F;\nnothing #hide","category":"section"},{"location":"d3_normalform/#Detection","page":"3: Branch Switching Using Normal Forms","title":"Detection","text":"bifis = findall(stab[1:end-1].!=stab[2:end]);\nbifis[2] += 1;\ndxis = [-1, 1];\n\nbi = 2;\nbifi = bifis[bi];\neVals, eVecs = eigen(sols.J[bifi][2:3, 2:3], Oms[bifi]*collect(E0[2:3,2:3]));\neVecsC = eVecs[1,:]-1im.*eVecs[2,:];  # Complexify\n\nei = argmax(abs.(eVecsC));  # Only one should \"survive\" for the Hopf bifurcation\n\nsig = imag(eVals[ei]);\nWself = Oms[bifi] + sig;  # Self Excited Frequency\nPvec = normalize([real(eVecsC[ei]), -imag(eVecsC[ei])]);  # Perturbation Vector\nnothing #hide\n\nSetup Initial Guess\n\nUhq0 = zeros(Nhcq);\nUhq0[[rindsq[hq2s]; iindsq[hq2s]]] = sols.up[bifi][[rinds[1:length(hq2s)];\n                                                    iinds[1:length(hq2s)]]];\nnothing #hide","category":"section"},{"location":"d3_normalform/#Fit-the-HB-Residue-to-a-Local-Normal-form","page":"3: Branch Switching Using Normal Forms","title":"Fit the HB Residue to a Local Normal form","text":"Fl1 = Fl[[rinds[1], iinds[1]]];  # Single harmonic excitation\nuh1 = sols.up[bifi][[rinds[1], iinds[1]]];  # Bifurcated Solution\nvh1 = [normalize(real(eVecs[:,ei])) normalize(imag(eVecs[:,ei]))];  # Projector\n\nuh0 = sols.up[bifi-dxis[bi]][[rinds[1], iinds[1]]];  # Previous Solution\nd_amp = norm(vh1'*(uh1-uh0));\n\nE0f, _ = HARMONICSTIFFNESS(0, -2mdl.M, 0, Oms[bifi], 1)\nxyfun = (u) -> vh1\\ (E0f\\HBRESFUN!([uh1+vh1*u; Oms[bifi]], mdl, Fl1, 1, N));\n\nA, B, C, H = NORMALFORMFIT(xyfun, d_amp/10, 100);\nλ = sum(diag(A))/2;\nα = sum(C[[1,4,5,8]])/4;\n\npVal, pVec = eigen(A);\nvi = argmax(abs.(pVec[1,:]+1im*pVec[2,:]));\nPvec = vh1*pVec[:,vi];\nPvec = normalize([real(pVec[1]+1im*pVec[2]), imag(pVec[1]+1im*pVec[2])]);\nnothing #hide\n\nPerturbation Vector\n\nPhq0 = zeros(Nhcq);\nPhq0[[rindsq[hq1s[1]]; iindsq[hq1s[1]]]] = Pvec;\nnothing #hide\n\nPerturbation Amplitude\n\nqamp = √(-λ/α);\nnothing #hide","category":"section"},{"location":"d3_normalform/#Apply-phase-constraint-and-converge-with-deflation","page":"3: Branch Switching Using Normal Forms","title":"Apply phase constraint and converge with deflation","text":"cL = I(Nhcq+2)[:, setdiff(1:Nhcq+2, iindsq[hq1s[1]])];\nuC = cL'*[Uhq0; Wself; Oms[bifi]];\n\nfunq = NonlinearFunction((r,u,p)-> QPHBRESFUN!([u;p], mdl, Flq, hq, Nq; R=r,cL=cL,U0=uC),\n    jac=(J,u,p)->QPHBRESFUN!([u;p], mdl, Flq, hq, Nq; dRdU=J,cL=cL,U0=uC),\n    paramjac=(Jp,u,p)->QPHBRESFUN!([u;p], mdl, Flq, hq, Nq; dRdw=Jp,cL=cL,U0=uC));\n\nu0 = cL'*[Uhq0+qamp*Phq0; Wself; Oms[bifi]];\nprobq = NonlinearProblem(funq, u0[1:end-1], u0[end]);\nsolq = solve(probq, show_trace=Val(true));\nnothing #hide\n\nWe can now verify that the converged solution does indeed have an amplitude that's almost exactly equal to the normal form prediction.\n\n[cL[2,:]'*[solq.u; Oms[bifi]], qamp]\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"d2_forcedvdp/#ex_d2","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Example D2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","text":"This example is designed to demonstrate stability analysis and branch switching across a (secondary) Hopf bifurcation that occurs in a forced Van der Pol oscillator.\n\nThe dynamical system that will be studied here is:\n\nddotx - c dotx + k x + eta x^2 dotx = FcosOmega t\n\nThis is an SDoF nonlinear oscillator with negative viscous damping. The nonlinearity provides the dissipation that saturates the response. Classically known as the Van der Pol oscillator, this is a useful system for learning about limit cycles. In the considered version, we also have an external periodic excitation.\n\nThe system will have a stable periodic response close to resonance, which will lose its stability as we move away from it.","category":"section"},{"location":"d2_forcedvdp/#Preamble:-Load-Packages","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Preamble: Load Packages","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing NonlinearSolve\nusing DSP\n\nusing Revise\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS\nusing juliajim.NLDYN","category":"section"},{"location":"d2_forcedvdp/#exd2_setup","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"System Setup","text":"Here we setup the system with parameters.\n\npars = (c=0.02, k=4., F=1., eta=0.1);\n\nmdl = MDOFGEN(1.0, -pars.c, pars.k);\nfnl = (t,u,ud) -> return pars.eta.*u.^2 .*ud, 2pars.eta.*u.*ud, pars.eta.*u.^2;\nmdl = ADDNL(mdl, :Inst, fnl, 1.0);\nnothing #hide","category":"section"},{"location":"d2_forcedvdp/#exd2_hbsetup","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Setup HB","text":"h = 0:5;\nN = 128;\nt = range(0, 2π, N+1)[1:N];\n\nNhc = NHC(h);\n\ninds0, hinds, zinds, rinds, iinds = HINDS(mdl.Ndofs, h);\nFl = zeros(Nhc*mdl.Ndofs, 1);\nFl[rinds[1]] = pars.F;\n\nOm0 = 0.1;\nOm1 = 2.0;\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Om0, h);\n\nUw0 = [E\\Fl; Om0];\nnothing #hide","category":"section"},{"location":"d2_forcedvdp/#Setup-HB-Residue,-Get-First-Point","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Setup HB Residue, Get First Point","text":"fun = NonlinearFunction((r,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; R=r),\n    jac=(J,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; dRdU=J),\n    paramjac=(Jp,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; dRdw=Jp));\n\nprob = NonlinearProblem(fun, Uw0[1:end-1], Uw0[end]);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"section"},{"location":"d2_forcedvdp/#exd2_cont","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Continuation","text":"Just like in other examples we call the CONTINUATE utility to obtain the periodic forced response.\n\nOm0 = 0.1;\nOm1 = 4.0;\ndOm = 0.1;\ncpars = (parm=:arclength, nmax=400, save_jacs=true);\n\nsols, _, _, _, _ = CONTINUATE(Uw0[1:end-1], fun, [Om0, Om1], dOm; cpars...);\nnothing #hide\n\nObtain Harmonics\n\nuh = zeros(Complex, maximum(h)+1, length(sols));\nuh[[inds0; hinds], :] = hcat([[up[zinds];up[rinds,:]+1im*up[iinds,:]] for up in sols.up]...);\nOms = sols.p;\nnothing #hide","category":"section"},{"location":"d2_forcedvdp/#Stability-Analysis","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Stability Analysis","text":"We now use an averaging formulation to obtain the stability coefficients based on just the first harmonics. This will work if the response is dominantly single harmonic.\n\nE0, _ = HARMONICSTIFFNESS(0., -2mdl.M, 0, 1, h);\nE0 = collect(E0);\nstab = zeros(length(Oms));\nfor (i,(J,Om)) in enumerate(zip(sols.J, Oms))\n    # evs = eigvals(J[2:end,2:end], Om*collect(E0[2:end,2:end]));  # Multiharmonic\n    evs = eigvals(J[2:3,2:3], Om*E0[2:3,2:3]);\n    stab[i] = sum(real(evs).>=0);\nend\n\nThe variable stab will store the number of unstable eigenvalues that have been detected. One may interpret these as the Floquet exponents of the system.","category":"section"},{"location":"d2_forcedvdp/#Bifurcation-Analysis","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Bifurcation Analysis","text":"","category":"section"},{"location":"d2_forcedvdp/#Setup-QPHB-for-Branch-Switching","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Setup QPHB for Branch Switching","text":"Nhmax = 3;\nhq = HSEL(Nhmax, [1.,1.]);\n\ninds0q,hindsq, zindsq,rindsq,iindsq = HINDS(1, hq);\nNhcq = NHC(hq);\nNq = 32;\n\nh01 = findall(vec(all(hq.==0, dims=2)));\nhq1s = setdiff(findall(hq[:,2].==0), h01).-length(h01);  # w1 alone\nhq2s = setdiff(findall(hq[:,1].==0), h01).-length(h01);  # w2 alone\n\nFlq = zeros(Nhcq);\nFlq[rindsq[hq2s[1]]] = pars.F;\nnothing #hide","category":"section"},{"location":"d2_forcedvdp/#Detection","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Detection","text":"bifis = findall(stab[1:end-1].!=stab[2:end]);\nbifis[2] += 1;\ndxis = [-1, 1];\n\nuhbs = [];\nOmsb = [];\nWselfs = [];\nnothing #hide\n\nWe loop over the two detected bifurcation points\n\nfor (bi, bifi) in enumerate(bifis)\n    # Eigenanalysis to obtain unstable manifold (eigenvectors)\n    eVals, eVecs = eigen(sols.J[bifi][2:3, 2:3], Oms[bifi]*collect(E0[2:3,2:3]));\n    eVecsC = eVecs[1,:]-1im.*eVecs[2,:];  # Complexify\n\n    ei = argmax(abs.(eVecsC));  # Only one should \"survive\" for the Hopf bifurcation\n\n    sig = imag(eVals[ei]);\n    Wself = Oms[bifi] + sig;  # Self Excited Frequency\n    eVecsC = eVecsC*exp(-1im*angle(eVecsC[ei]));  # Normalize phase\n    Pvec = normalize([real(eVecsC[ei]), -imag(eVecsC[ei])]);  # Perturbation Vector\n\n    # Setup Initial Guess\n    Uhq0 = zeros(Nhcq);\n    Uhq0[[rindsq[hq2s]; iindsq[hq2s]]] = sols.up[bifi][[rinds[1:length(hq2s)];\n                                                        iinds[1:length(hq2s)]]];\n\n    # Perturbation Vector\n    Phq0 = zeros(Nhcq);\n    Phq0[[rindsq[hq1s[1]]; iindsq[hq1s[1]]]] = Pvec;\n    # Perturbation amplitude\n    qamp = 1.0;\n    # We choose this arbitrarily for now. It is possible to use the\n    # method of normal forms to fix this exactly, see [next example](@ref ex_d3).\n\n    ### Apply phase constraint and converge with deflation\n    cL = I(Nhcq+2)[:, setdiff(1:Nhcq+2, iindsq[hq1s[1]])];\n    uC = cL'*[Uhq0; Wself; Oms[bifi]];\n    # The matrix `cL` is defined so that the original solution vector `Uw`\n    # (which includes harmonics and both the frequency components) can be\n    # recovered by $Uw = cL \\hat{Uw}$.\n\n    funq = NonlinearFunction((r,u,p)-> QPHBRESFUN!([u;p], mdl, Flq, hq, Nq;\n        R=r,cL=cL,U0=uC),\n        jac=(J,u,p)->QPHBRESFUN!([u;p], mdl, Flq, hq, Nq;\n            dRdU=J,cL=cL,U0=uC),\n        paramjac=(Jp,u,p)->QPHBRESFUN!([u;p], mdl, Flq, hq, Nq;\n            dRdw=Jp,cL=cL,U0=uC));\n    # The [`QPHBRESFUN!`](@ref juliajim.MDOFUTILS.QPHBRESFUN!) function\n    # supports deflation specification through the keyword argument U0.\n\n    u0 = cL[1:end-1,:]'*[Uhq0+qamp*Phq0; Wself];\n    probq = NonlinearProblem(funq, u0[1:end-1], Oms[bifi]);\n    solq = solve(probq, show_trace=Val(true));\n\n    # Get one point before (without deflation)\n    funr = NonlinearFunction((r,u,p)-> QPHBRESFUN!([u;p], mdl, Flq, hq, Nq; R=r,cL=cL),\n        jac=(J,u,p)->QPHBRESFUN!([u;p], mdl, Flq, hq, Nq; dRdU=J,cL=cL));\n    probq = NonlinearProblem(funr, u0[1:end-1], Oms[bifi-dxis[bi]]);\n    solprev = solve(probq, show_trace=Val(true));\n\n    ### Continue away from the bifurcation point\n    Om0b = Oms[bifi];\n    Om1b = (dxis[bi]<0) ? Om0 : Om1;\n    dOmb = 1.8;\n    cparsb = (parm=:arclength, nmax=500, save_jacs=true);\n\n    solsb, _, _, _, _ = CONTINUATE(solq.u, funq, [Om0b, Om1b], dOmb; cparsb...);\n    # Prepend previous point & expand constraint\n    sup = [cL*up for up in [[solprev.u;Oms[bifi-dxis[bi]]], solsb.up...]];\n\n    # Obtain Harmonics\n    uhq = zeros(Complex, size(hq,1), length(sup));\n    uhq[[inds0q; hindsq], :] = hcat([[up[zindsq];up[rindsq,:]+1im*up[iindsq,:]]\n                                    for up in sup]...);\n\n    push!(uhbs, uhq);\n    push!(Omsb, [up[end] for up in sup]);\n    push!(Wselfs, [up[end-1] for up in sup]);\nend","category":"section"},{"location":"d2_forcedvdp/#exd2_plot","page":"2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator","title":"Plotting","text":"set_theme!(theme_latexfonts())\nfsz = 24;\nfig = Figure(fontsize=fsz);\n\nax = Axis(fig[1, 1], xlabel=L\"Excitation Frequency $\\Omega$\", ylabel=\"Response\",\n    yscale=log10);\nscatterlines!(ax, Oms./(stab.==0), [norm(u) for u in eachcol(uh)], label=\"Stable\")\nscatterlines!(ax, Oms./(stab.==2), [norm(u) for u in eachcol(uh)], label=\"Unstable\")\n\nfor (i, (om,uhb)) in enumerate(zip(Omsb, uhbs))\n    scatterlines!(ax, om, [norm(u) for u in eachcol(uhb)],\n        label=\"Branch $(i)\")\n    # scatterlines!(ax, om[2:end], abs.(uhb[12,2:end]),\n    #     label=\"Branch $(i)\")\nend\n\naxislegend(ax, nbanks=3, position=:ct)\n\nxlims!(Om0, Om1)\n\nylims!(0, 3.75)\n\n    fig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"e_febeam/#ex_f","page":"E: Finite Element Beam with Nonlinear Support","title":"Example F: Finite Element Beam with Nonlinear Support","text":"This example considers a finite element model of a Beam (Euler-Bernoulli) that has a nonlinear attachment in one end and is clamped in the other. The same code can be used for simulating 3 different types of nonlinear attachments:\n\nA simple cubic spring of the form beta u^3.\nA stiff string attachment with reaction force of the form T fracw_Tsqrtell_s^2+w_T^2\nA non-smooth frictional joint.","category":"section"},{"location":"e_febeam/#Preamble:-Load-Packages","page":"E: Finite Element Beam with Nonlinear Support","title":"Preamble: Load Packages","text":"using GLMakie\nusing LinearAlgebra\nusing Random\nusing NonlinearSolve\nusing SparseArrays\nusing Revise\n\nusing juliajim.HARMONIC\nusing juliajim.MDOFUTILS\nusing juliajim.CONTINUATION","category":"section"},{"location":"e_febeam/#Setup-System","page":"E: Finite Element Beam with Nonlinear Support","title":"Setup System","text":"Ey = 70e9;\nrho = 2700.;\nw, h = 3*25e-3, 12.5e-3;\nell = 1.0;\nρA = rho*w*h;\nEI = Ey*w*h^3/12;\nnothing #hide\n\nCubic Spring\n\nβ = 500.0;  # Nonlinearity\nfnl = (t, u, ud) -> return β.*u.^3, 3β.*u.^2, zeros(size(u));\ntyp = :Inst;\nnothing #hide\n\nStiffened String\n\nTs = 1e2;\nls = 0.10;\nfnl = (t, u, ud) -> return Ts.*u./sqrt.(ls^2 .+u.^2),\n    Ts*ls^2 ./sqrt.(ls^2 .+u.^2).^3, zeros(size(u));\ntyp = :Inst;\nnothing #hide\n\nFrictional Support\n\nkt = 500;\nfs = 1e-2kt;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\ntyp = :Hyst;\n\nNe = 10;  # Number of elements\nNn = Ne+1;  # Number of nodes\nXn = range(0, ell, Nn);\n\nMe(Le) = ρA*Le/420*[156 22Le 54 -13Le;\n\t            22Le 4Le^2 13Le -3Le^2;\n\t            54 13Le 156 -22Le;\n\t            -13Le -3Le^2 -22Le 4Le^2];\nKe(Le) = EI/Le^3*[12 6Le -12 6Le;\n\t\t  6Le 4Le^2 -6Le 2Le^2;\n\t\t  -12 -6Le 12 -6Le;\n\t\t  6Le 2Le^2 -6Le 4Le^2];\n\nM = zeros(2Nn, 2Nn);\nK = zeros(2Nn, 2Nn);\nfor ei in 1:Ne\n    is = 2(ei-1)+1;\n    ie = 2(ei+1);\n\n    M[is:ie, is:ie] += Me(diff(Xn[ei:ei+1])[1]);\n    K[is:ie, is:ie] += Ke(diff(Xn[ei:ei+1])[1]);\nend\nF = [zeros(2Nn-2); 1.;0.];\nnothing #hide\n\nApply Clamped Boundary Condition\n\nLb = I(2Nn)[:, 3:end];\nMb = Lb'M*Lb;\nKb = Lb'K*Lb;\nFb = Lb'F;\n\nWn = sqrt.(eigvals(Kb, Mb));\nZts = [0.2e-2, 0.1e-2];\nab = [1 ./2Wn[1:2] Wn[1:2]/2]\\Zts;\nCb = ab[1]*Mb + ab[2]*Kb;\nnothing #hide\n\nSetup Nonlinearity\n\nmdl = MDOFGEN(Mb, Cb, Kb);\nmdl = ADDNL(mdl, typ, fnl, Float64.(Lb[end-1:end-1,:]));\nnothing #hide","category":"section"},{"location":"e_febeam/#Setup-HB","page":"E: Finite Element Beam with Nonlinear Support","title":"Setup HB","text":"h = 0:5;\nN = 256;\n\nNhc = NHC(h);\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h);\n\nFl = zeros(Nhc*mdl.Ndofs);\nFl[rinds[1:mdl.Ndofs]] = Fb;\n\nOm0 = 10.0;\nOm1 = 450.0;\ndOm = 10.0;\nnothing #hide\n\nLinear Initial Guess\n\nE, _ = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Om0, h);\nU0_(Fa) = E\\ (Fa*Fl);\nnothing #hide\n\nSetup nonlinear function\n\nfun(Fa) = NonlinearFunction((r,u,p)->HBRESFUN!([u;p], mdl, Fa*Fl, h, N; R=r),\n    jac=(J,u,p)->HBRESFUN!([u;p], mdl, Fa*Fl, h, N; dRdU=J),\n    paramjac=(Jp,u,p)->HBRESFUN!([u;p], mdl, Fa*Fl, h, N; dRdw=Jp));\nnothing #hide","category":"section"},{"location":"e_febeam/#Forced-Response-Continuation","page":"E: Finite Element Beam with Nonlinear Support","title":"Forced Response Continuation","text":"Famp = 8.0  # 0.5, 1.0, 2.0, 4.0, 8.0, 16.0\n\nContinuation: The main parameters that can be changed are the step size (dOm here) and the angopt parameter.\n\nangopt represents the desired angle between the secant and the tangent in a scaled space. Smaller angles represent that the secant is close to the tangent, i.e., the response curve is approximately a straight line.\n\nWe scale the vectors by the tangent so that the tangent at the previous point is represented by the orthotropic vector normalize(ones(N)). We exclude those unknowns that are close to zero.\n\ncpars = (parm=:arclength, nmax=4000, Dsc=:auto, angopt=deg2rad(10), itopt=4);\n\nOm0 = 40.0;\nOm1 = 100.0;\ndOm = 5.0;\nsolss = [];\nUhs = [];\nFamps = [0.5, 1., 2., 4., 8., 16.];\nfor Famp in Famps\n    sols, _, _, _, _ = CONTINUATE(U0_(Famp), fun(Famp), [Om0, Om1], dOm; cpars...);\n\n    Uh = [Lb[end-1,:]'reshape(u, mdl.Ndofs,:) for u in sols.u];\n\n    push!(solss, sols)\n    push!(Uhs, Uh);\nend","category":"section"},{"location":"e_febeam/#Stability-Certification","page":"E: Finite Element Beam with Nonlinear Support","title":"Stability Certification","text":"E0, _ = HARMONICSTIFFNESS(zeros(mdl.Ndofs,mdl.Ndofs), -2mdl.M,\n    zeros(mdl.Ndofs, mdl.Ndofs), [1.], h);\nindsh1 = [rinds[1:mdl.Ndofs]; iinds[1:mdl.Ndofs]];\nE0 = collect(E0);\n\nstabs = [];\nfor (Famp,sols) in zip(Famps,solss)\n    stab = zeros(length(sols));\n    for iw in 1:length(sols)\n        J = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\n        fun(Famp).jac(J, sols.u[iw], sols.p[iw])\n        eVs = eigvals(J[indsh1,indsh1], sols.p[iw]*E0[indsh1,indsh1]);\n        stab[iw] = sum(real(eVs).>=0);\n    end\n    push!(stabs, stab);\nend","category":"section"},{"location":"e_febeam/#Plot-Forced-Response","page":"E: Finite Element Beam with Nonlinear Support","title":"Plot Forced Response","text":"We now plot out the forced response of the system showing the characteristic frictional softening-dampening behavior.\n\nset_theme!(theme_latexfonts())\nfsz = 18;\nfig = Figure(fontsize=fsz);\n\nax = Axis(fig[1, 1], xlabel=\"Excitation Frequency (rad/s)\",\n    ylabel=\"Response (m)\", yscale=log10);\nfor (Famp, Uh, sols, stab) in zip(Famps, Uhs, solss, stabs)\n    scatterlines!(ax, sols.p./(stab.==0), norm.(Uh)/Famp, label=\"F = $Famp\")\n    scatterlines!(ax, sols.p./(stab.!=0), norm.(Uh)/Famp)\nend\n\nxlims!(ax, Om0, Om1)\nylims!(ax, 3e-4, 1e-1)\n\nLegend(fig[0, 1], ax, nbanks=3, tellheight=true, tellwidth=false)\n    fig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"b2_jenkhb/#ex_b2","page":"2: Frictional Oscillator","title":"Example B2: Numerical Continuation on a Frictional Oscillator","text":"The scope as well as the approach of this example are very similar to Example b1, with a key difference: this example involves a hysteretic nonlinearity. This poses a very important difference in how the nonlinear force and its harmonics are computed.\n\nThe general setup for the problem is similar:\n\nddotx + 2zeta_0omega_0dotx + omega_0^2 x + f_nl = FcosOmega t\n\nThe nonlinearity f_nl is a hysteretically saturated linear spring with low amplitude stiffness k_t and saturation limit (\"slip\" force) f_s.\n\nThe steps that will be followed in this file are exactly the same as in Example b1:\n\nFirst we define a \"harmonic residue\" function for the Duffing oscillator in a way that returns the residue, its Jacobian with respect to the vector of harmonics (see Example a), and also with respect to the excitation frequency.\nNext we define the parameters for the problem and setup the necessary variables for the Harmonic Balance (and AFT).\nThen we conduct the actual continuation after setting up parameters for this.\nFinally the results are plotted in terms of the different harmonics present.","category":"section"},{"location":"b2_jenkhb/#Preamble:-Load-Packages","page":"2: Frictional Oscillator","title":"Preamble: Load Packages","text":"using GLMakie\nusing LaTeXStrings\nusing LinearAlgebra\nusing NonlinearSolve\nusing ForwardDiff\nusing DSP\n\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION","category":"section"},{"location":"b2_jenkhb/#exb2_res","page":"2: Frictional Oscillator","title":"Define Residue Function","text":"The structure of the residue function is identical to that in Example 1. A key differerence is in the computation of the nonlinear force.\n\nUnlike in the previous case, the restoring force of a hysteretic element can not be estimated at any instant of time independent of its history. In other words, the restoring force of a hysteretic element can be different based on its loading history. For steady state calculations, we start by assuming initially that the hysteretic element acts as a linear spring (see ft=kt*ut below) and then \"march forward\" in time. At each instant the incremental form of the friction law is used to check if saturation is violated and the restoring force is corrected appropriately. The force \"shakes down\" after repeating this for 2 or more cycles of the period. We use this steady-state force for the Fourier transforms involve in Harmonic Balance.\n\nfunction RESFUN!(Uw, Fl, pars, h, Nt; R=nothing, dRdU=nothing, dRdw=nothing)\n    (; z0, w0, kt, fs, F) = pars;\n\n    Om = Uw[end];\n    Nhc = sum((h.==0)+2(h.!=0));\n\n    # Linear Portion\n    E, dEdw = HARMONICSTIFFNESS(1.0, 2z0*w0, w0^2, Om, h);\n\n    # AFT For nonlinear force\n    ut  = AFT(Uw[1:end-1], h, Nt, :f2t);\n\n    # Construct Residue\n    if !(R === nothing && dRdU === nothing)\n        ft = kt*ut;\n        if !(dRdU === nothing)\n            cst = AFT(eltype(Uw).(I(Nhc)), h, Nt, :f2t);\n            dfdat = kt.*cst;\n        end\n\n        for _ in 1:2\n            for (ti, tim1) in zip(1:Nt, circshift(1:Nt,1))\n                fsp = kt*(ut[ti]-ut[tim1]) + ft[tim1];  # stick prediction\n                ft[ti] = clamp(fsp, -fs, fs);\n                if !(dRdU === nothing)\n                    if (abs(fsp)<fs)\n                        dfdat[ti, :] = kt.*(cst[ti,:]-cst[tim1,:]) + dfdat[tim1,:];\n                    else\n                        dfdat[ti, :] .= 0.0;\n                    end\n                end\n            end\n        end\n        if !(R === nothing)\n            Fnl = AFT(ft, h, Nt, :t2f);\n            R[:] = E*Uw[1:end-1] + Fnl - Fl*F;\n        end\n        if !(dRdU === nothing)\n            Jnl    = AFT(dfdat, h, Nt, :t2f);\n            dRdU[:, :] = E + Jnl;\n        end\n    end\n    if !(dRdw === nothing)\n        dRdw[:] = dEdw*Uw[1:end-1];\n    end\n    return nothing;\nend","category":"section"},{"location":"b2_jenkhb/#exb2_setup","page":"2: Frictional Oscillator","title":"Setup","text":"Now we setup the specific problem by assigning numerical values to the parameters. Odd harmonics are chosen for the Harmonic Balance since we already have some intuition on the nonlinearity (it, being an \"odd function\" nonlinearity). As before, this is followed by setting up a NonlinearFunction object that will be used for the continuation.\n\npars = (z0 = 0.5e-2, w0 = 2., kt = 5.0, fs=1.0, F = 0.1);\n\n# h = (0:5); # Also possible\nh = 1:2:5;\nOm = 0.1;\n\nNhc = sum((h.==0)+2(h.!=0));\nNt = 2^9;\n\nFl = zeros(Nhc);\n_,_,zinds,rinds,iinds = HINDS(1, h)\nFl[rinds[1]] = 1.0;\n\nfun = NonlinearFunction((r,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;R=r),\n    jac=(J,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdU=J),\n    paramjac=(Jp,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdw=Jp));\nnothing #hide","category":"section"},{"location":"b2_jenkhb/#Check-by-solving-for-a-Single-point","page":"2: Frictional Oscillator","title":"Check by solving for a Single point","text":"We do the single point check to ensure that everything works - no errors in the residue, the Jacobian is correct, etc. This should also converge within 3-4 iterations.\n\nE = zeros(Nhc, Nhc);\nHARMONICSTIFFNESS!(E, nothing, 1.0, 2pars.z0*pars.w0, pars.w0^2+pars.kt, Om, h);\nU0 = E\\ (Fl*pars.F);\n\nprob = NonlinearProblem(fun, U0, Om);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"section"},{"location":"b2_jenkhb/#exb2_cont","page":"2: Frictional Oscillator","title":"Continuation","text":"Finally we're ready to do the continuation so we setup the system as before: initialize continuation parameters and setup the initial guess. Then we invoke CONTINUATE to compute the solutions and then arrange the harmonics in complex notation for plotting.\n\nOm0 = 0.02pars.w0;\nOm1 = 2pars.w0;\ndOm = 0.04pars.w0;\ncpars = (parm=:riks, nmax=300, Dsc=:auto, minDsc=1e-2);\n\nHARMONICSTIFFNESS!(E, nothing, 1.0, 2pars.z0*pars.w0, pars.w0^2+pars.kt, Om0, h);\nU0 = E\\ (Fl*pars.F);\n\nsols, its, dss, xis, Dsc = CONTINUATE(U0, fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols));\nuh[h.+1, :] = hcat([[s.up[zinds]; s.up[rinds]+1im*s.up[iinds]] for s in sols]...);\nOms = [s.up[end] for s in sols];\nnothing #hide","category":"section"},{"location":"b2_jenkhb/#exb2_plot","page":"2: Frictional Oscillator","title":"Plotting","text":"Here again, we visualize the harmonic contents. Unlike the previous example, a very clear non-smooth behavior can be noticed here. It is only near the resonance, when amplitude is large, where the higher harmonics show up. At other frequencies, the higher harmonics are all zero.\n\nhis = [1, 3, 5];\n\nfsz = 24;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\nax1s = [];\nax2s = [];\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :]));\n    push!(ax1s, ax)\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :])));\n    push!(ax2s, ax)\nend\nlinkxaxes!(vcat(ax1s, ax2s)...)\n\n    fig","category":"section"},{"location":"b2_jenkhb/#exb2_outro","page":"2: Frictional Oscillator","title":"Outro","text":"This is yet another example of using the utility functions in HARMONIC for conducting harmonic balance. Looking at Example b1 and this, it must be clear that a lot of the \"setup\" that has to be done for any given system is very similar. So it makes sense to have a unified interface which constructs the different residue functions for a given system with its nonlinearity. This is precisely what the MDOFUTILS module sets out to do.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"c2_mdofgen_hystnl/#ex_c2","page":"2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","title":"Example C2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","text":"Much like Examples B1 and B2, this builds off of Example C1 to conduct the forced response analysis of a 2DoF oscillator with a hysteretic support.\n\nThe dynamical system that will be studied here is:\n\nunderbracebeginbmatrix 1001 endbmatrix_mxM beginbmatrix ddotx_1 ddotx_2 endbmatrix +\nleft( 001 mxM + 0001 mxKright) beginbmatrix dotx_1 dotx_2 endbmatrix + underbracebeginbmatrix 2-1-12 endbmatrix_mxK beginbmatrix x_1x_2 endbmatrix + beginbmatrix 0 f_fr(x_2) endbmatrix = beginbmatrix 10 endbmatrixcosOmega t\n\nThe steps followed in this file are the same as in Example C1, except for the fact that we will now specify that the nonlinearity type is :Hyst:\n\nFirst we specify the system under study in terms of its \"MCK\" matrices and the nonlinearities it contains.\nNext we setup the parameters for Harmonic Balance and setup the harmonic excitation vector.\nAnd that's it! We're ready to compute the forced responses and visualize the results.","category":"section"},{"location":"c2_mdofgen_hystnl/#Preamble:-Load-Packages","page":"2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","title":"Preamble: Load Packages","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"section"},{"location":"c2_mdofgen_hystnl/#exc2_setup","page":"2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","title":"System Setup","text":"We provide the MCK matrices just as before.\n\nM = collect(1.0I(2));\nK = [2. -1.;-1. 2.];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\nnothing #hide\n\nFor the nonlinearity setup the signature of the nonlinear force is different (read the documentation of ADDNL), now conducting incremental evaluation and making explicit reference to the displacement and force at the previous step(s). This is added to the MDOFGEN model the same way as before, using the ADDNL routine.\n\n# Nonlinearity\nkt = 1.0;\nfs = 1.0;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\nL = [0.0 1.0];\n\nmdl = ADDNL(mdl, :Hyst, fnl, L);\nnothing #hide","category":"section"},{"location":"c2_mdofgen_hystnl/#exc2_hbsetup","page":"2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","title":"Setup HB","text":"We setup the HB, test nonlinear force evaluation through NLEVAL!, and test the HB residue.\n\nh = 0:5;\nN = 256;\nt = (0:N-1)*2π/N;\n\nNhc = sum(all(h.==0, dims=2) + 2any(h.!=0, dims=2));\n\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h)\nFl = zeros(Nhc*mdl.Ndofs);\nFl[rinds[1]] = 1.0;\n\nWst = 0.6;\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Wst, h);\n\nUw0 = [E\\Fl; Wst];\nnothing #hide","category":"section"},{"location":"c2_mdofgen_hystnl/#exc2_nleval","page":"2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","title":"Evaluate the Nonlinear Forces","text":"FNL = zeros(mdl.Ndofs*Nhc);\ndFNLdU = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\ndFNLdw = zeros(mdl.Ndofs*Nhc);\nNLEVAL!(2Uw0, mdl, h, N; FNL=FNL, dFNLdU=dFNLdU, dFNLdw=dFNLdw)","category":"section"},{"location":"c2_mdofgen_hystnl/#exc2_testhb","page":"2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","title":"Test HB Residue","text":"R = zeros(mdl.Ndofs*Nhc);\ndRdU = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\ndRdw = zeros(mdl.Ndofs*Nhc);\nHBRESFUN!(Uw0, mdl, Fl, h, N; R=R, dRdU=dRdU, dRdw=dRdw)\n\nFamp = 1.0;\n\nfun = NonlinearFunction((r,u,p)->HBRESFUN!([u;p], mdl, Famp*Fl, h, N; R=r),\n    jac=(J,u,p)->HBRESFUN!([u;p], mdl, Famp*Fl, h, N; dRdU=J),\n    paramjac=(Jp,u,p)->HBRESFUN!([u;p], mdl, Famp*Fl, h, N; dRdw=Jp));\n\nprob = NonlinearProblem(fun, Uw0[1:end-1], Uw0[end]);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"section"},{"location":"c2_mdofgen_hystnl/#exc2_cont","page":"2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","title":"Continuation","text":"Also like before, we do the continuation to compute the full forced response curve.\n\nNote that the code in the last two sections (Setup HB and Continuation) are identical to their counterparts in Example C1. This is what juliajim is all about - the analysis is abstracted enough that the code should look nearly the same except for the setup of the nonlinearity.\n\nOm0 = 0.1;\nOm1 = 3;\ndOm = 0.2;\ncpars = (parm=:arclength, nmax=1000, Dsc=:auto, angopt=deg2rad(1));\n\nsols, its, dss, xis, Dsc = CONTINUATE(Uw0[1:end-1], fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols), 2);\nfor i in 1:2\n    uh[h.+1, :, i] = hcat([[s.up[zinds[i:2:end]];\n                            s.up[rinds[i:2:end]]+1im*s.up[iinds[i:2:end]]]\n                          for s in sols]...);\nend\nOms = [s.up[end] for s in sols];\nnothing #hide","category":"section"},{"location":"c2_mdofgen_hystnl/#exc2_plot","page":"2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity","title":"Plotting","text":"Just like before, we visualize the results. Notice, just like in Example B2 that the non-smooth behavior of the nonlinearity is very striking.\n\nhis = [1, 3, 5];\n\nfsz = 24;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n              ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    lines!(ax, Oms, abs.(uh[his[i].+1, :, 1]), label=\"x1\");\n    lines!(ax, Oms, abs.(uh[his[i].+1, :, 2]), label=\"x2\");\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n              ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    lines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    lines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\nend\n\n    fig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"d1_deflation/#ex_d1","page":"1: Deflation to Locate Multiple roots","title":"Example D1: Deflation to Locate Multiple roots","text":"It is sometimes the case that we are trying to solve for the solution of a system of equations that has multiple zeros where one is (or a few are) already known. Case in point in dynamical systems: computing bifurcated branches emanating from a \"main\" branch of solutions.\n\nWe use the method of deflation to discourage the solver from converging to the previously known solution(s) by penalizing the residue by the distance to that solution. Let us suppose that u_0 is the previously known solution point and R(u) is the residue function that needs to be solved (uin mathbbR^n, R mathbbRto mathbbR). We write the deflated residue\n\nR_d(u) = frac1u-u_0_2^2 R(u)\n\nwhere x_2 denotes the 2-norm. The limit uto u_0 may or may not exist for R_d(u) based on the speed at which R(u) goes to zero at u_0, and this may affect the behavior of R_d(u). Notwithstanding this, we find using the 2-norm as above to be quite effective for most problems.\n\nR_d(u)\n\ndiscourages the solver from approaching the known solution u_0, allowing us to converge to another solution if it exists and if our initial guess is close enough.\n\njuliajim implements DEFLATEDRES! which is a deflation wrapper routine that can be used on top of any existing residue function to achieve deflation.\n\nThis example demonstrates this through a simple 2-state system of polynomial equations with two known roots:\n\nR(u p) = beginbmatrix u_2-p u_1-u_2+fracu_1^34 endbmatrix\n\nwhich is solved by (u_1u_2)=(-2sqrtp0) (00) (2sqrtp0).","category":"section"},{"location":"d1_deflation/#Load-Packages","page":"1: Deflation to Locate Multiple roots","title":"Load Packages","text":"using NonlinearSolve\nusing LinearAlgebra\n\nusing juliajim.MDOFUTILS","category":"section"},{"location":"d1_deflation/#Setup-Residue-function","page":"1: Deflation to Locate Multiple roots","title":"Setup Residue function","text":"function fres!(up, r=nothing, j=nothing, jp=nothing)\n    if !(r === nothing)\n        r[:] = [up[2];-up[3]*up[1]-up[2]+up[1]^3/4];\n    end\n    if !(j === nothing)\n        j[:, :] = [0 1;-up[3]+3up[1]^2/4 -1];\n    end\n    if !(jp === nothing)\n        jp[:] = [0;-1];\n    end\nend","category":"section"},{"location":"d1_deflation/#Obtain-the-first-solution","page":"1: Deflation to Locate Multiple roots","title":"Obtain the first solution","text":"par = 3.0;\nu0 = [3.0,0];\n\nfun1 = NonlinearFunction((r,u,p)->fres!([u;p], r),\n    jac=(J,u,p)->fres!([u;p], nothing,J),\n    paramjac=(Jp,u,p)->fres!([u;p], nothing,nothing,Jp));\nprob1 = NonlinearProblem(fun1, u0, par);\nsol1 = solve(prob1, show_trace=Val(true));\nnothing #hide\n\nThis returns the solution\n\nsol1\n\nwhich is exactly (2sqrtp0) as expected.","category":"section"},{"location":"d1_deflation/#Deflated-Solution","page":"1: Deflation to Locate Multiple roots","title":"Deflated Solution","text":"uC = [sol1.u; par];\n\nfun2 = NonlinearFunction((r,u,p)-> DEFLATEDRES!([u;p], uC, fres!; R=r),\n    jac=(J,u,p)-> DEFLATEDRES!([u;p], uC, fres!; J=J),\n    paramjac=(Jp,u,p)-> DEFLATEDRES!([u;p], uC, fres!; Jp=Jp));\nprob2 = NonlinearProblem(fun2, u0, par);\nsol2 = solve(prob2, show_trace=Val(true));\nnothing #hide\n\nThis returns the trivial solution (00) for the above initial guess:\n\nsol2","category":"section"},{"location":"d1_deflation/#Adding-multiple-deflators","page":"1: Deflation to Locate Multiple roots","title":"Adding multiple deflators","text":"DEFLATEDRES! allows specifying multiple solutions (in a list) for deflation. Let us specify both the solutions found above.\n\nuCs = [[sol1.u;par], [sol2.u;par]];\n\nfun3 = NonlinearFunction((r,u,p)-> DEFLATEDRES!([u;p], uCs, fres!, R=r),\n    jac=(J,u,p)-> DEFLATEDRES!([u;p], uCs, fres!, J=J),\n    paramjac=(Jp,u,p)-> DEFLATEDRES!([u;p], uCs, fres!, J=J));\nprob3 = NonlinearProblem(fun3, u0, par);\nsol3 = solve(prob3, show_trace=Val(true));\nnothing #hide\n\nNow we recover the solution (-2sqrtp0)!\n\nsol3\n\nNow isn't that cool? We've used exactly the same initial guess and have progressively recovered all the solutions of the system.","category":"section"},{"location":"d1_deflation/#What-if-we-kept-going?","page":"1: Deflation to Locate Multiple roots","title":"What if we kept going?","text":"In the practical setting we are sometimes not destined to know a priori how many solutions to expect. So let us keep going to see what happens.\n\nuCs = [[s.u;par] for s in [sol1,sol2,sol3]];\nfun4 = NonlinearFunction((r,u,p)-> DEFLATEDRES!([u;p], uCs, fres!, R=r),\n    jac=(J,u,p)-> DEFLATEDRES!([u;p], uCs, fres!, J=J),\n    paramjac=(Jp,u,p)-> DEFLATEDRES!([u;p], uCs, fres!, J=J));\nprob4 = NonlinearProblem(fun4, u0, par);\nsol4 = solve(prob4, show_trace=Val(true))\n\nNonlinearSolve will try out its list of methods and then finally get stalled. While this implies the absence of another solution in this case (because we know this), in the general case this merely implies the absence of another solution in the basin of attraction of the provided initial guess. The general problem of numerically eliminating possible solutions is quite complex!\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"a_hworld/#ex_a","page":"A: Harmonic Utilities","title":"Example A: Introduction to the AFT Routines","text":"This example is intended to showcase the Alternating Frequency Time (AFT) routines in juliajim.HARMONIC.\n\nAt its core, it is just a bunch of utility routines that allow time-to-frequency and frequency-to-time transformations. These can also be used for Chebyshev polynomial expansions, as will be seen below.","category":"section"},{"location":"a_hworld/#Preamble:-Load-the-necessary-packages","page":"A: Harmonic Utilities","title":"Preamble: Load the necessary packages","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing Arpack\n\nusing juliajim.HARMONIC","category":"section"},{"location":"a_hworld/#Alternating-Frequency-Time-Transformation","page":"A: Harmonic Utilities","title":"Alternating Frequency Time Transformation","text":"","category":"section"},{"location":"a_hworld/#AFT-Single-Frequency-(Periodic-signal)","page":"A: Harmonic Utilities","title":"AFT - Single Frequency (Periodic signal)","text":"Here we will use the AFT routine to do a Fourier transform of a time-domain signal, yt, to compute its Fourier coefficients, yf. The general form assumed for a Fourier series is:\n\ny = a_0 + sum_n=1^H a_n cos ntau + sin ntau\n\nwhere (\\tau) is the scaled time such that the signal y(tau) is 2pi-periodic. For instance, if the excitation frequency is Omega and physical time is t (such that we have 2piOmega as the time period), the scaled time coordinate tau is defined as tau=Omega t.\n\nThe AFT routine provides a convenience utility for transforming from a discrete time array to an array of the Fourier coefficients which is written as\n\nbeginbmatrix a_0  a_1  b_1  a_2  b_2  dots endbmatrix\n\nThe same routine may also be used to do the opposite transformation (frequency coefficients to time array).\n\nWe first discretize time by dividing the domain 0 2pi into 128 parts.\n\nN = 128;\nt = (0:N-1)*2π/N;\n# yt = cos.(t) + 3sin.(2t) .+ 4;\nyt = cos.(t) .+ 2;\nyt = [yt yt];\nnothing #hide\n\nWe have put two copies of the vector yt in columns to expose the fact that the AFT routine is vectorized: Having time series in M columns will return corresponding Fourier coefficients in M columns.\n\nNow we set the list of harmonics of interest. This can also be an unordered list, but if you're including the zeroth harmonic, that should always be the first.\n\nh = 0:3\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nnothing #hide\n\nThe variable Nhc is the number of harmonic coefficients. For the zeroth harmonics we have only one coefficient ((a0) above) and for every non-zero harmonic we have two, correponding to the sine and cosine ((ai,b_i) above). The formula above looks more complicated than it must because this works even for the multi-frequency case.\n\nNow we call the actual AFT routine. The first argument is the time series vector (or matrix of column vectors), the second argument is the harmonic indices of interest, third is the number of AFT samples (when inputting the time vector N has to be the same as the number of rows of yt), and the last argument is a Symbol. The last argument specifies if we're interested in a time-to-frequency (:t2f) or frequency-to-time (:f2t) transformation.\n\nyf = AFT(yt, h, N, :t2f);  # Time to Frequency\nYT = AFT(yf, h, N, :f2t);  # Frequency to Time\nnothing #hide\n\nyf is the list of harmonics and YT is the time vector reconstructed from the harmonics. You should be able to verify that yt and YT are numerically the same.\n\nyf","category":"section"},{"location":"a_hworld/#AFT-2-Frequency-Case-(Quasi-periodic-signal)","page":"A: Harmonic Utilities","title":"AFT - 2 Frequency Case (Quasi-periodic signal)","text":"Now we show how the same AFT routine can be used for multi-frequency Fourier representations. Our Fourier series representation is written as\n\ny(t) = a_0 + sum_n=1^H a_n cos( h1_n tau_1 + h2_n tau_2) + b_n sin( h1_n tau_1 + h2_ntau_2 )textwith  tau_i = Omega_i t\n\nHere, h1 h2 are index arrays storing the harmonic coefficient corresponding to the two frequencies present. The scaled time coordinates (aka Torus coordinates) (tau_1tau_2) are defined as above such that the signal y(t) can be written as the torus function Y(tau_1tau_2), which is periodic on the 2D domain. Note that y(t) and Y(tau_1 tau_2) are not the same, although we can reconstruct y(t) from Y(tau_1tau_2).\n\nThe usage of the routine is identical to before.\n\nts = Iterators.product(t, t);\nyt = [cos(t1)+3sin(t2)+4 for (t1,t2) in ts];\nh = [0 0;1 0;0 1;1 1];\n\nyf = AFT([yt[:] yt[:]], h, N, :t2f);\nYT = AFT(yf, h, N, :f2t);\nyf","category":"section"},{"location":"a_hworld/#Convenience-Routine-for-Harmonic-Selection:-[HSEL](@ref)","page":"A: Harmonic Utilities","title":"Convenience Routine for Harmonic Selection: HSEL","text":"Since harmonic selection in the 2D (and general N-D) case is not as trivial as writing 0:3 for the 1D case (different combinations of the indices must be considered on the tensor-grid while accounting for redundancies. The convenience routine HSEL helps to do this - one can specify the maximum harmonic order (Nhmax below) and the number of components (C below) and obtain a (H\\times C) matrix of indices.\n\nC = 2;\nNhmax = 4;\n\nh = HSEL(Nhmax, 1:C);  # Second argument is the list of frequencies\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nnothing #hide","category":"section"},{"location":"a_hworld/#Convenient-Routine-for-Harmonic-Indices:-[HINDS](@ref)","page":"A: Harmonic Utilities","title":"Convenient Routine for Harmonic Indices: HINDS","text":"It is often necessary to also know the indices of the cosine and sine harmonics individually. The HINDS routine helps with this.\n\nh = (0:4);\nzinds, hinds, rinds0, rinds, iinds = HINDS(1, h)\n\nHere, zinds and hinds store the indices that have to be used for a complex representation ((\\begin{bmatrix} a0&a1-ib1&a2-ib_2&\\dots \\end{bmatrix})) and rinds0, rinds, and iinds store the indices \\hat{t} have to be used for the real Fourier coefficients representation. Specifically, rinds0 are the indices for the zeroth harmonic, rinds are the indices for the cosine harmonics and iinds are the indices for the sine harmonics.\n\nThe routine can also be called when there are multiple Degrees-of-Freedom. See below for the case of 3 DoFs. This should also clarify the ordering convention used in this package.\n\nh = (0:4);\nzinds, hinds, rinds0, rinds, iinds = HINDS(3, h)\n\nNote that the routine also supports multi-frequency cases (h with multiple columns).","category":"section"},{"location":"a_hworld/#The-\"Harmonic\"-Stiffness","page":"A: Harmonic Utilities","title":"The \"Harmonic\" Stiffness","text":"Harmonic Balance is a numerical technique where the solution for a dynamical system (expressed in second order form) is expressed in terms of its Fourier series. The resulting algebraic system is solved numerically. For a linear system, however, the algebraic system can be simplified significantly and written in a succinct (\\mx{E} \\vc{u} = \\vc{f}) form.\n\nConsider a linear dynamical system with (n) Degrees-of-Freedom of the form:\n\nmxM ddotvcx + mxC dotvcx + mxK vcx = vcF(t)quad vcxinmathbbR^n\n\nWe expand out the vector of unknowns (\\vc{x}) as\n\nvcx = vca_0 + sum_n=1^H vca_n cos ntau + vcb_n sin ntautextwith  vca_ivcb_iin mathbbR^n\n\nand write the vector of harmonic coefficients (\\vc{u}) as\n\nvcu = beginbmatrix vca_0 vca_1 vcb_1 vca_2 vcb_2 vdots endbmatrix\n\nSubstituting the harmonic ansatz into the governing equations and projecting the resulting residue onto the Fourier basis functions leads to:\n\nbeginbmatrix\nmxK  \nmxK-Omega^2 mxM  Omega mxC  \n-Omega mxC  mxK-Omega^2 mxM \nmxK-(2Omega)^2 mxM  (2Omega) mxC\n -(2Omega) mxC  mxK-(2Omega)^2 mxM \nddots\nendbmatrix\nbeginbmatrix vca_0 vca_1 vcb_1 vca_2 vcb_2 vdots endbmatrix =\nbeginbmatrix vcf_a0 vcf_a1 vcf_b1 vcf_a2 vcf_b2 vdots endbmatrix\n\nThe HARMONICSTIFFNESS function provides a convenience routine for just this. It works for arbitrary number of frequency components also. The usage is as follows. Since the frequency jacobian of this matrix is often necessary, this is also returned by the routine. There is also an in-place version of this in HARMONICSTIFFNESS!.\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nC = 2;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C)\nws = [1, π];\nws = ws[1:C];\n\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\nE","category":"section"},{"location":"a_hworld/#Forced-Response-Computation-with-[HARMONIC](@ref)","page":"A: Harmonic Utilities","title":"Forced Response Computation with HARMONIC","text":"We shall now use the above utilites to compute the forced response of a linear system. The code below should be self explanatory.\n\nC = 1;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C);\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nFl = zeros(Nhc, 1);\nFl[2] = 1.0;\nFl = kron(Fl, [1;0]);\n\nOmr, V = eigen(K, collect(M));\nOmr = sqrt.(Omr);\n\nΩs = LinRange(0.5, 2, 500);\nAs = zeros(ComplexF64, size(Ωs));\n\nfor i = eachindex(Ωs)\n    local E, dEdw\n    E, dEdw = HARMONICSTIFFNESS(M, D, K, [Ωs[i]], h);\n    U = E\\Fl;\n    As[i] = U[3]+im*U[5];\nend\n\nset_theme!(theme_latexfonts())\nfsz = 18;\nfig = Figure(fontsize=fsz);\n\nax = Axis(fig[1, 1],\n    xlabel=\"Excitation Frequency (rad/s)\",\n    ylabel=\"Response Amplitude (m)\",\n    xscale=Makie.pseudolog10,\n    yscale=Makie.pseudolog10);\nlines!(ax, Ωs, abs.(As))\n\n    fig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"c1_mdofgen_instnl/#ex_c1","page":"1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","title":"Example C1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","text":"This example is designed to expose the core features of the MDOFUTILS module. As already noted in Example b2, much of the setup while doing these analyses are very repetitive and common. MDOFUTILS abstracts much of this so the user can focus on the dynamics.\n\nThe dynamical system that will be studied here is:\n\nunderbracebeginbmatrix 1001 endbmatrix_mxM beginbmatrix ddotx_1 ddotx_2 endbmatrix +\nleft( 001 mxM + 0001 mxKright) beginbmatrix dotx_1 dotx_2 endbmatrix + underbracebeginbmatrix 2-1-12 endbmatrix_mxK beginbmatrix x_1x_2 endbmatrix + beginbmatrix 0 beta x_2^3 endbmatrix = beginbmatrix 10 endbmatrixcosOmega t\n\nThe steps followed in this file are:\n\nFirst we specify the system under study in terms of its \"MCK\" matrices and the nonlinearities it contains.\nNext we setup the parameters for Harmonic Balance and setup the harmonic excitation vector.\nAnd that's it! We're ready to compute the forced responses and visualize the results.","category":"section"},{"location":"c1_mdofgen_instnl/#Preamble:-Load-Packages","page":"1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","title":"Preamble: Load Packages","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"section"},{"location":"c1_mdofgen_instnl/#exc1_setup","page":"1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","title":"System Setup","text":"We specify the linear \"MCK\" matrices of the system here. Also check out the documentation for the MDOFGEN struct.\n\nM = collect(1.0I(2));\nK = [2. -1.;-1. 2.];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\nnothing #hide\n\nNext we specify the nonlinearity using a function handle. This function handle must take 3 input arguments (time, displacement, velocity) and output 3 results (force, displacement derivative, velocity derivative). Although the nonlinearity is a simple spring here, this same routine also supports more complicated nonlinearities involving multiple degrees of freedom. In such cases, u,ud must be an (N\\times d) matrix where (N) is the number of time samples and (d) is the number of nonlinear degrees-of-freedom. It should also return d forces (for adjoint forcing).\n\nAlong with this, we also specify a \"selector matrix\" (\\mx{L}) such that the nonlinear DoFs are (\\mx{L}\\vc{u}) when (\\vc{u}) is the vector of all the DoFs.\n\n# Nonlinearity\nβ = 0.1;\nfnl = (t,u,ud)->return β.*u.^3, 3β.*u.^2, zeros(size(u));;\nL = [0.0 1.0];\nnothing #hide\n\nWe \"add\" the nonlinearity to the MDOFGEN object (mdl here) using the ADDNL routine. The second argument here specifies that the nonlinearity can be evaluated \"instantaneously\", like a cubic spring (UNlike a Jenkins element, as in Example b2. ADDNL also supports non-self adjoint forcing - check its documentation for this. Under the hood, this creates an object of the NONLINEARITY struct and pushes it into the field NLTs (which is a vector of NONLINEARITY objects) of the MDOFGEN object. Each NONLINEARITY object contains a type, the force evaluation function and a DoF selection (and force distribution) matrix.\n\nmdl = ADDNL(mdl, :Inst, fnl, L);\nnothing #hide","category":"section"},{"location":"c1_mdofgen_instnl/#exc1_hbsetup","page":"1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","title":"Setup HB","text":"Next we setup the harmonics necessary and the number of time samples to use per period for the Alternating Frequency Time (AFT) step. We setup the excitation vector in the frequency domain by using the indices returned by HINDS - we set Fl to be non-zero at the first cosine harmonic index, which will correspond to the first harmonic of the first DoF.\n\nh = 0:5;\nN = 128;\nt = (0:N-1)*2π/N;\n\nNhc = sum(all(h.==0, dims=2) + 2any(h.!=0, dims=2));\n\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h)\nFl = zeros(Nhc*mdl.Ndofs, 1);\nFl[rinds[1]] = 1.0;\n\nWst = 0.6;\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, Wst, h);\n\nUw0 = [E\\Fl; Wst];\nnothing #hide","category":"section"},{"location":"c1_mdofgen_instnl/#exc1_nleval","page":"1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","title":"Evaluate the Nonlinear Forces","text":"The NLEVAL! routine is defined in MDOFUTILS. This uses the appropriate methodology to evaluate each nonlinearity that has been added to the given MDOFGEN model. The function is written in the in-place evaluation for efficiency. The routine directly just returns the nonlinear force harmonics (FNL here).\n\nFNL = zeros(mdl.Ndofs*Nhc);\ndFNLdU = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\ndFNLdw = zeros(mdl.Ndofs*Nhc);\nNLEVAL!(Uw0, mdl, h, N; FNL=FNL, dFNLdU=dFNLdU, dFNLdw=dFNLdw);\nFNL","category":"section"},{"location":"c1_mdofgen_instnl/#exc1_testhb","page":"1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","title":"Test HB Residue","text":"HBRESFUN! implements the Harmonic Balance forced response residue. This can be used in the same way that the RESFUN! functions were used in Example b1 and Example b2 for forced response evaluation.\n\nR = zeros(mdl.Ndofs*Nhc);\ndRdU = zeros(mdl.Ndofs*Nhc, mdl.Ndofs*Nhc);\ndRdw = zeros(mdl.Ndofs*Nhc);\nHBRESFUN!(Uw0, mdl, Fl, h, N; R=R, dRdU=dRdU, dRdw=dRdw)\n\nfun = NonlinearFunction((r,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; R=r),\n    jac=(J,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; dRdU=J),\n    paramjac=(Jp,u,p)->HBRESFUN!([u;p], mdl, Fl, h, N; dRdw=Jp));\n\nprob = NonlinearProblem(fun, Uw0[1:end-1], Uw0[end]);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide","category":"section"},{"location":"c1_mdofgen_instnl/#exc1_cont","page":"1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","title":"Continuation","text":"HBRESFUN! can also be used in tandem with CONTINUATE for getting the full forced response.\n\nOm0 = 0.1;\nOm1 = 3;\ndOm = 0.1;\nnothing #hide\n\nThe angopt property can be reduced to get finer resolved curves\n\ncpars = (parm=:arclength, nmax=2000, Dsc=:auto, angopt=deg2rad(1));\n\nsols, its, dss, xis, Dsc = CONTINUATE(Uw0[1:end-1], fun, [Om0, Om1], dOm; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols), 2);\nfor i in 1:2\n    uh[h.+1, :, i] = hcat([[s.up[zinds[i:2:end]];\n                            s.up[rinds[i:2:end]]+1im*s.up[iinds[i:2:end]]]\n                          for s in sols]...);\nend\nOms = [s.up[end] for s in sols];\nnothing #hide","category":"section"},{"location":"c1_mdofgen_instnl/#exc1_plot","page":"1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity","title":"Plotting","text":"Now we plot the response harmonics. It can be seen that two primary and 3 secondary (super harmonic) resonances have been picked up. The nonlinearity level is quite strong, as evidenced by the non-trivial shapes of the response curves.\n\nhis = [1, 3, 5];\n\nfsz = 24;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\naxs = [];\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    lines!(ax, Oms, abs.(uh[his[i].+1, :, 1]), label=\"x1\");\n    lines!(ax, Oms, abs.(uh[his[i].+1, :, 2]), label=\"x2\");\n    push!(axs, ax);\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    lines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    lines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\n    push!(axs, ax)\nend\n\nlinkxaxes!(axs...);\n\n    fig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"Pages = [\"reference.md\"]","category":"section"},{"location":"reference/#Main-Module","page":"Reference","title":"Main Module","text":"","category":"section"},{"location":"reference/#Module-Harmonic","page":"Reference","title":"Module Harmonic","text":"","category":"section"},{"location":"reference/#Module-CONTINUATION","page":"Reference","title":"Module CONTINUATION","text":"","category":"section"},{"location":"reference/#Module-MDOFUTILS","page":"Reference","title":"Module MDOFUTILS","text":"","category":"section"},{"location":"reference/#Module-NLDYN","page":"Reference","title":"Module NLDYN","text":"","category":"section"},{"location":"reference/#juliajim.juliajim","page":"Reference","title":"juliajim.juliajim","text":"The main juliajim module\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.HARMONIC","page":"Reference","title":"juliajim.HARMONIC","text":"Useful routines for Harmonic Balance. Also includes Chebyshev Galerkin utilites.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.HARMONIC.ACT-NTuple{4, Any}","page":"Reference","title":"juliajim.HARMONIC.ACT","text":"ACT(yin, h::hTypes, N::Int64, dir::Symbol)\n\nRoutine for the alternating Chebyshev Transform. Uses AFT internally. \n\nArguments\n\nyin              : \nh::hTypes : \nN::Int64         : \ndir::Symbol      : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.AFT-NTuple{4, Any}","page":"Reference","title":"juliajim.HARMONIC.AFT","text":"AFT(yin, h::hTypes, N::Int64, dir::Symbol);\n\nRoutine to conduct Time-to-Frequency and Frequency-to-Time transforms for the general Multi frequency case.\n\nArguments\n\nyin::VecOrMat{Float64}: (N^C, Ny) if time data, and (Nhc, Ny) if frequency data.\nh::hTypes: (Nh, C) list of harmonics.\nN::Int64: Number of time samples for AFT.\ndir::Symbol: :t2f for time-to-frequency, and :f2t for frequency-to-time.\n\nExamples\n\nSingle Frequency Case:\n\n    N = 8;\n    t = (0:N-1)*2π/N;\n    yt = cos.(t) + 3sin.(2t) .+ 4;\n    yt = [yt yt];\n\n    h = collect(0:3)[:,:];\n    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\n    yf = AFT(yt, h, N, :t2f);\n    YT = AFT(yf, h, N, :f2t);\n\n2-Frequency Case:\n\n    t1 = repeat(t, 1, N);\n    t2 = repeat(t', N, 1);\n\n    yt = cos.(t1) + 3sin.(t2) .+ 4;\n    h = [0 0;1 0;0 1;1 1];\n    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\n    yf = AFT([yt[:] yt[:]], h, N, :t2f);\n    YT = AFT(yf, h, N, :f2t);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.DCHEB-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.HARMONIC.DCHEB","text":"DCHEB(h::hTypes)\n\nReturns the Chebyshev Differentiation matrix.\n\nArguments\n\nh::hTypes : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.DFOUR","page":"Reference","title":"juliajim.HARMONIC.DFOUR","text":"DFOUR(h::hTypes, ws=nothing)\n\nReturns the Fourier differentiation matrix (useful for HB representations).\n\nArguments\n\nh::hTypes : (H, C) Harmonic indices\nws::Array{Float64} : (C, 1) (optional) list of frequencies\n\nOutputs\n\nD : (Nhc, Nhc) Harmonic differentiation matrix\ndDdw : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.DFOUR!","page":"Reference","title":"juliajim.HARMONIC.DFOUR!","text":"DFOUR!(h::hTypes, D, dDdw=nothing, ws=nothing)\n\nBang version of DFOUR.\n\nArguments\n\nh::hTypes : (H, C) Harmonic indices\nD : (Nhc, Nhc) Harmonic differentiation matrix\ndDdw : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).\nws::Array{Float64} : (C, 1) (optional) list of frequencies\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.FSEVAL","page":"Reference","title":"juliajim.HARMONIC.FSEVAL","text":"FSEVAL(h::hTypes, t::Union{StepRangeLen{Float64}, VecOrMat{Float64}}, U::Union{Nothing,Matrix{Float64}}=nothing)\n\nDescription\n\nEvaluates the Fourier series at required time points. If Fourier coefficients are not provided, it returns the mapping matrix.\n\nArguments\n\nh::hTypes                      : \nt::Union{StepRangeLen{Float64} : \nVecOrMat{Float64}}             : \nU::Union{Nothing               : \nMatrix{Float64}}               : (default nothing)\n\nOutputs\n\nut\t: In case U is provided, this is outputted first.\nJ\t: The mapping matrix such that J*U gives the desired temporal evaluates.\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.HARMONICSTIFFNESS!-NTuple{7, Any}","page":"Reference","title":"juliajim.HARMONIC.HARMONICSTIFFNESS!","text":"HARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h)\n\nBang version of HARMONICSTIFFNESS (preallocate E, dEdw).\nAdvantage is that nothing can be passed to avoid needless computations.\n\nArguments\n\nE: (NdNhc, NdNhc) Harmonic Stiffness\ndEdw: C-Vector of (NdNhc, NdNhc) Representing Frequency-gradients of E\n'M, D, K': (Nd,Nd) Mass, Damping, Stiffness Matrices.\n'ws::Array{Float64}': (C,1) list of frequencies\n'h': (H, C) harmonic indices\n\nExamples\n\nSingle Frequency Case\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nh = [0;1;2;3];\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nE = zeros(2*Nhc, 2*Nhc);\ndEdw = zeros(2*Nhc, 2*Nhc);\nws = 1;\nHARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);\n\n2-Frequency Case\n\nNhmax = 3;\nws = [1; π];\nh = HSEL(Nhmax, ws);\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nE = zeros(2*Nhc, 2*Nhc);\ndEdw = zeros(2*Nhc, 2*Nhc);\nHARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HARMONICSTIFFNESS-NTuple{5, Any}","page":"Reference","title":"juliajim.HARMONIC.HARMONICSTIFFNESS","text":"HARMONICSTIFFNESS(M, D, K, ws::Array{Float64}, h)\n\nComputes the harmonic stiffness for HB simulations.\n\nArguments\n\n'M, D, K': (Nd,Nd) Mass, Damping, Stiffness Matrices.\n'ws::Array{Float64}': (C,1) list of frequencies\n'h': (H, C) harmonic indices\n\nOutputs\n\nE: (NdNhc, NdNhc) Harmonic Stiffness\ndEdw: C-Vector of (NdNhc, NdNhc) Representing Frequency-gradients of E\n\nExamples\n\nSingle Frequency Case\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nh = [0;1;2;3];\nws = 1;\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\n\n2-Frequency Case\n\nNhmax = 3;\nws = [1; π];\nh = HSEL(Nhmax, ws);\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.HARMONIC.HINDS","text":"HINDS(Ndofs::Int64, h::hTypes)\n\nArguments\n\nNdofs::Int64     : \nh::hTypes :\n\nOutputs\n\nzinds\nhinds\nrinds0\nrinds\niinds\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HSEL","page":"Reference","title":"juliajim.HARMONIC.HSEL","text":"HSEL(Nhmax::Int64, ws::Any=1, hcr::Int=1)\n\nSelection of Harmonic indices based on different criteria. First C+1 rows are [zeros(1,C); I(C)].\n\nImplemented criteria are,\n\nhcr=1: Σᵢ |hᵢ| < Nhmax & ∑ᵢ h_i ≥ 0\n\nArguments\n\nNhmax::Int64: Max harmonic for truncation.\nws=1: [opt] List of frequencies\nhcr::Int=1: [opt] Truncation criterion. See above.\n\nExamples\n\nC = 2;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.NHC-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.HARMONIC.NHC","text":"NHC(h::hTypes)\n\nReturns the number of harmonics in a chosen harmonic set h. \n\nArguments\n\nh::hTypes : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.PRODMAT_CHEB","page":"Reference","title":"juliajim.HARMONIC.PRODMAT_CHEB","text":"Description\n\nArguments\n\nU    : \nh    : \nHmax : (default nothing)\nD    : (default nonothing)\nL    : (default nonothing)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.PRODMAT_FOUR","page":"Reference","title":"juliajim.HARMONIC.PRODMAT_FOUR","text":"PRODMAT_FOUR(U::VecOrMat{Float64}, h::hTypes, Hmax=nothing, D=nothing, L=nothing)\n\nDescription\n\nReturns the Fourier product matrix. Currently only implemented for C=1.\n\nArguments\n\nU::VecOrMat{Float64}\t\t: \nh::hTypes    \t\t\t: \nHmax \t\t\t\t: (default nothing)\nD    \t\t\t\t: (default nothing)\nLb   \t\t\t\t: (default nothing)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.CONTINUATION","page":"Reference","title":"juliajim.CONTINUATION","text":"Useful types and routines for numerical continuation.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.CONTINUATION.myNLSoln","page":"Reference","title":"juliajim.CONTINUATION.myNLSoln","text":"myNLSoln(up::nvTypes=nothing; J::nmTypes=nothing, Jp::nvTypes=nothing)\n\nConstructor for myNLSoln. Can specify one or all the arguments (point, jacobian, paramjac).\n\nArguments\n\nup::nvTypes       : (default nothing) Solution point\nJ::nmTypes        : (default nothing) Jacobian\nJp::nvTypes       : (default nothing) paramjac\nsave_jacs::Bool   : (default false) Whether or not to store the Jacobians.\n\nIf both J and Jp are provided, the unit tangent dupds is computed using nullspace([J Jp])[:,1].\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.CONTINUATION.myNLSoln-2","page":"Reference","title":"juliajim.CONTINUATION.myNLSoln","text":"myNLSoln\n\nStruct storing the solution, Jacobian, and (unit) tangent.\n\nFields\n\nup::nvTypes: Solution point ([u;p])\nJ::nmTypes: Jacobian dr/du\nJp::nvTypes: Parameter Jacobian dr/dp\ndupds::nvTypes: Tangent vector (has to be vector only)  \n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:--Tuple{myNLSoln, myNLSoln}","page":"Reference","title":"Base.:-","text":"Base.:-(v1::myNLSoln, v2::myNLSoln)\n\nOverloading the subtraction operator to take the difference between two myNLSoln \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getproperty-Tuple{Vector{myNLSoln}, Symbol}","page":"Reference","title":"Base.getproperty","text":"Base.getproperty(sols::Vector{myNLSoln}, sym::Symbol)\n\nThis will allow accessing elements of myNLSoln from vectors of structs.\n\nArguments\n\nsols::Vector{myNLSoln} : \nsym::Symbol            : \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.getproperty-Tuple{myNLSoln, Symbol}","page":"Reference","title":"Base.getproperty","text":"Base.getproperty(sol::myNLSoln, sym::Symbol)\n\nThis will allow accessing the solution (u) and parameter (p) from myNLSoln easily\n\nArguments\n\nsol::myNLSoln : \nsym::Symbol   : \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, myNLSoln}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, p::myNLSoln)\n\nOverloading base show function to display myNLSoln object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.CONTINUATION.CONTINUATE-Tuple{Vector{Float64}, Any, Vector{Float64}, Float64}","page":"Reference","title":"juliajim.CONTINUATION.CONTINUATE","text":"CONTINUATE(u0, fun, ps, dp; pkwargs...)\n\nContinuation routine. Solves the bordered problem with residue drawn from EXTRESFUN!.\n\nArguments\n\nu0::Vector{Float64}                          : Initial guess for first point\nfun                                          : NonlinearFunction object. Will call:\nfun.f(du, u, p) for residue r. p must be scalar.\nfun.jac(J, u, p) for jacobian dr/du. Uses ForwardDiff.jacobian! if fun.jac is nothing.\nfun.paramjac(Jp, u, p) for jacobian dr/dp. Uses ForwardDiff.jacobian! if fun.paramjac is nothing.\nps::Vector{Float64}                          : Specify range of p for continuation.\ndp::Float64                                  : Specify first step in Δp units. (will be rescaled if necessary)\n\nOptional Arguments\n\nparm::Symbol                                 : (default :arclength) Arclength parameterization. See EXTRESFUN!.\nnmax::Int64                                  : (default 1000) Maximum number of steps.\ndpbnds::Union{Nothing,Vector{Float64}}       : (default [dp/5,5dp]) Bounds for the step length dp. (Rescaled as appropriate)\nsave_jacs::Bool                              : (default false) Specify whether or not to save the Jacobians in the output. Only solution and (unit) tangent are saved if false.\nverbosity::Int                               : (default 1) Verbosity levels:\n0: Suppress all messages.\n1: Display Steps, Continuation Progress.\n2: Display Iteration Information for each step also.\n\nFor Scaling of Unknowns (recommended to get evenly spaced points on response curve)\n\nDsc::Union{Symbol,Nothing,Vector{Float64}}   : (default :none) \"Dscaling\" used to scale the unknowns. The arc length constraint is applied in the scaled space (uₛ=uₚₕ./Dsc).\nIf set to :auto, it uses the absolute of the first converged solution as the initial Dsc vector. Zero entries are replaced with minDsc.\nIf set to :none, it fixes Dsc to a vector of ones and doesn't dynamically adapt it. (this forces DynScale to false).\nIf set to :ones, it fixes Dsc to a vector of ones but dynamically continues to scale.\nDynScale::Bool                               : (default true) Whether or not to dynamically adapt the Dsc vector. Each entry is allowed to grow or shrink by a maximum factor of 2 in each step if true.\nminDsc::Float64                              : (default eps()^(4//5)=3e-13) Minimum value for Dscale.\nndxi::Float64\t\t\t\t : (default 0.5) Dscale update exponent.\n\nFor Step Length Adaptation. Currently set as dsₙ = dsₒ * xi, where xi = clamp((itopt/itns)^nxi, xirange[1], xirange[2]).\n\nitopt::Union{Symbol,Int}                     : (default :auto) Optimal number of iterations\nangopt::Float64\t\t\t\t : (default deg2rad(20)) Optimal angle change per unit (scaled) arc-length.\nnxi::Float64                                 : (default 0.5) Step length adaptation rate.\n\nFor the Solvers\n\nmaxiters::Int\t\t\t\t : (default 100) Maximum number of iterations that NonlinearSolve must attempt.\npkwargs\t\t\t\t\t : (default (;abstol=1e-6, reltol=1e-6)) Parameters to be passed to NonlinearProblem.\n\nReturns\n\nvector{myNLsoln} representing solutions.\nvector{Int} representing iterations taken.\nvector{Float64} representing step sizes.\nvector{Float64} representing adaptation parameter ξ.\nvector{Float64} representing the final Dscale matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.CONTINUATION.EXTRESFUN!-NTuple{4, Any}","page":"Reference","title":"juliajim.CONTINUATION.EXTRESFUN!","text":"EXTRESFUN!(up::nvTypes, fun, sol0::myNLSoln, ds::Float64; parm::Symbol=:riks, Dsc::Vector{Float64}, dup::nvTypes=nothing, Jf::nmTypes=nothing)\n\nReturns the bordered/extended residue function. Appends residue with required arclength constraint.\n\nNote\n\nThe function involves very naive autodiff calls. Does not respect or try to detect jacobian sparsity. For now it is best to provide analytical jacobians for very large problems. \n\nArguments\n\nup::nvTypes: Solution point for evaluation\nfun: Nonlinear function specified in a fashion that can be called as\nfun.f(du,up[1:end-1],up[end]) for the residue.\nfun.jac(J,up[1:end-1],up[end]) for the jacobian (uses ForwardDiff.jacobian! if fun.jac is nothing)\nfun.paramjac(Jp,up[1:end-1],up[end]) for the parameter jacobian (uses ForwardDiff.jacobian! if fun.paramjac is nothing)\nDevelopment Done based on NonlinearFunction from NonlinearSolve\nsol0::myNLSoln: Previous solution point.\nds::Float64: Step size.\nparm::Symbol=:riks: Arclength parameterization. Defaults to :riks. Possible are:\n:riks: Riks' or normal parameterization.\n:arclength: Arclength parameterization.\nDsc::Vector{Float64}: Scaling vector. Recommended to be of the order of magnitude of the expected unknowns. Size same as up.\ndup::nvTypes=nothing: Residue vector (for iip evaluation)\nJf::nmTypes=nothing: Jacobian matrix (for iip evaluation)\n\nReturns\n\ndup::nvTypes=nothing: Residue vector (for iip evaluation)\nJf::nmTypes=nothing: Jacobian matrix (for iip evaluation)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS","page":"Reference","title":"juliajim.MDOFUTILS","text":"Useful types and routines for dynamic analyses of MDOF problems.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.MDOFUTILS.MDOFGEN","page":"Reference","title":"juliajim.MDOFUTILS.MDOFGEN","text":"MDOFGEN\n\nStruct storing the generic MDOF system.\n\nFields\n\nM::Matrix{Float64}: Mass matrix\nC::Matrix{Float64}: Damping Matrix\nK::Matrix{Float64}: Stiffness Matrix\nL: Displacement Transform Matrix (can be empty)\nNdofs::Int64: Number of DOFs\nNLTs::Vector{NONLINEARITY}: Vector of nonlinearities present (see NONLINEARITY)\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.MDOFUTILS.NONLINEARITY","page":"Reference","title":"juliajim.MDOFUTILS.NONLINEARITY","text":"NONLINEARITY\n\nStruct storing a nonlinearity.\n\nFields\n\ntype::Symbol: Type of nonlinearity. One of:\n:Inst (for instantaneous nonlinearity)\n:Hyst (for hysteretic nonlinearity)\n:Fdom (for nonlinearity defined in frequency domain)\nOut of these, only the first 2 can be used for transient simulations.\nfunc::Function: Function handle for evaluating nonlinearity. Has signature\n(t, u, udot) for :Inst\n(t, u, up, sp) for :Hyst, where s is some internal state (sp is s at t-Δt)\nL::Matrix{Float64}: Selection Matrix\nLf: Force shape matrix (can be empty)\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.MDOFUTILS.ADDNL","page":"Reference","title":"juliajim.MDOFUTILS.ADDNL","text":"Description\n\nAdd a nonlinearity to the MDOFGEN object.\n\nArguments\n\nm::MDOFGEN     : MDOFGEN object\ntype::Symbol   : One of :Inst (Instantaneous nonlinearity), :Hyst (Hysteretic nonlinearity), :Fdom (Frequency Domain nonlinearity), :Dla (Dynamic Lagrangian)\nfunc::Function : Nonlinearity function returning the nonlinear force. Different signatures for different types:\n:Inst : (t,u,ud) returning (f, dfdu, dfdud)\n:Hyst : (t,u,uprev,fprev) returning (f, dfdu, dfduprev, dfdfprev)\n:Fdom : (Unl, h, N) returning (F, dFdU, dFdw)\n:Dlag : Not implemented yet\nL              : \nLf             : (default nothing)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.MDOFUTILS.DEFLATEDRES!-Tuple{Any, Any, Any}","page":"Reference","title":"juliajim.MDOFUTILS.DEFLATEDRES!","text":"Description\n\nArguments\n\nU  : \nU0 : Vector{Float64} or Vector{Vector{Float64}}\nresfun!     : function!(u, Res, Jac, Jacp)\nR  : (default nothing)\nJ  : (default nothing)\nJp : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.EPMCRESFUN!-Tuple{Any, MDOFGEN, Any, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.EPMCRESFUN!","text":"Description\n\nArguments\n\nUwxa                : \nm::MDOFGEN          :\nFl                  : (Nd*Nhc) Forcing vector. Zero harmonics are used as static loads. Harmonic portions are used to provide phase constraint.\nh                   : \nN::Int64            : \ntol::Float64        : (default eps()^(4//5))\natype::Symbol       : (default :H1)\nashape::Union{Int64 : \nVector{Float64}}    : (default 1)\nR                   : (default nothing)\ndRdUwx              : (default nothing)\ndRda                : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.HBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.HBRESFUN!","text":"Description\n\nResidue function that can be used for Harmonic Balance forced response analysis.\n\nArguments\n\nUw   : \nm    : \nFl   : \nh    : \nN    : \ntol  : \ndRdU : \ndRdw : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.HBRESFUN_A!-Tuple{Any, MDOFGEN, Float64, Any, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.HBRESFUN_A!","text":"Description\n\nHB residue with amplitude constraint.\n\nArguments\n\nUfw           : \nm::MDOFGEN    : \nA::Float64    : Amplitude level (also see atype below)\nFl            : \nh             : \nN::Int64      :\natype::Symbol : (default :H1) One of :H1, :RMS. Type of amplitude measure.\nashape        : (default 1) Shape to dof for applying amplitude. If Integer, interpreted as Dof. If vector, taken as shape.\ntol::Float64  : (default eps()^(4//5))\nR             : (default nothing)\ndRdUf         : (default nothing)\ndRdw          : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NEWMARKMARCH-Tuple{MDOFGEN, Vararg{Any, 6}}","page":"Reference","title":"juliajim.MDOFUTILS.NEWMARKMARCH","text":"Description\n\nArguments\n\nm::MDOFGEN : \nT0         : \nT1         : \ndt         : \nU0         : \nUd0        : \nFex        : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NLEVAL!-Tuple{Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, MDOFGEN, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.NLEVAL!","text":"Description\n\nEvaluate the nonlinearities (and Jacobian) for one period and return the harmonics\n\nArguments\n\nUw         : \nm::MDOFGEN :\nh          :\nN::Int64   : [optional]\ntol        :   \nFNL        : \ndFNLdU     : \ndFNLdw     : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NLFORCE-Tuple{MDOFGEN, Any, Any, Any}","page":"Reference","title":"juliajim.MDOFUTILS.NLFORCE","text":"Description\n\nEvaluate the nonlinearities in the time domain for a single time instant.\n\nArguments\n\nm::MDOFGEN : MDOFGEN object.\nt          : Time\nU          : (m.Ndofs) Displacements\nUd         : (m.Ndofs) Velocities\ntp         : (default nothing) Previous instant time\nUp         : (default nothing) (m.Ndofs) Displacements at previous instant.\nUdp        : (default nothing) (m.Ndofs) Velocities at previous instant.\nSp         : (default nothing) (length(m.NLTs)) Vector of vectors of internal states at previous instant. Each nonlinearity can have its own set of internal states.\n\nReturns\n\nF\t: (m.Ndofs) force vector\ndFdU\t: (m.Ndofs, m.Ndofs) force-displacement derivative matrix\ndFdUd\t: (m.Ndofs, m.Ndofs) force-velocity derivative matrix\nS\t: (length(m.NLTs)) vector of vectors of internal states\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.QPHBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.QPHBRESFUN!","text":"Returns the quasi periodic forced response residue. Also allows for specifying a constrained form. If provided, the matrix cL and vector cLb are interpreted such that the unknown vector gets written as U = ^cL Û + ^cL_b where Û is of size (D Nhc+C,1), containing the frequencies also in the end.\n\nThe matrix {}^cL is used to project the residue vector {}^cL^T R. By choosing its size appropriately, one can make the system square.\n\nThe last element in U is always interpreted as the continuation parameter.\n\nArguments\n\nUw               : \nm::MDOFGEN       : \nFl::Union{Vector : \nMatrix           : \nSparseMatrixCSC  : \nNothing}         : \nh                : \nN::Int64         : \ntol::Float64     : (default eps()^(4//5))\nR                : (default nothing)\ndRdU             : (default nothing)\ndRdw             : (default nothing)\ncL               : (default nothing)\ncLb              : (default nothing)\nU0               : (default nothing) Solution to deflate from. 2-norm is used for deflation.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.NLDYN","page":"Reference","title":"juliajim.NLDYN","text":"Some routines for Nonlinear Dynamics.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.NLDYN.NORMALFORMFIT-Tuple{Any, Any, Any}","page":"Reference","title":"juliajim.NLDYN.NORMALFORMFIT","text":"Description\n\nNORMALFORMFIT fits a quadratic normal form to the given residue function (in R2) numerically. It starts with a cloud of randomly distributed points with given amplitude standard deviation and fits a general cubic model such that the dynamics may be approximated as:        xdot = A x + B x x + C x x x .   Then the quadratic terms are eliminated by posing a near identity transformation from x to z as \tx = z + H z z .   The simplified normal form equations in terms of z are \tzdot = A z + C3 z z z .\n\nA good reference for this is sec. 19.10 in Wiggins (1990).   \n\nArguments\n\nxyfun       : (xy) Taking in a 2-vector and returning a 2-residue vector.\n\n\tMust have equilibrium at origin.\n\ndamp       : If scalar, standard deviation for amplitude.               If vector, [dmin, d_max] for the amplitude.\nNpts        : Number of points to be used for fit.\nconstrained : (default true)\n\nOutputs\n\nA           : (2,2) The linear Jacobian matrix.\nB2n         : (2,3) The quadratic coefficient matrix such that                     the nonlinear influence is written as                        B2[z1^2; z1z2; z2^2]\nC3n         : (2,4) The cubic coefficient matrix such that the                     nonlinear influence is written as                        C3[z1^3; z1^2z2; z1*z2^2; z2^3].\nHn          : (2,3) The cubic near identity transformation                     matrix such that the near identity                     transformation can be written as                        x = z + Hn [z1^2; z1*z2; z2^2]\nC3          : (2,2,2,2) The cubic coefficient matrix in tensor                         form.\nH           : (2,2,2) The quadratic near identity                       transformation coefficients in tensor form.\n\n\n\n\n\n","category":"method"},{"location":"c4_mdofgen_epmc/#ex_c4","page":"4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC","title":"Example C4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using the Extended Periodic Motion Concept","text":"note: The Extended Periodic Motion Concept\nNonlinear normal modes is a very succinct methodology for describing the dynamics of nonlinear systems. It leads to descriptions of the dynamics in terms of amplitude-dependent natural frequency, daming factor, and mode-shapes for each mode. The Extended Periodic Motion Concept is a very popular methodology for capturing these numerically. The idea here is simple - it iteratively looks for what would be a linear self excitation (in terms of a negative viscous factor) that must be supplied to a system so that it has a periodic solution as an invariant set in its unforced state.Mathematically the system we will be solving is:mxM ddotvcu + mxC dotvcu + mxK vcu + vcf_nl = xi mxM dotvcuwhere xi controls the strength of the self-excitation. Since the system is always solved by the trivial solution, an amplitude constraint is often imposed. In order to simplify calculations later on, the first harmonic amplitude of the degrees of freedom is constrained as:vcU_c1^T mxM vcU_c1 + vcU_s1^T mxM vcU_s1 = a^2where vcU_c1 = fracOmegapi int_0^2piOmega vcu cosOmega t dt and vcU_s1 = fracOmegapi int_0^2piOmega vcu sinOmega t dt. (a) is the user-specified amplitude, which serves as the continuation parameter in this context. In addition to this, there is still a phase indeterminacy present in the system. So we choose an arbitrary DoF (which is expected to be non-zero in the mode under consideration), and set its cosine harmonic to be zero (other constraints are also possible). With this, we will have a square system (same number of unknowns as equations) and it can be solved to obtain the amplitude-dependent nonlinear modal characteristics of the system.\n\nThe EPMCRESFUN! routine in MDOFUTILS implements the residue function for EPMC that can be used in tandem with CONTINUATION to obtain nonlinear modal characteristics. This example will illustrate this on the frictional 2DoF oscillator under consideration in Examples C2 and C3. The steps followed are:\n\nFirst the system is setup (along with the nonlinearity, see descriptions in Example C2.\nNext we conduct linear modal analysis on the linearized system. This is important to set the initial guess for the EPMC run next.\nNow we setup the Harmonic Balance parameters and then test out the EPMC residue routine using the linearized modes estimated above.\nFinally we conduct the contuation over the modal amplitude (a) and then visualize the results.","category":"section"},{"location":"c4_mdofgen_epmc/#Preamble:-Load-Packages","page":"4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC","title":"Preamble: Load Packages","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing ForwardDiff\nusing NonlinearSolve\nusing DSP\n\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION\nusing juliajim.MDOFUTILS","category":"section"},{"location":"c4_mdofgen_epmc/#exc4_setup","page":"4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC","title":"System Setup","text":"MCK matrices and nonlinearity setup: identical to Example C2.\n\nM = collect(1.0I(2));\nK = [2. -1.;-1. 2.];\nC = 0.01*M+0.001*K;\n\nmdl = MDOFGEN(M, C, K);\n\n# Nonlinearity\nkt = 1.0;\nfs = 1.0;\nfnl = (t,u,up,fp)-> if all(abs.(fp+kt*(u-up)).<fs)\n    return fp+kt*(u-up), kt*ones(size(u)), -kt*ones(size(u)), ones(size(u)); else\n        return fs*sign.(fp+kt*(u-up)), zeros(size(u)), zeros(size(u)), zeros(size(u));\nend\nL = [0.0 1.0];\n\nmdl = ADDNL(mdl, :Hyst, fnl, L);\nnothing #hide","category":"section"},{"location":"c4_mdofgen_epmc/#exc4_linmodal","page":"4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC","title":"Linear Modal Analysis","text":"Remember that in the limit of small amplitude, the Jenkins element acts like a linear spring. So we add this additional stiffness to the linearized stiffness matrix and conduct the modal analysis (eigen decomposition). The mode shapes, natural frequencies, and damping are saved since these will be used next as the initial guess for EPMC.\n\nKnl0 = L'kt*L;\nK0 = mdl.K+Knl0;\nD, V = eigen(K0, mdl.M)\nW0s = sqrt.(D);\nXis = diag(V'mdl.C*V)\n\nmi = 1;  # Mode of interest\nnothing #hide","category":"section"},{"location":"c4_mdofgen_epmc/#exc4_hbsetup","page":"4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC","title":"Setup HB","text":"Setting up parameters for Harmonic Balance: identical to Example C2.\n\nh = 0:5;\nN = 256;\nt = (0:N-1)*2π/N;\n\nNhc = sum(all(h.==0, dims=2) + 2any(h.!=0, dims=2));\n\n_, _, zinds, rinds, iinds = HINDS(mdl.Ndofs, h)\nFl = zeros(Nhc*mdl.Ndofs);\nFl[rinds[1]] = 1.0;\n\nE, dEdw = HARMONICSTIFFNESS(mdl.M, mdl.C, mdl.K, W0s[mi], h);\n\nU0 = zeros(mdl.Ndofs*Nhc);\nU0[iinds[1:mdl.Ndofs]] = V[:, mi];\nnothing #hide","category":"section"},{"location":"c4_mdofgen_epmc/#exc4_epmcres","page":"4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC","title":"Test EPMC Residue","text":"The ordering of unknowns that will be sent to the EPMCRESFUN! routine is (\\begin{bmatrix} \\vc{u}^T&\\omega&\\xi&\\log_{10}(a) \\end{bmatrix}^T), where the last parameter is the log of the amplitude (base 10). The log-scaling is done on the amplitude to help with numerical conditioning issues.\n\nIn the following we setup everything and test it to ensure that the residue can be used to converge to the solution.\n\nR = zeros(mdl.Ndofs*Nhc+2);\ndRdU = zeros(mdl.Ndofs*Nhc+2, mdl.Ndofs*Nhc+2);\ndRda = zeros(mdl.Ndofs*Nhc+2);\n\nEPMCRESFUN!([U0; W0s[mi]; Xis[mi]; -2], mdl, Fl, h, N; R=R, dRdUwx=dRdU, dRda=dRda)\n\nA0 = -2.0;\n\nU0 = zeros(mdl.Ndofs*Nhc);\nU0[iinds[1:mdl.Ndofs]] = V[:, mi];\n\nfun = NonlinearFunction((r,uwx,p)->EPMCRESFUN!([uwx;p], mdl, Fl, h, N; R=r),\n    jac=(J,uwx,p)->EPMCRESFUN!([uwx;p], mdl, Fl, h, N; dRdUwx=J),\n    paramjac=(Jp,uwx,p)->EPMCRESFUN!([uwx;p], mdl, Fl, h, N; dRda=Jp));\n\nprob = NonlinearProblem(fun, [U0;W0s[mi];Xis[mi]], A0);\nsol = solve(prob, show_trace=Val(true), maxiters=100);\nnothing #hide","category":"section"},{"location":"c4_mdofgen_epmc/#exc4_cont","page":"4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC","title":"Continuation","text":"Now we are ready to conduct continuation to obtain the amplitude dependent resonance backbone for the system. The invocation of CONTINUATE is exactly as encountered in the earlier examples.\n\nA0 = -1.;\nA1 = 3.;\nda = 0.05;\ncpars = (parm=:arclength, nmax=1000, Dsc=:none, itopt=4, dpbnds=[da/5, 2da]);\n\nda = 0.02;\ncpars = (nmax=1000, Dsc=:auto, angopt=deg2rad(10));\n\nsols, its, dss, xis, Dsc = CONTINUATE([U0;W0s[mi];Xis[mi]], fun, [A0, A1], da; cpars...);\n\nuh = zeros(Complex, maximum(h)+1, length(sols), 2);\nfor i in 1:2\n    uh[h.+1, :, i] = hcat([[s.up[zinds[i:2:end]];\n                            s.up[rinds[i:2:end]]+1im*s.up[iinds[i:2:end]]]\n                          for s in sols]...);\nend\nOms = [s.up[end-2] for s in sols];\nZts = [s.up[end-1] for s in sols]./2Oms;\nAs = [10^s.up[end] for s in sols];\nnothing #hide","category":"section"},{"location":"c4_mdofgen_epmc/#exc4_plot","page":"4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC","title":"Plotting","text":"Finally we visualize the results in terms of harmonics as well as in terms of natural frequency and (equivalent) damping factor characteristic curves.\n\nhis = [1, 3, 5];\n\nset_theme!(theme_latexfonts());\nfsz = 20;\nfig = Figure(fontsize=fsz, size=(1000, 600));\n\naxs = [];\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i],\n        ylabel=L\"$H_%$(his[i])$ Response (m)\", xscale=log10, yscale=log10);\n    scatterlines!(ax, As, abs.(uh[his[i].+1, :, 1]), label=\"x1\");\n    scatterlines!(ax, As, abs.(uh[his[i].+1, :, 2]), label=\"x2\");\n    push!(axs, ax)\n\n    ax = Axis(fig[2, i], xlabel=L\"Modal Amplitude $a$\",\n        ylabel=L\"$H_%$(his[i])$ Phase (rad)\", xscale=log10);\n    scatterlines!(ax, As, unwrap(angle.(uh[his[i].+1, :, 1])), label=\"x1\");\n    scatterlines!(ax, As, unwrap(angle.(uh[his[i].+1, :, 2])), label=\"x2\");\n    push!(axs, ax)\n    if i==1\n        axislegend(ax)\n    end\nend\nax = Axis(fig[1, length(his)+1],\n    ylabel=L\"Natural Frequency $\\omega_n$ (rad/s)\", xscale=log10);\nscatterlines!(ax, As, Oms);\npush!(axs, ax)\n\nax = Axis(fig[2, length(his)+1], xlabel=L\"Modal Amplitude $a$\",\n    ylabel=\"Damping Factor (%)\", xscale=log10);\nscatterlines!(ax, As, 100Zts);\npush!(axs, ax)\n\nlinkxaxes!(axs...)\n\n    fig\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"b1_duffhb/#ex_b1","page":"1: Duffing Oscillator","title":"Example B1: Numerical Continuation on a Duffing Oscillator","text":"This example exposes the core functionality of juliajim.CONTINUATION through a very minimal example. The governing equations for the oscillator are taken as\n\nddotx + 2zeta_0omega_0 dotx + omega_0^2 x + alpha x^3 = FcosOmega t\n\nThe steps that will be followed in this file are as follows:\n\nFirst we define a \"harmonic residue\" function for the Duffing oscillator in a way that returns the residue, its Jacobian with respect to the vector of harmonics (see Example a), and also with respect to the excitation frequency.\nNext we define the parameters for the problem and setup the necessary variables for the Harmonic Balance (and AFT).\nThen we conduct the actual continuation after setting up parameters for this.\nFinally the results are plotted in terms of the different harmonics present.","category":"section"},{"location":"b1_duffhb/#Preamble:-Load-packages","page":"1: Duffing Oscillator","title":"Preamble: Load packages","text":"using GLMakie\nusing LaTeXStrings\nusing LinearAlgebra\nusing NonlinearSolve\nusing ForwardDiff\nusing DSP\n\nusing juliajim.HARMONIC\nusing juliajim.CONTINUATION","category":"section"},{"location":"b1_duffhb/#exb1_res","page":"1: Duffing Oscillator","title":"Define Residue Function","text":"We setup the Harmonic Balance residue function such that it takes as input the list of harmonics and the excitation frequency as a single vector. This is convenient for bordered continuation strategies.\n\nThe computation of the residue itself is as follows:\n\nEstimate the linear harmonic stiffness\nTransform the given harmonic coefficients into the time domain (for one cycle) using AFT, and use that to compute the nonlinearity in one oscillation cycle.\nTransform the computed force into the Frequency domain by computing its harmonics using AFT.\nAssemble the overall harmonic balance equation.\n\nJacobian computations also follow similar steps. The function is implemented \"in-place\" in order to be efficient - the Jacobian(s) are computed only when requested.\n\nfunction RESFUN!(Uw, Fl, pars, h, Nt; R=nothing, dRdU=nothing, dRdw=nothing)\n    (; z0, w0, al, F) = pars;\n\n    Om = Uw[end];\n    Nhc = sum((h.==0)+2(h.!=0));\n\n    # Linear Portion\n    E, dEdw = HARMONICSTIFFNESS(1.0, 2z0*w0, w0^2, Om, h);\n\n    # AFT For nonlinear force\n    ut  = AFT(Uw[1:end-1], h, Nt, :f2t);\n\n    # Construct Residue\n    if !(R === nothing)\n        ft  = al*ut.^3;\n        Fnl = AFT(ft, h, Nt, :t2f);\n\n        R[:] = E*Uw[1:end-1] + Fnl - Fl*F;\n    end\n    if !(dRdU === nothing)\n        cst = AFT(Float64.(I(Nhc)), h, Nt, :f2t);\n        dfdat = (3al*ut.^2) .* cst;\n        Jnl    = AFT(dfdat, h, Nt, :t2f);\n\n        dRdU[:, :] = E + Jnl;\n    end\n    if !(dRdw === nothing)\n        dRdw[:] = dEdw*Uw[1:end-1];\n    end\n    return nothing;\nend","category":"section"},{"location":"b1_duffhb/#exb1_setup","page":"1: Duffing Oscillator","title":"Setup","text":"We now setup the parameters of the system and forcing vector for Harmonic balance.\n\n  ξ = 1e0;  # Scaling fudge factor - change to test the robustness of the continuation\npars = (z0 = 0.5e-2, w0 = 2., al = 0.1*ξ^2, F = 0.1/ξ);\n\nh = (0:5);  # Choose list of harmonics\n# h = 1:2:5;  # Also possible\nOm = 0.1;\n\nNhc = sum((h.==0)+2(h.!=0));\nNt = 2^9;\n\nFl = zeros(Nhc);\n_,_,zinds,rinds,iinds = HINDS(1, h)\nFl[rinds[1]] = 1.0;\nnothing #hide\n\nNow Fl is the harmonic forcing vector. Next, we define a NonlinearFunction object (from [NonlinearSolve.jl]) that will be used by juliajim for the continuation. Note that for this, the unknowns are the harmonics and the parameter (has to be scalar) is the excitation frequency, with which the continuation procedure will be carried out.\n\nWe also use the same RESFUN! function defined above to specify the jac (jacobian w.r.t. the unknowns) and paramjac (jacobian w.r.t. the frequency). If these are left empty, ForwardDiff will be used to estimate them.\n\nfun = NonlinearFunction((r,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;R=r),\n                        jac=(J,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdU=J),\n                        paramjac=(Jp,u,p)->RESFUN!([u;p],Fl,pars,h,Nt;dRdw=Jp));\nnothing #hide\n\nNow we are ready!","category":"section"},{"location":"b1_duffhb/#Check-by-solving-for-a-Single-point","page":"1: Duffing Oscillator","title":"Check by solving for a Single point","text":"We set the initial guess as the solution of the linearized oscillator and solve the problem using NonlinearSolve.jl. The following should work properly and converge within 3-4 iterations.\n\nE = zeros(Nhc, Nhc);\nHARMONICSTIFFNESS!(E, nothing, 1.0, 2pars.z0*pars.w0, pars.w0^2, Om, h);\nU0 = E\\ (Fl*pars.F);\n\nprob = NonlinearProblem(fun, U0, Om);\nsol = solve(prob, show_trace=Val(true));\nnothing #hide\n\nInspecting the solution would show that the solution has only odd-harmonic content, as expected from a simple system with a cubic spring:\n\nsol.u","category":"section"},{"location":"b1_duffhb/#exb1_cont","page":"1: Duffing Oscillator","title":"Continuation","text":"Now we are ready to conduct the actual continuation. First things first, we setup the starting and ending frequencies (Om0, Om1) and the starting step length dOm. In juliajim the units of the step length are always in the same units as the continuation parameter, the excitation frequency in this case.\n\nOm0 = 2pars.w0;\nOm1 = 0.02pars.w0;\ndOm = 0.1pars.w0;\ncpars = (parm=:arclength, nmax=2000);\nnothing #hide\n\nWe also set two parameters relevant for continuation (see the documentation of CONTINUATE for an exhaustive list of parameters with descriptions). Here we are specifying that we would use the arclength parameterization and will do the computation for a maximum of 2000 points. We provide the initial guess the same as before (of the linearized problem) and can reuse the same NonlinearFunction object from before.\n\nHARMONICSTIFFNESS!(E, nothing, 1.0, 2pars.z0*pars.w0, pars.w0^2, Om0, h);\nU0 = E\\ (Fl*pars.F);\n\nsols, its, dss, xis, Dsc = CONTINUATE(U0, fun, [Om0, Om1], dOm; cpars...);\nnothing #hide\n\nCONTINUATE returns, firstly, a vector of myNLSoln objects. These store the solution vector up, local tanget dupds, and any Jacobians if required.\n\nIn order to help with plotting and other postprocessing, it is sometimes helpful to express the harmonics in the complex notation. So we do that here before moving on to plotting.\n\nuh = zeros(Complex, maximum(h)+1, length(sols));\nuh[h.+1, :] = hcat([[s.up[zinds]; s.up[rinds]+1im*s.up[iinds]] for s in sols]...);\nOms = [s.up[end] for s in sols];\nnothing #hide","category":"section"},{"location":"b1_duffhb/#exb1_plot","page":"1: Duffing Oscillator","title":"Plotting","text":"Now we choose a few harmonics and plot them using GLMakie (I highly recommend Makie for interativity as well as for its rich feature-set). The output should show the primary resonance (visible in all harmonics) as well as secondary superharmonic resonances (visible in the higher harmonics).\n\nhis = [1, 3, 5];\n\nfsz = 24;\nfig = Figure(fontsize=fsz, size = (1000, 600));\n\nax1s = [];\nax2s = [];\nfor i in eachindex(his[his.<=maximum(h)])\n    ax = Axis(fig[1, i], ylabel=L\"$H_%$(his[i])$ Response (m)\", yscale=log10);\n    scatterlines!(ax, Oms, abs.(uh[his[i].+1, :]));\n    push!(ax1s, ax);\n\n    ax = Axis(fig[2, i], xlabel=L\"Excitation Frequency $\\Omega$\",\n              ylabel=L\"$H_%$(his[i])$ Phase (rad)\");\n    scatterlines!(ax, Oms, unwrap(angle.(uh[his[i].+1, :])));\n    push!(ax2s, ax);\nend\nlinkxaxes!(vcat(ax1s, ax2s)...)\n\n    fig","category":"section"},{"location":"b1_duffhb/#Outro","page":"1: Duffing Oscillator","title":"Outro","text":"This file shows how to use the routines in HARMONIC to construct a residue and then use this function with CONTINUATION to conduct numerical continuation to compute its forced response.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"examples/#Overview","page":"Overview","title":"Overview","text":"The examples are organized in an order of increasing complexity.","category":"section"},{"location":"examples/#Example-code-snippet","page":"Overview","title":"Example code snippet","text":"using juliajim.HARMONIC\n\nN = 8\nt = (0:N-1)*2pi/N;\ny = cos.(t);\nh = 0:3;\nYh = AFT(y, h,N, :t2f);","category":"section"},{"location":"#Welcome-to-the-juliajim-Documentation!","page":"Home","title":"Welcome to the juliajim Documentation!","text":"Welcome to the documentation page. \n\nnote: Why should you be interested?\nHere's my vision for the package: I would like to use a singly specified dynamical system to subject it to different types of analyses. This includes transient simulations, steady-state periodic/quasi-periodic, etc.If this is interesting to you, you may find value in the project. \n\nNote that this is still under heavy development. It is functional but the documentation needs a lot of work. Please reach out to me in case you're interested in contributing, share the vision, and have started loving Julia! :-)","category":"section"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"This is a set of Julia routines to help with computational research in nonlinear structural dynamics. Most of the content is derived from my earlier efforts (functional but badly maintained) with MATLAB/Octave at https://github.com/Nidish96/octave-jim.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"The development is not yet complete and the package is not registered either. But you can try out the package by installing it manually from Github as follows:\n\n] dev https://github.com/Nidish96/juliajim\n\nor, with Pkg\n\nusing Pkg\nPkg.develop(url=\"https://github.com/Nidish96/juliajim\")\n\nAfter this you can just do using juliajim and get cracking.","category":"section"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"Although formal documentation is highly lacking, a series of examples with progressively increasing complexity designed to expose most of the features of the toolbox are provided here. Each example is documented to a reasonable degree. Going through the examples should already help you get started on the analysis. The following is a road-map for navigating the examples:\n\nIf you're just here for the...\n\nFourier Utilities, start by looking at Example A.\nContinuation Utilities, start by looking at Examples B1 and B2.\nIntegrated nonlinear dynamics, start by looking at Examples C1-C5. Note:\nFor Harmonic Balance forced response computations, see Examples C1, C2, and C3.\nFor Harmonic Balance Extended Periodic Motion Concept (EPMC) Nonlinear Modal Analysis, see Example C4.\nFor transient simulation utilities, see Example C5, which uses a Newmark-beta implementation.\nOut of the above, all examples except Example C1 use a hysteretic nonlinearity.","category":"section"},{"location":"#Why-yet-another-package?","page":"Home","title":"Why yet another package?","text":"Each programming language/environment/specification you choose (MATLAB, Python, Julia, C/C++, etc.) has its own host of libraries that can do a lot of what juliajim sets out to do. Notable examples include Trilinos (C++) and the SciML ecosystem (Julia), which can do what juliajim sets out and (FAR!) more.\n\nMy vision for this tool is this: I'd like to be able to specify a system once and conduct different types of analysis on it. This mainly includes nonlinear static solves, transient time-marching (also shooting for periodic solutions), harmonic balance (for periodic and quasi periodic solutions), and variants therein (potentially more).\n\nAlthough a lot of the existing tools come very close to acheiving this, they don't span nearly all the kinds of nonlinearities. For instance, it is presently quite non-trivial to use any existing code as is for simulating systems with something as simple as an elastic dry-friction element (a hysteretically saturated linear spring).\n\nFurthermore, very few tools provide a lot of convenience for harmonic balance simulations. A notable exception to this is the MATLAB tool NLvib (a very well designed set of minimal routines that work really well). The main reason that juliajim is not just a fork of NLvib is Julia - I'm convinced of the several advantages of Julia and want to ensure a useful package exists in Julia that I can throw myself behind. Furthermore, since I started using Julia MATLAB has started feeling really annoying (read: https://mateusaraujo.info/2024/04/03/matlab-is-dead-long-live-julia/ ).","category":"section"},{"location":"#Design-Philosophy","page":"Home","title":"Design Philosophy","text":"I am taking care to ensure that the project is as small as possible in order to ensure that the routines developed here can be part of something bigger. Furthermore, the different parts of the package (HARMONIC, CONTINUATION) are written in order to be fully functional independently. For instance, the HB routines in the former portion of the toolbox can be used to write residue that can be used with BifurcationKit.jl for doing numerical continuation if the provided routines in CONTINUATION are deemed insufficient. \n\nMDOFUTILS and its suite of routines (including frequency domain residues, time domain marchers, etc.) are my way of using the two main parts of the package to provide a functional interface for nonlinear dynamics research.","category":"section"},{"location":"#Conventions","page":"Home","title":"Conventions","text":"All scripts are tagged by an alphabet. \nAll routines are upper case. ","category":"section"},{"location":"#Other-Projects-to-Look-at","page":"Home","title":"Other Projects to Look at","text":"NLvib: A Matlab toolbox for harmonic balance, shooting, and continuation.\ntmdsimpy: A Python package with very similar goals as juliajim.\noctave-jim: My old code - its a mess that works.\nHarmonicBalance.jl: A Julia toolbox for harmonic balance. \nBifurcationKit.jl: A great set of continuation and bifurcation routines.","category":"section"}]
}
