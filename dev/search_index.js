var documenterSearchIndex = {"docs":
[{"location":"a_hworld/#Example-a:-Introduction-to-the-AFT-Routines","page":"a_hworld","title":"Example a: Introduction to the AFT Routines","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"This example is intended to showcase the Alternating Frequency Time (AFT) routines in juliajim.HARMONIC.","category":"page"},{"location":"a_hworld/#PreambleLoad-the-necessary-packages","page":"a_hworld","title":"PreambleLoad the necessary packages","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"using GLMakie\nusing LinearAlgebra\nusing SparseArrays\nusing Arpack\n\nusing Revise\nusing juliajim.HARMONIC","category":"page"},{"location":"a_hworld/#Alternating-Frequency-Time-Transformation","page":"a_hworld","title":"Alternating Frequency Time Transformation","text":"","category":"section"},{"location":"a_hworld/#AFT-Single-Frequency-Check-(Periodic-signal)","page":"a_hworld","title":"AFT - Single Frequency Check (Periodic signal)","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"Here we will use the AFT routine to do a Fourier transform of a time-domain signal, yt, to compute its Fourier coefficients, yf. The general form assumed for a Fourier series is: $ y = a0 + \\sum{n=1}^H a_n \\cos n\\tau + \\sin n\\tau $ where tau is the scaled time such that the signal y(tau) is 2pi-periodic. For instance, if the excitation frequency is Omega and physical time is t (such that we have 2piOmega as the time period, the scaled time coordinate tau is defined as tau=Omega t.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"The AFT routine provides a convenience utility for transforming from a discrete time array to an array of the Fourier coefficients which is written as $ \\begin{bmatrix} a0 & a1 & b1 & a2 & b_2 & \\dots \\end{bmatrix}^T. $ The same routine may also be used to do the opposite transformation (frequency coefficients to time array).","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"We first discretize time by dividing the domain 0 2pi into 128 parts.","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"N = 128;\nt = (0:N-1)*2π/N;\n# yt = cos.(t) + 3sin.(2t) .+ 4;\nyt = cos.(t) .+ 2;\nyt = [yt yt];\n\nh = collect(0:3)[:,:];\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\nyf = AFT(yt, h, N, :t2f);\nYT = AFT(yf, h, N, :f2t);\nnothing #hide","category":"page"},{"location":"a_hworld/#AFT-2-Freq-Check","page":"a_hworld","title":"AFT - 2 Freq Check","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"ts = Iterators.product(t, t);\nyt = [cos(t1)+3sin(t2)+4 for (t1,t2) in ts];\nh = [0 0;1 0;0 1;1 1];\n\nyf = AFT([yt[:] yt[:]], h, N, :t2f);\nYT = AFT(yf, h, N, :f2t);\nnothing #hide","category":"page"},{"location":"a_hworld/#HSEL","page":"a_hworld","title":"HSEL","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"C = 2;\nNhmax = 4;\n\nh = HSEL(Nhmax, 1:C);\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nnothing #hide","category":"page"},{"location":"a_hworld/#HARMONIC-STIFFNESS","page":"a_hworld","title":"HARMONIC STIFFNESS","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"M = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nC = 2;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C)\nws = [1, π];\nws = ws[1:C];\n\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\nnothing #hide","category":"page"},{"location":"a_hworld/#Forced-Response","page":"a_hworld","title":"Forced Response","text":"","category":"section"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"C = 1;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C);\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nFl = zeros(Nhc, 1);\nFl[2] = 1.0;\nFl = kron(Fl, [1;0]);\n\nOmr, V = eigen(K, collect(M));\nOmr = sqrt.(Omr);\n\nΩs = LinRange(0.5, 2, 500);\nAs = zeros(ComplexF64, size(Ωs));\n\nfor i = eachindex(Ωs)\n    local E, dEdw\n    E, dEdw = HARMONICSTIFFNESS(M, D, K, [Ωs[i]], h);\n    U = E\\Fl;\n    As[i] = U[3]+im*U[5];\nend\n\nset_theme!(theme_latexfonts())\nfsz = 18;\nfig = Figure(fontsize=fsz);\nif !isdefined(Main, :scr) && Makie.current_backend()==GLMakie # src\n   scr = GLMakie.Screen(); # src\nend # src\n\nax = Axis(fig[1, 1],\n          xlabel=\"Excitation Frequency (rad/s)\",\n          ylabel=\"Response Amplitude (m)\",\n          xscale=Makie.pseudolog10,\n          yscale=Makie.pseudolog10);\nlines!(ax, Ωs, abs.(As))\n\n\nfig","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"","category":"page"},{"location":"a_hworld/","page":"a_hworld","title":"a_hworld","text":"This page was generated using Literate.jl.","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Contents","page":"Reference","title":"Contents","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#Index","page":"Reference","title":"Index","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Pages = [\"reference.md\"]","category":"page"},{"location":"reference/#juliajim.juliajim","page":"Reference","title":"juliajim.juliajim","text":"The main juliajim module\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.HARMONIC","page":"Reference","title":"juliajim.HARMONIC","text":"Useful routines for Harmonic Balance. Also includes Chebyshev Galerkin utilites.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.HARMONIC.ACT-NTuple{4, Any}","page":"Reference","title":"juliajim.HARMONIC.ACT","text":"ACT(yin, h::hTypes, N::Int64, dir::Symbol)\n\nRoutine for the alternating Chebyshev Transform. Uses AFT internally. \n\nArguments\n\nyin              : \nh::hTypes : \nN::Int64         : \ndir::Symbol      : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.AFT-NTuple{4, Any}","page":"Reference","title":"juliajim.HARMONIC.AFT","text":"AFT(yin, h::hTypes, N::Int64, dir::Symbol);\n\nRoutine to conduct Time-to-Frequency and Frequency-to-Time transforms for the general Multi frequency case.\n\nArguments\n\nyin::VecOrMat{Float64}: (N^C, Ny) if time data, and (Nhc, Ny) if frequency data.\nh::hTypes: (Nh, C) list of harmonics.\nN::Int64: Number of time samples for AFT.\ndir::Symbol: :t2f for time-to-frequency, and :f2t for frequency-to-time.\n\nExamples\n\nSingle Frequency Case:\n\n    N = 8;\n    t = (0:N-1)*2π/N;\n    yt = cos.(t) + 3sin.(2t) .+ 4;\n    yt = [yt yt];\n\n    h = collect(0:3)[:,:];\n    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\n    yf = AFT(yt, h, N, :t2f);\n    YT = AFT(yf, h, N, :f2t);\n\n2-Frequency Case:\n\n    t1 = repeat(t, 1, N);\n    t2 = repeat(t', N, 1);\n\n    yt = cos.(t1) + 3sin.(t2) .+ 4;\n    h = [0 0;1 0;0 1;1 1];\n    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\n\n    yf = AFT([yt[:] yt[:]], h, N, :t2f);\n    YT = AFT(yf, h, N, :f2t);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.DCHEB-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.HARMONIC.DCHEB","text":"DCHEB(h::hTypes)\n\nReturns the Chebyshev Differentiation matrix.\n\nArguments\n\nh::hTypes : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.DFOUR","page":"Reference","title":"juliajim.HARMONIC.DFOUR","text":"DFOUR(h::hTypes, ws=nothing)\n\nReturns the Fourier differentiation matrix (useful for HB representations).\n\nArguments\n\nh::hTypes : (H, C) Harmonic indices\nws::Array{Float64} : (C, 1) (optional) list of frequencies\n\nOutputs\n\nD : (Nhc, Nhc) Harmonic differentiation matrix\ndDdw : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.DFOUR!","page":"Reference","title":"juliajim.HARMONIC.DFOUR!","text":"DFOUR!(h::hTypes, D, dDdw=nothing, ws=nothing)\n\nBang version of DFOUR.\n\nArguments\n\nh::hTypes : (H, C) Harmonic indices\nD : (Nhc, Nhc) Harmonic differentiation matrix\ndDdw : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).\nws::Array{Float64} : (C, 1) (optional) list of frequencies\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.FSEVAL","page":"Reference","title":"juliajim.HARMONIC.FSEVAL","text":"FSEVAL(h::hTypes, t::Union{StepRangeLen{Float64}, VecOrMat{Float64}}, U::Union{Nothing,Matrix{Float64}}=nothing)\n\nDescription\n\nEvaluates the Fourier series at required time points. If Fourier coefficients are not provided, it returns the mapping matrix.\n\nArguments\n\nh::hTypes                      : \nt::Union{StepRangeLen{Float64} : \nVecOrMat{Float64}}             : \nU::Union{Nothing               : \nMatrix{Float64}}               : (default nothing)\n\nOutputs\n\nut\t: In case U is provided, this is outputted first.\nJ\t: The mapping matrix such that J*U gives the desired temporal evaluates.\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.HARMONICSTIFFNESS!-NTuple{7, Any}","page":"Reference","title":"juliajim.HARMONIC.HARMONICSTIFFNESS!","text":"HARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h)\n\nBang version of HARMONICSTIFFNESS (preallocate E, dEdw).\nAdvantage is that nothing can be passed to avoid needless computations.\n\nArguments\n\nE: (NdNhc, NdNhc) Harmonic Stiffness\ndEdw: C-Vector of (NdNhc, NdNhc) Representing Frequency-gradients of E\n'M, D, K': (Nd,Nd) Mass, Damping, Stiffness Matrices.\n'ws::Array{Float64}': (C,1) list of frequencies\n'h': (H, C) harmonic indices\n\nExamples\n\nSingle Frequency Case\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nh = [0;1;2;3];\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nE = zeros(2*Nhc, 2*Nhc);\ndEdw = zeros(2*Nhc, 2*Nhc);\nws = 1;\nHARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);\n\n2-Frequency Case\n\nNhmax = 3;\nws = [1; π];\nh = HSEL(Nhmax, ws);\nNhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));\nE = zeros(2*Nhc, 2*Nhc);\ndEdw = zeros(2*Nhc, 2*Nhc);\nHARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HARMONICSTIFFNESS-NTuple{5, Any}","page":"Reference","title":"juliajim.HARMONIC.HARMONICSTIFFNESS","text":"HARMONICSTIFFNESS(M, D, K, ws::Array{Float64}, h)\n\nComputes the harmonic stiffness for HB simulations.\n\nArguments\n\n'M, D, K': (Nd,Nd) Mass, Damping, Stiffness Matrices.\n'ws::Array{Float64}': (C,1) list of frequencies\n'h': (H, C) harmonic indices\n\nOutputs\n\nE: (NdNhc, NdNhc) Harmonic Stiffness\ndEdw: C-Vector of (NdNhc, NdNhc) Representing Frequency-gradients of E\n\nExamples\n\nSingle Frequency Case\n\nM = I(2);\nK = [2 -1;-1 2];\nD = 0.001.*K + 0.01.*M;\n\nh = [0;1;2;3];\nws = 1;\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\n\n2-Frequency Case\n\nNhmax = 3;\nws = [1; π];\nh = HSEL(Nhmax, ws);\nE, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}","page":"Reference","title":"juliajim.HARMONIC.HINDS","text":"HINDS(Ndofs::Int64, h::hTypes)\n\nArguments\n\nNdofs::Int64     : \nh::hTypes :\n\nOutputs\n\nzinds\nhinds\nrinds0\nrinds\niinds\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.HARMONIC.HSEL","page":"Reference","title":"juliajim.HARMONIC.HSEL","text":"HSEL(Nhmax::Int64, ws::Any=1, hcr::Int=1)\n\nSelection of Harmonic indices based on different criteria. First C+1 rows are [zeros(1,C); I(C)].\n\nImplemented criteria are,\n\nhcr=1: Σᵢ |hᵢ| < Nhmax & ∑ᵢ h_i ≥ 0\n\nArguments\n\nNhmax::Int64: Max harmonic for truncation.\nws=1: [opt] List of frequencies\nhcr::Int=1: [opt] Truncation criterion. See above.\n\nExamples\n\nC = 2;\nNhmax = 3;\n\nh = HSEL(Nhmax, 1:C)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.PRODMAT_CHEB","page":"Reference","title":"juliajim.HARMONIC.PRODMAT_CHEB","text":"Description\n\nArguments\n\nU    : \nh    : \nHmax : (default nothing)\nD    : (default nonothing)\nL    : (default nonothing)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.HARMONIC.PRODMAT_FOUR","page":"Reference","title":"juliajim.HARMONIC.PRODMAT_FOUR","text":"PRODMAT_FOUR(U::VecOrMat{Float64}, h::hTypes, Hmax=nothing, D=nothing, L=nothing)\n\nDescription\n\nReturns the Fourier product matrix. Currently only implemented for C=1.\n\nArguments\n\nU::VecOrMat{Float64}\t\t: \nh::hTypes    \t\t\t: \nHmax \t\t\t\t: (default nothing)\nD    \t\t\t\t: (default nothing)\nLb   \t\t\t\t: (default nothing)\n\n\n\n\n\n","category":"function"},{"location":"reference/#juliajim.CONTINUATION","page":"Reference","title":"juliajim.CONTINUATION","text":"Useful types and routines for numerical continuation.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.CONTINUATION.myNLSoln","page":"Reference","title":"juliajim.CONTINUATION.myNLSoln","text":"myNLSoln\n\nStruct storing the solution, Jacobian, and (unit) tangent.\n\nFields\n\nup::nvTypes: Solution point ([u;p])\nJ::nmTypes: Jacobian dr/du\nJp::nvTypes: Parameter Jacobian dr/dp\ndupds::nvTypes: Tangent vector (has to be vector only)  \n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.CONTINUATION.myNLSoln-2","page":"Reference","title":"juliajim.CONTINUATION.myNLSoln","text":"myNLSoln(up::nvTypes=nothing; J::nmTypes=nothing, Jp::nvTypes=nothing)\n\nConstructor for myNLSoln. Can specify one or all the arguments (point, jacobian, paramjac).\n\nArguments\n\nup::nvTypes       : (default nothing) Solution point\nJ::nmTypes        : (default nothing) Jacobian\nJp::nvTypes       : (default nothing) paramjac\nsave_jacs::Bool   : (default false) Whether or not to store the Jacobians.\n\nIf both J and Jp are provided, the unit tangent dupds is computed using nullspace([J Jp])[:,1].\n\n\n\n\n\n","category":"type"},{"location":"reference/#Base.:--Tuple{myNLSoln, myNLSoln}","page":"Reference","title":"Base.:-","text":"Base.:-(v1::myNLSoln, v2::myNLSoln)\n\nOverloading the subtraction operator to take the difference between two myNLSoln \n\n\n\n\n\n","category":"method"},{"location":"reference/#Base.show-Tuple{IO, myNLSoln}","page":"Reference","title":"Base.show","text":"Base.show(io::IO, p::myNLSoln)\n\nOverloading base show function to display myNLSoln object.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.CONTINUATION.CONTINUATE-Tuple{Vector{Float64}, Any, Vector{Float64}, Float64}","page":"Reference","title":"juliajim.CONTINUATION.CONTINUATE","text":"CONTINUATE(u0, fun, ps, dp; kwargs...)\n\nContinuation routine. Solves the bordered problem with residue drawn from EXTRESFUN!.\n\nArguments\n\nu0::Vector{Float64}                          : Initial guess for first point\nfun                                          : NonlinearFunction object. Will call:\nfun.f(du, u, p) for residue r. p must be scalar.\nfun.jac(J, u, p) for jacobian dr/du. Uses ForwardDiff.jacobian! if fun.jac is nothing.\nfun.paramjac(Jp, u, p) for jacobian dr/dp. Uses ForwardDiff.jacobian! if fun.paramjac is nothing.\nps::Vector{Float64}                          : Specify range of p for continuation.\ndp::Float64                                  : Specify first step in Δp units. (will be rescaled if necessary)\n\nOptional Arguments\n\nparm::Symbol                                 : (default :arclength) Arclength parameterization. See EXTRESFUN!.\nnmax::Int64                                  : (default 1000) Maximum number of steps.\ndpbnds::Union{Nothing,Vector{Float64}}       : (default [dp/5,5dp]) Bounds for the step length dp. (Rescaled as appropriate)\nsave_jacs::Bool                              : (default false) Specify whether or not to save the Jacobians in the output. Only solution and (unit) tangent are saved if false.\nverbosity::Int                               : (default 1) Verbosity levels:\n0: Suppress all messages.\n1: Display Steps, Continuation Progress.\n2: Display Iteration Information for each step also.\n\nFor Scaling of Unknowns (recommended to get evenly spaced points on response curve)\n\nDsc::Union{Symbol,Nothing,Vector{Float64}}   : (default :auto) \"Dscaling\" used to scale the unknowns. The arc length constraint is applied in the scaled space (uₛ=uₚₕ./Dsc).\nIf set to :auto, it uses the absolute of the first converged solution as the initial Dsc vector. Zero entries are replaced with minDsc.\nIf set to :none, it fixes Dsc to a vector of ones and doesn't dynamically adapt it. (this forces DynScale to false).\nIf set to :ones, it fixes Dsc to a vector of ones but dynamically continues to scale.\nDynScale::Bool                               : (default true) Whether or not to dynamically adapt the Dsc vector. Each entry is allowed to grow or shrink by a maximum factor of 2 in each step if true.\nminDsc::Float64                              : (default eps()^(4//5)=3e-13) Minimum value for Dscale.\n\nFor Step Length Adaptation. Currently set as dsₙ = dsₒ * xi, where xi = clamp((itopt/itns)^nxi, xirange[1], xirange[2]).\n\nitopt::Union{Symbol,Int}                     : (default :auto) Optimal number of  \nnxi::Float64                                 : (default 0.0) Switches off adaptation by default. \nxirange::Vector{Float64}                     : (default [0.5,2.])\n\nReturns\n\nvector{myNLsoln} representing solutions.\nvector{Int} representing iterations taken.\nvector{Float64} representing step sizes.\nvector{Float64} representing adaptation parameter ξ.\nvector{Float64} representing the final Dscale matrix.\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.CONTINUATION.EXTRESFUN!-NTuple{4, Any}","page":"Reference","title":"juliajim.CONTINUATION.EXTRESFUN!","text":"EXTRESFUN!(up::nvTypes, fun, sol0::myNLSoln, ds::Float64; parm::Symbol=:riks, Dsc::Vector{Float64}, dup::nvTypes=nothing, Jf::nmTypes=nothing)\n\nReturns the bordered/extended residue function. Appends residue with required arclength constraint.\n\nNote\n\nThe function involves very naive autodiff calls. Does not respect or try to detect jacobian sparsity. For now it is best to provide analytical jacobians for very large problems. \n\nArguments\n\nup::nvTypes: Solution point for evaluation\nfun: Nonlinear function specified in a fashion that can be called as\nfun.f(du,up[1:end-1],up[end]) for the residue.\nfun.jac(J,up[1:end-1],up[end]) for the jacobian (uses ForwardDiff.jacobian! if fun.jac is nothing)\nfun.paramjac(Jp,up[1:end-1],up[end]) for the parameter jacobian (uses ForwardDiff.jacobian! if fun.paramjac is nothing)\nDevelopment Done based on NonlinearFunction from NonlinearSolve\nsol0::myNLSoln: Previous solution point.\nds::Float64: Step size.\nparm::Symbol=:riks: Arclength parameterization. Defaults to :riks. Possible are:\n:riks: Riks' or normal parameterization.\n:arclength: Arclength parameterization.\nDsc::Vector{Float64}: Scaling vector. Recommended to be of the order of magnitude of the expected unknowns. Size same as up.\ndup::nvTypes=nothing: Residue vector (for iip evaluation)\nJf::nmTypes=nothing: Jacobian matrix (for iip evaluation)\n\nReturns\n\ndup::nvTypes=nothing: Residue vector (for iip evaluation)\nJf::nmTypes=nothing: Jacobian matrix (for iip evaluation)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS","page":"Reference","title":"juliajim.MDOFUTILS","text":"Useful types and routines for dynamic analyses of MDOF problems.\n\n\n\n\n\n","category":"module"},{"location":"reference/#juliajim.MDOFUTILS.MDOFGEN","page":"Reference","title":"juliajim.MDOFUTILS.MDOFGEN","text":"MDOFGEN\n\nStruct storing the generic MDOF system.\n\nFields\n\nM::Matrix{Float64}: Mass matrix\nC::Matrix{Float64}: Damping Matrix\nK::Matrix{Float64}: Stiffness Matrix\nL: Displacement Transform Matrix (can be empty)\nNdofs::Int64: Number of DOFs\nNLTs::Vector{NONLINEARITY}: Vector of nonlinearities present (see NONLINEARITY)\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.MDOFUTILS.NONLINEARITY","page":"Reference","title":"juliajim.MDOFUTILS.NONLINEARITY","text":"NONLINEARITY\n\nStruct storing a nonlinearity.\n\nFields\n\ntype::Symbol: Type of nonlinearity. One of:\n:Inst (for instantaneous nonlinearity)\n:Hyst (for hysteretic nonlinearity)\n:Fdom (for nonlinearity defined in frequency domain)\nOut of these, only the first 2 can be used for transient simulations.\nfunc::Function: Function handle for evaluating nonlinearity. Has signature\n(t, u, udot) for :Inst\n(t, u, up, sp) for :Hyst, where s is some internal state (sp is s at t-Δt)\nL::Matrix{Float64}: Selection Matrix\nLf: Force shape matrix (can be empty)\n\n\n\n\n\n","category":"type"},{"location":"reference/#juliajim.MDOFUTILS.EPMCRESFUN!-Tuple{Any, MDOFGEN, Any, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.EPMCRESFUN!","text":"Description\n\nArguments\n\nUwxa                : \nm::MDOFGEN          :\nFl                  : (Nd*Nhc) Forcing vector. Zero harmonics are used as static loads. Harmonic portions are used to provide phase constraint.\nh                   : \nN::Int64            : \ntol::Float64        : (default eps()^(4//5))\natype::Symbol       : (default :H1)\nashape::Union{Int64 : \nVector{Float64}}    : (default 1)\nR                   : (default nothing)\ndRdUwx              : (default nothing)\ndRda                : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.HBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.HBRESFUN!","text":"Description\n\nResidue function that can be used for Harmonic Balance forced response analysis.\n\nArguments\n\nUw   : \nm    : \nFl   : \nh    : \nN    : \ntol  : \ndRdU : \ndRdw : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.HBRESFUN_A!-Tuple{Any, MDOFGEN, Float64, Any, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.HBRESFUN_A!","text":"Description\n\nHB residue with amplitude constraint.\n\nArguments\n\nUfw           : \nm::MDOFGEN    : \nA::Float64    : Amplitude level (also see atype below)\nFl            : \nh             : \nN::Int64      :\natype::Symbol : (default :H1) One of :H1, :RMS. Type of amplitude measure.\nashape        : (default 1) Shape to dof for applying amplitude. If Integer, interpreted as Dof. If vector, taken as shape.\ntol::Float64  : (default eps()^(4//5))\nR             : (default nothing)\ndRdUf         : (default nothing)\ndRdw          : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NEWMARKMARCH-Tuple{MDOFGEN, Vararg{Any, 6}}","page":"Reference","title":"juliajim.MDOFUTILS.NEWMARKMARCH","text":"Description\n\nArguments\n\nm::MDOFGEN : \nT0         : \nT1         : \ndt         : \nU0         : \nUd0        : \nFex        : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NLEVAL!-Tuple{Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, MDOFGEN, Any, Int64}","page":"Reference","title":"juliajim.MDOFUTILS.NLEVAL!","text":"Description\n\nEvaluate the nonlinearities (and Jacobian) for one period and return the harmonics\n\nArguments\n\nUw         : \nm::MDOFGEN :\nh          :\nN::Int64   : [optional]\ntol        :   \nFNL        : \ndFNLdU     : \ndFNLdw     : \n\n\n\n\n\n","category":"method"},{"location":"reference/#juliajim.MDOFUTILS.NLFORCE-Tuple{MDOFGEN, Any, Any, Any}","page":"Reference","title":"juliajim.MDOFUTILS.NLFORCE","text":"Description\n\nArguments\n\nm::MDOFGEN : \nt          : \nU          : \nUd         : \ntp         : (default nothing)\nUp         : (default nothing)\nUdp        : (default nothing)\nSp         : (default nothing)\n\n\n\n\n\n","category":"method"},{"location":"#Welcome-to-the-juliajim-Documentation!","page":"Home","title":"Welcome to the juliajim Documentation!","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation page. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"note: Why should you be interested?\nHere's my vision for the package: I would like to use a singly specified dynamical system to subject it to different types of analyses. This includes transient simulations, steady-state periodic/quasi-periodic, etc.If this is interesting to you, you may find value in the project. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that this is still under heavy development. It is functional but the documentation needs a lot of work. Please reach out to me in case you're interested in contributing, share the vision, and have started loving Julia! :-)","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This is a set of Julia routines to help with computational research in nonlinear structural dynamics. Most of the content is derived from my earlier efforts (functional but badly maintained) with MATLAB/Octave at https://github.com/Nidish96/octave-jim.","category":"page"},{"location":"#Why-yet-another-package?","page":"Home","title":"Why yet another package?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Each programming language/environment/specification you choose (MATLAB, Python, Julia, C/C++, etc.) has its own host of libraries that can do a lot of what juliajim sets out to do. Notable examples include Trilinos (C++) and the SciML ecosystem (Julia), which can do what juliajim sets out and (FAR!) more.","category":"page"},{"location":"","page":"Home","title":"Home","text":"My vision for this tool is this: I'd like to be able to specify a system once and conduct different types of analysis on it. This mainly includes nonlinear static solves, transient time-marching (also shooting for periodic solutions), harmonic balance (for periodic and quasi periodic solutions), and variants therein (potentially more).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Although a lot of the existing tools come very close to acheiving this, they don't span nearly all the kinds of nonlinearities. For instance, it is presently quite non-trivial to use any existing code as is for simulating systems with something as simple as an elastic dry-friction element (a hysteretically saturated linear spring).","category":"page"},{"location":"","page":"Home","title":"Home","text":"Furthermore, very few tools provide a lot of convenience for harmonic balance simulations. A notable exception to this is the MATLAB tool NLvib (a very well designed set of minimal routines that work really well). The main reason that juliajim is not just a fork of NLvib is Julia - I'm convinced of the several advantages of Julia and want to ensure a useful package exists in Julia that I can throw myself behind. Furthermore, since I started using Julia MATLAB has started feeling really annoying (read: https://mateusaraujo.info/2024/04/03/matlab-is-dead-long-live-julia/ ).","category":"page"},{"location":"#Other-Projects-to-Look-at","page":"Home","title":"Other Projects to Look at","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"NLvib: A Matlab toolbox for harmonic balance, shooting, and continuation.\ntmdsimpy: A Python package with very similar goals as juliajim.\noctave-jim: My old code - its a mess that works.\nHarmonicBalance.jl: A Julia toolbox for harmonic balance. \nBifurcationKit.jl: A great set of continuation and bifurcation routines.","category":"page"},{"location":"#Design-Philosophy","page":"Home","title":"Design Philosophy","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"I am taking care to ensure that the project is as small as possible in order to ensure that the routines developed here can be part of something bigger. Furthermore, the different parts of the package (Harmonic, Continuation) are written in order to be fully functional independently. For instance, the HB routines in the former portion of the toolbox can be used to write residue that can be used with BifurcationKit.jl for doing numerical continuation if the provided routines are deemed insufficient. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"MDOFUTILS and its suite of routines (including frequency domain residues, time domain marchers, etc.) are my way of using the two main parts of the package to provide a functional interface for nonlinear dynamics research.","category":"page"},{"location":"#Conventions","page":"Home","title":"Conventions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All scripts are tagged by an alphabet. \nAll routines are upper case. ","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you're just here for the...","category":"page"},{"location":"","page":"Home","title":"Home","text":"Fourier Utilities, start by looking at AFT.\nContinuation Utilities, start by looking at CONTINUATE.\nIntegrated nonlinear dynamics, start by looking at MDOFUTILS.\nHarmonic Balance Utilities, start by looking at HBRESFUN!\nTransient Simulation Utilities, start by looking at NEWMARKMARCH\nAll of the above.","category":"page"},{"location":"#Examples-with-Documentation","page":"Home","title":"Examples with Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Few examples of increasing complexity. Find them in the /examples/ folder.","category":"page"},{"location":"","page":"Home","title":"Home","text":"And more!","category":"page"},{"location":"#Example-code-snippet","page":"Home","title":"Example code snippet","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using juliajim.HARMONIC\n\nN = 8\nt = (0:N-1)*2pi/N;\ny = cos.(t);\nh = 0:3;\nYh = AFT(y, h,N, :t2f);","category":"page"}]
}
