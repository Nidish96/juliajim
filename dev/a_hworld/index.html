<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>A: Harmonic Utilities · juliajim</title><meta name="title" content="A: Harmonic Utilities · juliajim"/><meta property="og:title" content="A: Harmonic Utilities · juliajim"/><meta property="twitter:title" content="A: Harmonic Utilities · juliajim"/><meta name="description" content="Documentation for juliajim."/><meta property="og:description" content="Documentation for juliajim."/><meta property="twitter:description" content="Documentation for juliajim."/><meta property="og:url" content="https://github.com/Nidish96/juliajim/a_hworld/"/><meta property="twitter:url" content="https://github.com/Nidish96/juliajim/a_hworld/"/><link rel="canonical" href="https://github.com/Nidish96/juliajim/a_hworld/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">juliajim</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li class="is-active"><a class="tocitem" href>A: Harmonic Utilities</a><ul class="internal"><li><a class="tocitem" href="#Preamble:-Load-the-necessary-packages"><span>Preamble: Load the necessary packages</span></a></li><li><a class="tocitem" href="#Alternating-Frequency-Time-Transformation"><span>Alternating Frequency Time Transformation</span></a></li><li><a class="tocitem" href="#The-&quot;Harmonic&quot;-Stiffness"><span>The &quot;Harmonic&quot; Stiffness</span></a></li><li><a class="tocitem" href="#Forced-Response-Computation-with-[HARMONIC](@ref)"><span>Forced Response Computation with <code>HARMONIC</code></span></a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">B: Numerical Continuation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../b1_duffhb/">1: Duffing Oscillator</a></li><li><a class="tocitem" href="../b2_jenkhb/">2: Frictional Oscillator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">C: Examples with the MDOFUTILS Suite</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../c1_mdofgen_instnl/">1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity</a></li><li><a class="tocitem" href="../c2_mdofgen_hystnl/">2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity</a></li><li><a class="tocitem" href="../c3_mdofgen_ahb/">3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator</a></li><li><a class="tocitem" href="../c4_mdofgen_epmc/">4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC</a></li><li><a class="tocitem" href="../c5_mdofgen_newmark/">5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme</a></li></ul></li></ul></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>A: Harmonic Utilities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>A: Harmonic Utilities</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nidish96/juliajim/blob/master/examples/a_hworld.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="ex_a"><a class="docs-heading-anchor" href="#ex_a">Example A: Introduction to the AFT Routines</a><a id="ex_a-1"></a><a class="docs-heading-anchor-permalink" href="#ex_a" title="Permalink"></a></h1><p>This example is intended to showcase the Alternating Frequency Time (AFT) routines in <a href="../reference/#juliajim.HARMONIC"><code>juliajim.HARMONIC</code></a>.</p><p>At its core, it is just a bunch of utility routines that allow time-to-frequency and frequency-to-time transformations. These can also be used for Chebyshev polynomial expansions, as will be seen below.</p><h2 id="Preamble:-Load-the-necessary-packages"><a class="docs-heading-anchor" href="#Preamble:-Load-the-necessary-packages">Preamble: Load the necessary packages</a><a id="Preamble:-Load-the-necessary-packages-1"></a><a class="docs-heading-anchor-permalink" href="#Preamble:-Load-the-necessary-packages" title="Permalink"></a></h2><pre><code class="language-julia hljs">using GLMakie
using LinearAlgebra
using SparseArrays
using Arpack

using juliajim.HARMONIC</code></pre><h2 id="Alternating-Frequency-Time-Transformation"><a class="docs-heading-anchor" href="#Alternating-Frequency-Time-Transformation">Alternating Frequency Time Transformation</a><a id="Alternating-Frequency-Time-Transformation-1"></a><a class="docs-heading-anchor-permalink" href="#Alternating-Frequency-Time-Transformation" title="Permalink"></a></h2><h3 id="AFT-Single-Frequency-(Periodic-signal)"><a class="docs-heading-anchor" href="#AFT-Single-Frequency-(Periodic-signal)">AFT - Single Frequency (Periodic signal)</a><a id="AFT-Single-Frequency-(Periodic-signal)-1"></a><a class="docs-heading-anchor-permalink" href="#AFT-Single-Frequency-(Periodic-signal)" title="Permalink"></a></h3><p>Here we will use the AFT routine to do a Fourier transform of a time-domain signal, <code>yt</code>, to compute its Fourier coefficients, <code>yf</code>. The general form assumed for a Fourier series is:</p><p class="math-container">\[y = a_0 + \sum_{n=1}^H a_n \cos n\tau + \sin n\tau\]</p><p>where (\tau) is the scaled time such that the signal <span>$y(\tau)$</span> is <span>$2\pi$</span>-periodic. For instance, if the excitation frequency is <span>$\Omega$</span> and physical time is <span>$t$</span> (such that we have <span>$2\pi/\Omega$</span> as the time period), the scaled time coordinate <span>$\tau$</span> is defined as <span>$\tau=\Omega t$</span>.</p><p>The AFT routine provides a convenience utility for transforming from a discrete time array to an array of the Fourier coefficients which is written as</p><p class="math-container">\[\begin{bmatrix} a_0 &amp; a_1 &amp; b_1 &amp; a_2 &amp; b_2 &amp; \dots \end{bmatrix}.\]</p><p>The same routine may also be used to do the opposite transformation (frequency coefficients to time array).</p><p>We first discretize time by dividing the domain <span>$[0, 2\pi]$</span> into <code>128</code> parts.</p><pre><code class="language-julia hljs">N = 128;
t = (0:N-1)*2π/N;
# yt = cos.(t) + 3sin.(2t) .+ 4;
yt = cos.(t) .+ 2;
yt = [yt yt];</code></pre><p>We have put two copies of the vector <code>yt</code> in columns to expose the fact that the <a href="../reference/#juliajim.HARMONIC.AFT-NTuple{4, Any}"><code>AFT</code></a> routine is vectorized: Having time series in <code>M</code> columns will return corresponding Fourier coefficients in <code>M</code> columns.</p><p>Now we set the list of harmonics of interest. This can also be an unordered list, but if you&#39;re including the zeroth harmonic, that should always be the first.</p><pre><code class="language-julia hljs">h = 0:3
Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));</code></pre><p>The variable <code>Nhc</code> is the number of harmonic coefficients. For the zeroth harmonics we have only one coefficient ((a<em>0) above) and for every non-zero harmonic we have two, correponding to the sine and cosine ((a</em>i,b_i) above). The formula above looks more complicated than it must because this works even for the multi-frequency case.</p><p>Now we call the actual <a href="../reference/#juliajim.HARMONIC.AFT-NTuple{4, Any}"><code>AFT</code></a> routine. The first argument is the time series vector (or matrix of column vectors), the second argument is the harmonic indices of interest, third is the number of AFT samples (when inputting the time vector <code>N</code> has to be the same as the number of rows of <code>yt</code>), and the last argument is a <code>Symbol</code>. The last argument specifies if we&#39;re interested in a time-to-frequency (<code>:t2f</code>) or frequency-to-time (<code>:f2t</code>) transformation.</p><pre><code class="language-julia hljs">yf = AFT(yt, h, N, :t2f);  # Time to Frequency
YT = AFT(yf, h, N, :f2t);  # Frequency to Time</code></pre><p><code>yf</code> is the list of harmonics and <code>YT</code> is the time vector reconstructed from the harmonics. You should be able to verify that <code>yt</code> and <code>YT</code> are numerically the same.</p><pre><code class="language-julia hljs">yf</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7×2 Matrix{Float64}:
 2.0          2.0
 1.0          1.0
 1.56844e-16  1.56844e-16
 2.49554e-17  2.49554e-17
 4.70719e-19  4.70719e-19
 5.22189e-18  5.22189e-18
 6.0355e-18   6.0355e-18</code></pre><h3 id="AFT-2-Frequency-Case-(Quasi-periodic-signal)"><a class="docs-heading-anchor" href="#AFT-2-Frequency-Case-(Quasi-periodic-signal)">AFT - 2 Frequency Case (Quasi-periodic signal)</a><a id="AFT-2-Frequency-Case-(Quasi-periodic-signal)-1"></a><a class="docs-heading-anchor-permalink" href="#AFT-2-Frequency-Case-(Quasi-periodic-signal)" title="Permalink"></a></h3><p>Now we show how the same <a href="../reference/#juliajim.HARMONIC.AFT-NTuple{4, Any}"><code>AFT</code></a> routine can be used for multi-frequency Fourier representations. Our Fourier series representation is written as</p><p class="math-container">\[y(t) = a_0 + \sum_{n=1}^H a_n cos( h1_n \tau_1 + h2_n \tau_2) + b_n sin( h1_n \tau_1 + h2_n\tau_2 ),\,\text{with } \tau_i = \Omega_i t.\]</p><p>Here, <span>$h1, h2$</span> are index arrays storing the harmonic coefficient corresponding to the two frequencies present. The scaled time coordinates (aka Torus coordinates) <span>$(\tau_1,\tau_2)$</span> are defined as above such that the signal <span>$y(t)$</span> can be written as the torus function <span>$Y(\tau_1,\tau_2)$</span>, which is periodic on the 2D domain. Note that <span>$y(t)$</span> and <span>$Y(\tau_1, \tau_2)$</span> are not the same, although we can reconstruct <span>$y(t)$</span> from <span>$Y(\tau_1,\tau_2)$</span>.</p><p>The usage of the routine is identical to before.</p><pre><code class="language-julia hljs">ts = Iterators.product(t, t);
yt = [cos(t1)+3sin(t2)+4 for (t1,t2) in ts];
h = [0 0;1 0;0 1;1 1];

yf = AFT([yt[:] yt[:]], h, N, :t2f);
YT = AFT(yf, h, N, :f2t);
yf</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">7×2 Matrix{Float64}:
  4.0           4.0
  1.0           1.0
  1.42674e-16   1.42674e-16
 -4.33469e-16  -4.33469e-16
  3.0           3.0
  3.1531e-18    3.1531e-18
 -2.26734e-18  -2.26734e-18</code></pre><h4 id="Convenience-Routine-for-Harmonic-Selection:-[HSEL](@ref)"><a class="docs-heading-anchor" href="#Convenience-Routine-for-Harmonic-Selection:-[HSEL](@ref)">Convenience Routine for Harmonic Selection: <a href="../reference/#juliajim.HARMONIC.HSEL"><code>HSEL</code></a></a><a id="Convenience-Routine-for-Harmonic-Selection:-[HSEL](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-Routine-for-Harmonic-Selection:-[HSEL](@ref)" title="Permalink"></a></h4><p>Since harmonic selection in the 2D (and general N-D) case is not as trivial as writing <code>0:3</code> for the 1D case (different combinations of the indices must be considered on the tensor-grid while accounting for redundancies. The convenience routine <a href="../reference/#juliajim.HARMONIC.HSEL"><code>HSEL</code></a> helps to do this - one can specify the maximum harmonic order (<code>Nhmax</code> below) and the number of components (<code>C</code> below) and obtain a (H\times C) matrix of indices.</p><pre><code class="language-julia hljs">C = 2;
Nhmax = 4;

h = HSEL(Nhmax, 1:C);  # Second argument is the list of frequencies
Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));</code></pre><h4 id="Convenient-Routine-for-Harmonic-Indices:-[HINDS](@ref)"><a class="docs-heading-anchor" href="#Convenient-Routine-for-Harmonic-Indices:-[HINDS](@ref)">Convenient Routine for Harmonic Indices: <a href="../reference/#juliajim.HARMONIC.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><code>HINDS</code></a></a><a id="Convenient-Routine-for-Harmonic-Indices:-[HINDS](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Convenient-Routine-for-Harmonic-Indices:-[HINDS](@ref)" title="Permalink"></a></h4><p>It is often necessary to also know the indices of the cosine and sine harmonics individually. The <a href="../reference/#juliajim.HARMONIC.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><code>HINDS</code></a> routine helps with this.</p><pre><code class="language-julia hljs">h = (0:4);
zinds, hinds, rinds0, rinds, iinds = HINDS(1, h)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([1], [2, 3, 4, 5], [1], [2, 4, 6, 8], [3, 5, 7, 9])</code></pre><p>Here, <code>zinds</code> and <code>hinds</code> store the indices that have to be used for a complex representation ((\begin{bmatrix} a<em>0&amp;a</em>1-ib<em>1&amp;a</em>2-ib_2&amp;\dots \end{bmatrix})) and <code>rinds0</code>, <code>rinds,</code> and <code>iinds</code> store the indices \hat{t} have to be used for the real Fourier coefficients representation. Specifically, <code>rinds0</code> are the indices for the zeroth harmonic, <code>rinds</code> are the indices for the cosine harmonics and <code>iinds</code> are the indices for the sine harmonics.</p><p>The routine can also be called when there are multiple Degrees-of-Freedom. See below for the case of 3 DoFs. This should also clarify the ordering convention used in this package.</p><pre><code class="language-julia hljs">h = (0:4);
zinds, hinds, rinds0, rinds, iinds = HINDS(3, h)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">([1, 2, 3], [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [1, 2, 3], [4, 5, 6, 10, 11, 12, 16, 17, 18, 22, 23, 24], [7, 8, 9, 13, 14, 15, 19, 20, 21, 25, 26, 27])</code></pre><p>Note that the routine also supports multi-frequency cases (<code>h</code> with multiple columns).</p><h2 id="The-&quot;Harmonic&quot;-Stiffness"><a class="docs-heading-anchor" href="#The-&quot;Harmonic&quot;-Stiffness">The &quot;Harmonic&quot; Stiffness</a><a id="The-&quot;Harmonic&quot;-Stiffness-1"></a><a class="docs-heading-anchor-permalink" href="#The-&quot;Harmonic&quot;-Stiffness" title="Permalink"></a></h2><p>Harmonic Balance is a numerical technique where the solution for a dynamical system (expressed in second order form) is expressed in terms of its Fourier series. The resulting algebraic system is solved numerically. For a linear system, however, the algebraic system can be simplified significantly and written in a succinct (\mx{E} \vc{u} = \vc{f}) form.</p><p>Consider a linear dynamical system with (n) Degrees-of-Freedom of the form:</p><p class="math-container">\[\mx{M} \ddot{\vc{x}} + \mx{C} \dot{\vc{x}} + \mx{K} \vc{x} = \vc{F}(t),\quad \vc{x}\in\mathbb{R}^n.\]</p><p>We expand out the vector of unknowns (\vc{x}) as</p><p class="math-container">\[\vc{x} = \vc{a}_0 + \sum_{n=1}^H \vc{a}_n \cos n\tau + \vc{b}_n \sin n\tau,\,\text{with } \vc{a}_i,\vc{b}_i\in \mathbb{R}^n,\]</p><p>and write the vector of harmonic coefficients (\vc{u}) as</p><p class="math-container">\[\vc{u} = \begin{bmatrix} \vc{a}_0\\ \vc{a}_1\\ \vc{b}_1\\ \vc{a}_2\\ \vc{b}_2\\ \vdots \end{bmatrix}.\]</p><p>Substituting the harmonic ansatz into the governing equations and projecting the resulting residue onto the Fourier basis functions leads to:</p><p class="math-container">\[\begin{bmatrix}
\mx{K} &amp; \\
&amp;\mx{K}-\Omega^2 \mx{M} &amp; \Omega \mx{C} &amp; \\
&amp;-\Omega \mx{C} &amp; \mx{K}-\Omega^2 \mx{M} \\
&amp;&amp;&amp;\mx{K}-(2\Omega)^2 \mx{M} &amp; (2\Omega) \mx{C}\\
&amp;&amp;&amp; -(2\Omega) \mx{C} &amp; \mx{K}-(2\Omega)^2 \mx{M} \\
&amp;&amp;&amp;&amp;&amp;\ddots&amp;&amp;&amp;&amp;
\end{bmatrix}
\begin{bmatrix} \vc{a}_0\\ \vc{a}_1\\ \vc{b}_1\\ \vc{a}_2\\ \vc{b}_2\\ \vdots \end{bmatrix} =
\begin{bmatrix} \vc{f}_{a0}\\ \vc{f}_{a1}\\ \vc{f}_{b1}\\ \vc{f}_{a2}\\ \vc{f}_{b2}\\ \vdots \end{bmatrix}.\]</p><p>The <a href="../reference/#juliajim.HARMONIC.HARMONICSTIFFNESS-NTuple{5, Any}"><code>HARMONICSTIFFNESS</code></a> function provides a convenience routine for just this. It works for arbitrary number of frequency components also. The usage is as follows. Since the frequency jacobian of this matrix is often necessary, this is also returned by the routine. There is also an in-place version of this in <a href="../reference/#juliajim.HARMONIC.HARMONICSTIFFNESS!-NTuple{7, Any}"><code>HARMONICSTIFFNESS!</code></a>.</p><pre><code class="language-julia hljs">M = I(2);
K = [2 -1;-1 2];
D = 0.001.*K + 0.01.*M;

C = 2;
Nhmax = 3;

h = HSEL(Nhmax, 1:C)
ws = [1, π];
ws = ws[1:C];

E, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);
E</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">46×46 SparseArrays.SparseMatrixCSC{Float64, Int64} with 180 stored entries:
⎡⠛⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎤
⎢⠀⠛⠛⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠛⠛⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠛⠛⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠛⠛⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⣤⣤⠀⠀⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⣤⣤⠀⠀⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⣤⣤⠀⠀⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⣤⣤⠀⠀⎥
⎢⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⣤⣤⎥
⎣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠛⎦</code></pre><h2 id="Forced-Response-Computation-with-[HARMONIC](@ref)"><a class="docs-heading-anchor" href="#Forced-Response-Computation-with-[HARMONIC](@ref)">Forced Response Computation with <a href="../reference/#juliajim.HARMONIC"><code>HARMONIC</code></a></a><a id="Forced-Response-Computation-with-[HARMONIC](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Forced-Response-Computation-with-[HARMONIC](@ref)" title="Permalink"></a></h2><p>We shall now use the above utilites to compute the forced response of a linear system. The code below should be self explanatory.</p><pre><code class="language-julia hljs">C = 1;
Nhmax = 3;

h = HSEL(Nhmax, 1:C);
Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));
Fl = zeros(Nhc, 1);
Fl[2] = 1.0;
Fl = kron(Fl, [1;0]);

Omr, V = eigen(K, collect(M));
Omr = sqrt.(Omr);

Ωs = LinRange(0.5, 2, 500);
As = zeros(ComplexF64, size(Ωs));

for i = eachindex(Ωs)
    local E, dEdw
    E, dEdw = HARMONICSTIFFNESS(M, D, K, [Ωs[i]], h);
    U = E\Fl;
    As[i] = U[3]+im*U[5];
end

set_theme!(theme_latexfonts())
fsz = 18;
fig = Figure(fontsize=fsz);

ax = Axis(fig[1, 1],
    xlabel=&quot;Excitation Frequency (rad/s)&quot;,
    ylabel=&quot;Response Amplitude (m)&quot;,
    xscale=Makie.pseudolog10,
    yscale=Makie.pseudolog10);
lines!(ax, Ωs, abs.(As))

    fig</code></pre><img src="077ee9eb.png" alt="Example block output"/><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a><a class="docs-footer-nextpage" href="../b1_duffhb/">1: Duffing Oscillator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 28 September 2025 08:28">Sunday 28 September 2025</span>. Using Julia version 1.11.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
