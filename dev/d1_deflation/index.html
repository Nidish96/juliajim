<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>1: Deflation to Locate Multiple roots · juliajim</title><meta name="title" content="1: Deflation to Locate Multiple roots · juliajim"/><meta property="og:title" content="1: Deflation to Locate Multiple roots · juliajim"/><meta property="twitter:title" content="1: Deflation to Locate Multiple roots · juliajim"/><meta name="description" content="Documentation for juliajim."/><meta property="og:description" content="Documentation for juliajim."/><meta property="twitter:description" content="Documentation for juliajim."/><meta property="og:url" content="https://github.com/Nidish96/juliajim/d1_deflation/"/><meta property="twitter:url" content="https://github.com/Nidish96/juliajim/d1_deflation/"/><link rel="canonical" href="https://github.com/Nidish96/juliajim/d1_deflation/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">juliajim</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../a_hworld/">A: Harmonic Utilities</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">B: Numerical Continuation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../b1_duffhb/">1: Duffing Oscillator</a></li><li><a class="tocitem" href="../b2_jenkhb/">2: Frictional Oscillator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">C: Examples with the MDOFUTILS Suite</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../c1_mdofgen_instnl/">1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity</a></li><li><a class="tocitem" href="../c2_mdofgen_hystnl/">2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity</a></li><li><a class="tocitem" href="../c3_mdofgen_ahb/">3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator</a></li><li><a class="tocitem" href="../c4_mdofgen_epmc/">4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC</a></li><li><a class="tocitem" href="../c5_mdofgen_newmark/">5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox" checked/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">D: Bifurcation Analysis Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>1: Deflation to Locate Multiple roots</a><ul class="internal"><li><a class="tocitem" href="#ex_d1"><span>Example D1: Deflation to Locate Multiple roots</span></a></li><li><a class="tocitem" href="#Load-Packages"><span>Load Packages</span></a></li><li><a class="tocitem" href="#Setup-Residue-function"><span>Setup Residue function</span></a></li><li><a class="tocitem" href="#Obtain-the-first-solution"><span>Obtain the first solution</span></a></li><li><a class="tocitem" href="#Deflated-Solution"><span>Deflated Solution</span></a></li><li><a class="tocitem" href="#Adding-multiple-deflators"><span>Adding multiple deflators</span></a></li><li><a class="tocitem" href="#What-if-we-kept-going?"><span>What if we kept going?</span></a></li></ul></li><li><a class="tocitem" href="../d2_forcedvdp/">2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator</a></li><li><a class="tocitem" href="../d3_normalform/">3: Branch Switching Using Normal Forms</a></li></ul></li><li><a class="tocitem" href="../e_febeam/">E: Finite Element Beam with Nonlinear Support</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li><a class="is-disabled">D: Bifurcation Analysis Examples</a></li><li class="is-active"><a href>1: Deflation to Locate Multiple roots</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>1: Deflation to Locate Multiple roots</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nidish96/juliajim/blob/master/examples/d1_deflation.jl#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h2 id="ex_d1"><a class="docs-heading-anchor" href="#ex_d1">Example D1: Deflation to Locate Multiple roots</a><a id="ex_d1-1"></a><a class="docs-heading-anchor-permalink" href="#ex_d1" title="Permalink"></a></h2><p>It is sometimes the case that we are trying to solve for the solution of a system of equations that has multiple zeros where one is (or a few are) already known. Case in point in dynamical systems: computing bifurcated branches emanating from a &quot;main&quot; branch of solutions.</p><p>We use the method of deflation to discourage the solver from converging to the previously known solution(s) by penalizing the residue by the distance to that solution. Let us suppose that <span>$u_0$</span> is the previously known solution point and <span>$R(u)$</span> is the residue function that needs to be solved (<span>$u\in \mathbb{R}^n$</span>, <span>$R: \mathbb{R}\to \mathbb{R}$</span>). We write the deflated residue</p><p class="math-container">\[R_d(u) = \frac{1}{||u-u_0||_2^2} R(u),\]</p><p>where <span>$||x||_2$</span> denotes the 2-norm. The limit <span>$u\to u_0$</span> may or may not exist for <span>$R_d(u)$</span> based on the speed at which <span>$R(u)$</span> goes to zero at <span>$u_0$</span>, and this may affect the behavior of <span>$R_d(u)$</span>. Notwithstanding this, we find using the 2-norm as above to be quite effective for most problems.</p><p class="math-container">\[R_d(u)\]</p><p>discourages the solver from approaching the known solution <span>$u_0$</span>, allowing us to converge to another solution if it exists and if our initial guess is close enough.</p><p><a href="../reference/#juliajim.juliajim"><code>juliajim</code></a> implements <a href="../reference/#juliajim.MDOFUTILS.DEFLATEDRES!-Tuple{Any, Any, Any}"><code>DEFLATEDRES!</code></a> which is a deflation wrapper routine that can be used on top of any existing residue function to achieve deflation.</p><p>This example demonstrates this through a simple 2-state system of polynomial equations with two known roots:</p><p class="math-container">\[R(u; p) = \begin{bmatrix} u_2\\-p u_1-u_2+\frac{u_1^3}{4} \end{bmatrix},\]</p><p>which is solved by <span>$(u_1,u_2)=(-2\sqrt{p},0), (0,0), (2\sqrt{p},0)$</span>.</p><h2 id="Load-Packages"><a class="docs-heading-anchor" href="#Load-Packages">Load Packages</a><a id="Load-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Load-Packages" title="Permalink"></a></h2><pre><code class="language-julia hljs">using NonlinearSolve
using LinearAlgebra

using juliajim.MDOFUTILS</code></pre><h2 id="Setup-Residue-function"><a class="docs-heading-anchor" href="#Setup-Residue-function">Setup Residue function</a><a id="Setup-Residue-function-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-Residue-function" title="Permalink"></a></h2><pre><code class="language-julia hljs">function fres!(up, r=nothing, j=nothing, jp=nothing)
    if !(r === nothing)
        r[:] = [up[2];-up[3]*up[1]-up[2]+up[1]^3/4];
    end
    if !(j === nothing)
        j[:, :] = [0 1;-up[3]+3up[1]^2/4 -1];
    end
    if !(jp === nothing)
        jp[:] = [0;-1];
    end
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">fres! (generic function with 4 methods)</code></pre><h2 id="Obtain-the-first-solution"><a class="docs-heading-anchor" href="#Obtain-the-first-solution">Obtain the first solution</a><a id="Obtain-the-first-solution-1"></a><a class="docs-heading-anchor-permalink" href="#Obtain-the-first-solution" title="Permalink"></a></h2><pre><code class="language-julia hljs">par = 3.0;
u0 = [3.0,0];

fun1 = NonlinearFunction((r,u,p)-&gt;fres!([u;p], r),
    jac=(J,u,p)-&gt;fres!([u;p], nothing,J),
    paramjac=(Jp,u,p)-&gt;fres!([u;p], nothing,nothing,Jp));
prob1 = NonlinearProblem(fun1, u0, par);
sol1 = solve(prob1, show_trace=Val(true));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Algorithm: NewtonRaphson(
    descent = NewtonDescent(),
    autodiff = AutoForwardDiff(),
    vjp_autodiff = AutoFiniteDiff(
        fdtype = Val{:forward}(),
        fdjtype = Val{:forward}(),
        fdhtype = Val{:hcentral}(),
        dir = true
    ),
    jvp_autodiff = AutoForwardDiff(),
    concrete_jac = Val{false}()
)

----    	-------------       	-----------
Iter    	f(u) inf-norm       	Step 2-norm
----    	-------------       	-----------
0       	2.25000000e+00      	0.00000000e+00
1       	8.64000000e-01      	6.00000000e-01
2       	4.41013120e-02      	1.28571429e-01
3       	1.38792329e-04      	7.30382447e-03
4       	1.39016088e-09      	2.31315914e-05
5       	1.77635684e-15      	2.31693479e-10
Final   	1.77635684e-15
----------------------</code></pre><p>This returns the solution</p><pre><code class="language-julia hljs">sol1</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 3.464101615137755
 0.0</code></pre><p>which is exactly <span>$(2\sqrt{p},0)$</span> as expected.</p><h2 id="Deflated-Solution"><a class="docs-heading-anchor" href="#Deflated-Solution">Deflated Solution</a><a id="Deflated-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Deflated-Solution" title="Permalink"></a></h2><pre><code class="language-julia hljs">uC = [sol1.u; par];

fun2 = NonlinearFunction((r,u,p)-&gt; DEFLATEDRES!([u;p], uC, fres!; R=r),
    jac=(J,u,p)-&gt; DEFLATEDRES!([u;p], uC, fres!; J=J),
    paramjac=(Jp,u,p)-&gt; DEFLATEDRES!([u;p], uC, fres!; Jp=Jp));
prob2 = NonlinearProblem(fun2, u0, par);
sol2 = solve(prob2, show_trace=Val(true));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Algorithm: NewtonRaphson(
    descent = NewtonDescent(),
    autodiff = AutoForwardDiff(),
    vjp_autodiff = AutoFiniteDiff(
        fdtype = Val{:forward}(),
        fdjtype = Val{:forward}(),
        fdhtype = Val{:hcentral}(),
        dir = true
    ),
    jvp_autodiff = AutoForwardDiff(),
    concrete_jac = Val{false}()
)

----    	-------------       	-----------
Iter    	f(u) inf-norm       	Step 2-norm
----    	-------------       	-----------
0       	1.04461524e+01      	0.00000000e+00
1       	4.73423048e+00      	3.78395951e-01
2       	1.98329177e+00      	5.77129827e-01
3       	7.33414117e-01      	7.27236432e-01
4       	2.22548715e-01      	6.97298275e-01
5       	4.60853796e-02      	4.52588317e-01
6       	3.72572734e-03      	1.52574887e-01
7       	3.12508123e-05      	1.46513168e-02
8       	2.25490352e-09      	1.24985209e-04
9       	1.17423574e-17      	9.01961399e-09
Final   	1.17423574e-17
----------------------</code></pre><p>This returns the trivial solution <span>$(0,0)$</span> for the above initial guess:</p><pre><code class="language-julia hljs">sol2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 4.6969429454406597e-17
 0.0</code></pre><h2 id="Adding-multiple-deflators"><a class="docs-heading-anchor" href="#Adding-multiple-deflators">Adding multiple deflators</a><a id="Adding-multiple-deflators-1"></a><a class="docs-heading-anchor-permalink" href="#Adding-multiple-deflators" title="Permalink"></a></h2><p><a href="../reference/#juliajim.MDOFUTILS.DEFLATEDRES!-Tuple{Any, Any, Any}"><code>DEFLATEDRES!</code></a> allows specifying multiple solutions (in a list) for deflation. Let us specify both the solutions found above.</p><pre><code class="language-julia hljs">uCs = [[sol1.u;par], [sol2.u;par]];

fun3 = NonlinearFunction((r,u,p)-&gt; DEFLATEDRES!([u;p], uCs, fres!, R=r),
    jac=(J,u,p)-&gt; DEFLATEDRES!([u;p], uCs, fres!, J=J),
    paramjac=(Jp,u,p)-&gt; DEFLATEDRES!([u;p], uCs, fres!, J=J));
prob3 = NonlinearProblem(fun3, u0, par);
sol3 = solve(prob3, show_trace=Val(true));</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">
Algorithm: NewtonRaphson(
    descent = NewtonDescent(),
    autodiff = AutoForwardDiff(),
    vjp_autodiff = AutoFiniteDiff(
        fdtype = Val{:forward}(),
        fdjtype = Val{:forward}(),
        fdhtype = Val{:hcentral}(),
        dir = true
    ),
    jvp_autodiff = AutoForwardDiff(),
    concrete_jac = Val{false}()
)

----    	-------------       	-----------
Iter    	f(u) inf-norm       	Step 2-norm
----    	-------------       	-----------
0       	1.06961524e+01      	0.00000000e+00
1       	5.09526538e+00      	3.95815545e-01
2       	2.72599526e+00      	7.10468839e-01
3       	5.01974668e+00      	2.48624726e+00
4       	2.41439058e+00      	5.78303591e-01
5       	9.61732005e-01      	1.00218788e+00
6       	1.76376748e-01      	1.01608731e+00
7       	4.70383197e-03      	2.67469974e-01
8       	3.07342153e-06      	7.51630224e-03
9       	1.30876791e-12      	4.91747026e-06
10      	1.85037171e-16      	2.09402865e-12
Final   	1.85037171e-16
----------------------</code></pre><p>Now we recover the solution <span>$(-2\sqrt{p},0)$</span>!</p><pre><code class="language-julia hljs">sol3</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
u: 2-element Vector{Float64}:
 -3.4641016151377544
  0.0</code></pre><p>Now isn&#39;t that cool? We&#39;ve used exactly the same initial guess and have progressively recovered all the solutions of the system.</p><h2 id="What-if-we-kept-going?"><a class="docs-heading-anchor" href="#What-if-we-kept-going?">What if we kept going?</a><a id="What-if-we-kept-going?-1"></a><a class="docs-heading-anchor-permalink" href="#What-if-we-kept-going?" title="Permalink"></a></h2><p>In the practical setting we are sometimes not destined to know a priori how many solutions to expect. So let us keep going to see what happens.</p><pre><code class="language-julia hljs">uCs = [[s.u;par] for s in [sol1,sol2,sol3]];
fun4 = NonlinearFunction((r,u,p)-&gt; DEFLATEDRES!([u;p], uCs, fres!, R=r),
    jac=(J,u,p)-&gt; DEFLATEDRES!([u;p], uCs, fres!, J=J),
    paramjac=(Jp,u,p)-&gt; DEFLATEDRES!([u;p], uCs, fres!, J=J));
prob4 = NonlinearProblem(fun4, u0, par);
sol4 = solve(prob4, show_trace=Val(true))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Stalled
u: 2-element Vector{Float64}:
 -24810.65311212503
     -3.81241509304851e12</code></pre><p>NonlinearSolve will try out its list of methods and then finally get stalled. While this implies the absence of another solution in this case (because we know this), in the general case this merely implies the absence of another solution in the basin of attraction of the provided initial guess. The general problem of numerically eliminating possible solutions is quite complex!</p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../c5_mdofgen_newmark/">« 5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme</a><a class="docs-footer-nextpage" href="../d2_forcedvdp/">2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 10 January 2026 10:53">Saturday 10 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
