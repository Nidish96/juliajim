<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · juliajim</title><meta name="title" content="Reference · juliajim"/><meta property="og:title" content="Reference · juliajim"/><meta property="twitter:title" content="Reference · juliajim"/><meta name="description" content="Documentation for juliajim."/><meta property="og:description" content="Documentation for juliajim."/><meta property="twitter:description" content="Documentation for juliajim."/><meta property="og:url" content="https://github.com/Nidish96/juliajim/reference/"/><meta property="twitter:url" content="https://github.com/Nidish96/juliajim/reference/"/><link rel="canonical" href="https://github.com/Nidish96/juliajim/reference/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">juliajim</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../a_hworld/">A: Harmonic Utilities</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">B: Numerical Continuation</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../b1_duffhb/">1: Duffing Oscillator</a></li><li><a class="tocitem" href="../b2_jenkhb/">2: Frictional Oscillator</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">C: Examples with the MDOFUTILS Suite</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../c1_mdofgen_instnl/">1: Forced Response of a 2DoF Oscillator with Instantaneous Nonlinearity</a></li><li><a class="tocitem" href="../c2_mdofgen_hystnl/">2: Forced Response of a 2DoF Oscillator with Hysteretic Nonlinearity</a></li><li><a class="tocitem" href="../c3_mdofgen_ahb/">3: Response Constrained Forced Response of a 2DoF Hysteretic Oscillator</a></li><li><a class="tocitem" href="../c4_mdofgen_epmc/">4: Nonlinear Normal Modes of a 2DoF Hysteretic Oscillator using EPMC</a></li><li><a class="tocitem" href="../c5_mdofgen_newmark/">5: Transient Response of a 2DoF Hysteretic Oscillator using Newmark Scheme</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">D: Bifurcation Analysis Examples</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../d1_deflation/">1: Deflation to Locate Multiple roots</a></li><li><a class="tocitem" href="../d2_forcedvdp/">2: Bifurcation Analysis of the Forced Response of a Van der Pol Oscillator</a></li><li><a class="tocitem" href="../d3_normalform/">3: Branch Switching Using Normal Forms</a></li></ul></li><li><a class="tocitem" href="../e_febeam/">E: Finite Element Beam with Nonlinear Support</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Examples</a></li><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/Nidish96/juliajim/blob/master/docs/src/reference.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Reference">Reference</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Index">Index</a></li></ul></li></ul><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#juliajim.CONTINUATION"><code>juliajim.CONTINUATION</code></a></li><li><a href="#juliajim.HARMONIC"><code>juliajim.HARMONIC</code></a></li><li><a href="#juliajim.MDOFUTILS"><code>juliajim.MDOFUTILS</code></a></li><li><a href="#juliajim.NLDYN"><code>juliajim.NLDYN</code></a></li><li><a href="#juliajim.juliajim"><code>juliajim.juliajim</code></a></li><li><a href="#juliajim.CONTINUATION.myNLSoln"><code>juliajim.CONTINUATION.myNLSoln</code></a></li><li><a href="#juliajim.CONTINUATION.myNLSoln"><code>juliajim.CONTINUATION.myNLSoln</code></a></li><li><a href="#juliajim.MDOFUTILS.MDOFGEN"><code>juliajim.MDOFUTILS.MDOFGEN</code></a></li><li><a href="#juliajim.MDOFUTILS.NONLINEARITY"><code>juliajim.MDOFUTILS.NONLINEARITY</code></a></li><li><a href="#Base.:--Tuple{myNLSoln, myNLSoln}"><code>Base.:-</code></a></li><li><a href="#Base.getproperty-Tuple{Vector{myNLSoln}, Symbol}"><code>Base.getproperty</code></a></li><li><a href="#Base.getproperty-Tuple{myNLSoln, Symbol}"><code>Base.getproperty</code></a></li><li><a href="#Base.show-Tuple{IO, myNLSoln}"><code>Base.show</code></a></li><li><a href="#juliajim.CONTINUATION.CONTINUATE-Tuple{Vector{Float64}, Any, Vector{Float64}, Float64}"><code>juliajim.CONTINUATION.CONTINUATE</code></a></li><li><a href="#juliajim.CONTINUATION.EXTRESFUN!-NTuple{4, Any}"><code>juliajim.CONTINUATION.EXTRESFUN!</code></a></li><li><a href="#juliajim.HARMONIC.ACT-NTuple{4, Any}"><code>juliajim.HARMONIC.ACT</code></a></li><li><a href="#juliajim.HARMONIC.AFT-NTuple{4, Any}"><code>juliajim.HARMONIC.AFT</code></a></li><li><a href="#juliajim.HARMONIC.DCHEB-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><code>juliajim.HARMONIC.DCHEB</code></a></li><li><a href="#juliajim.HARMONIC.DFOUR"><code>juliajim.HARMONIC.DFOUR</code></a></li><li><a href="#juliajim.HARMONIC.DFOUR!"><code>juliajim.HARMONIC.DFOUR!</code></a></li><li><a href="#juliajim.HARMONIC.FSEVAL"><code>juliajim.HARMONIC.FSEVAL</code></a></li><li><a href="#juliajim.HARMONIC.HARMONICSTIFFNESS-NTuple{5, Any}"><code>juliajim.HARMONIC.HARMONICSTIFFNESS</code></a></li><li><a href="#juliajim.HARMONIC.HARMONICSTIFFNESS!-NTuple{7, Any}"><code>juliajim.HARMONIC.HARMONICSTIFFNESS!</code></a></li><li><a href="#juliajim.HARMONIC.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><code>juliajim.HARMONIC.HINDS</code></a></li><li><a href="#juliajim.HARMONIC.HSEL"><code>juliajim.HARMONIC.HSEL</code></a></li><li><a href="#juliajim.HARMONIC.NHC-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><code>juliajim.HARMONIC.NHC</code></a></li><li><a href="#juliajim.HARMONIC.PRODMAT_CHEB"><code>juliajim.HARMONIC.PRODMAT_CHEB</code></a></li><li><a href="#juliajim.HARMONIC.PRODMAT_FOUR"><code>juliajim.HARMONIC.PRODMAT_FOUR</code></a></li><li><a href="#juliajim.MDOFUTILS.ADDNL"><code>juliajim.MDOFUTILS.ADDNL</code></a></li><li><a href="#juliajim.MDOFUTILS.DEFLATEDRES!-Tuple{Any, Any, Any}"><code>juliajim.MDOFUTILS.DEFLATEDRES!</code></a></li><li><a href="#juliajim.MDOFUTILS.EPMCRESFUN!-Tuple{Any, MDOFGEN, Any, Any, Int64}"><code>juliajim.MDOFUTILS.EPMCRESFUN!</code></a></li><li><a href="#juliajim.MDOFUTILS.HBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}"><code>juliajim.MDOFUTILS.HBRESFUN!</code></a></li><li><a href="#juliajim.MDOFUTILS.HBRESFUN_A!-Tuple{Any, MDOFGEN, Float64, Any, Any, Int64}"><code>juliajim.MDOFUTILS.HBRESFUN_A!</code></a></li><li><a href="#juliajim.MDOFUTILS.NEWMARKMARCH-Tuple{MDOFGEN, Vararg{Any, 6}}"><code>juliajim.MDOFUTILS.NEWMARKMARCH</code></a></li><li><a href="#juliajim.MDOFUTILS.NLEVAL!-Tuple{Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, MDOFGEN, Any, Int64}"><code>juliajim.MDOFUTILS.NLEVAL!</code></a></li><li><a href="#juliajim.MDOFUTILS.NLFORCE-Tuple{MDOFGEN, Any, Any, Any}"><code>juliajim.MDOFUTILS.NLFORCE</code></a></li><li><a href="#juliajim.MDOFUTILS.QPHBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}"><code>juliajim.MDOFUTILS.QPHBRESFUN!</code></a></li><li><a href="#juliajim.NLDYN.NORMALFORMFIT-Tuple{Any, Any, Any}"><code>juliajim.NLDYN.NORMALFORMFIT</code></a></li></ul><h3 id="Main-Module"><a class="docs-heading-anchor" href="#Main-Module">Main Module</a><a id="Main-Module-1"></a><a class="docs-heading-anchor-permalink" href="#Main-Module" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="juliajim.juliajim"><a class="docstring-binding" href="#juliajim.juliajim"><code>juliajim.juliajim</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>The main juliajim module</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/juliajim.jl#L1">source</a></section></details></article><h3 id="Module-Harmonic"><a class="docs-heading-anchor" href="#Module-Harmonic">Module Harmonic</a><a id="Module-Harmonic-1"></a><a class="docs-heading-anchor-permalink" href="#Module-Harmonic" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC"><a class="docstring-binding" href="#juliajim.HARMONIC"><code>juliajim.HARMONIC</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Useful routines for Harmonic Balance. Also includes Chebyshev Galerkin utilites.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/juliajim.jl#L4">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.ACT-NTuple{4, Any}"><a class="docstring-binding" href="#juliajim.HARMONIC.ACT-NTuple{4, Any}"><code>juliajim.HARMONIC.ACT</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>ACT(yin, h::hTypes, N::Int64, dir::Symbol)</p><p>Routine for the alternating Chebyshev Transform. Uses AFT internally. </p><p><strong>Arguments</strong></p><ul><li>yin              : </li><li>h::hTypes : </li><li>N::Int64         : </li><li>dir::Symbol      : </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L532-L542">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.AFT-NTuple{4, Any}"><a class="docstring-binding" href="#juliajim.HARMONIC.AFT-NTuple{4, Any}"><code>juliajim.HARMONIC.AFT</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">AFT(yin, h::hTypes, N::Int64, dir::Symbol);</code></pre><p>Routine to conduct Time-to-Frequency and Frequency-to-Time transforms for the general Multi frequency case.</p><p><strong>Arguments</strong></p><ul><li><code>yin::VecOrMat{Float64}</code>: (N^C, Ny) if time data, and (Nhc, Ny) if frequency data.</li><li><code>h::hTypes</code>: (Nh, C) list of harmonics.</li><li><code>N::Int64</code>: Number of time samples for AFT.</li><li><code>dir::Symbol</code>: :t2f for time-to-frequency, and :f2t for frequency-to-time.</li></ul><p><strong>Examples</strong></p><ul><li>Single Frequency Case:</li></ul><pre><code class="language-julia-repl hljs">    N = 8;
    t = (0:N-1)*2π/N;
    yt = cos.(t) + 3sin.(2t) .+ 4;
    yt = [yt yt];

    h = collect(0:3)[:,:];
    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));

    yf = AFT(yt, h, N, :t2f);
    YT = AFT(yf, h, N, :f2t);</code></pre><ul><li>2-Frequency Case:</li></ul><pre><code class="language-julia-repl hljs">    t1 = repeat(t, 1, N);
    t2 = repeat(t&#39;, N, 1);

    yt = cos.(t1) + 3sin.(t2) .+ 4;
    h = [0 0;1 0;0 1;1 1];
    Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));

    yf = AFT([yt[:] yt[:]], h, N, :t2f);
    YT = AFT(yf, h, N, :f2t);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L38-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.DCHEB-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><a class="docstring-binding" href="#juliajim.HARMONIC.DCHEB-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><code>juliajim.HARMONIC.DCHEB</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>DCHEB(h::hTypes)</p><p>Returns the Chebyshev Differentiation matrix.</p><p><strong>Arguments</strong></p><ul><li>h::hTypes : </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L587-L594">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.DFOUR"><a class="docstring-binding" href="#juliajim.HARMONIC.DFOUR"><code>juliajim.HARMONIC.DFOUR</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>DFOUR(h::hTypes, ws=nothing)</p><p>Returns the Fourier differentiation matrix (useful for HB representations).</p><p><strong>Arguments</strong></p><ul><li>h::hTypes : (H, C) Harmonic indices</li><li>ws::Array{Float64} : (C, 1) (optional) list of frequencies</li></ul><p><strong>Outputs</strong></p><ul><li><code>D</code> : (Nhc, Nhc) Harmonic differentiation matrix</li><li><code>dDdw</code> : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L393-L404">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.DFOUR!"><a class="docstring-binding" href="#juliajim.HARMONIC.DFOUR!"><code>juliajim.HARMONIC.DFOUR!</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>DFOUR!(h::hTypes, D, dDdw=nothing, ws=nothing)</p><p>Bang version of DFOUR.</p><p><strong>Arguments</strong></p><ul><li>h::hTypes : (H, C) Harmonic indices</li><li><code>D</code> : (Nhc, Nhc) Harmonic differentiation matrix</li><li><code>dDdw</code> : (Nhc, Nhc) Harmonic differentiation matrix (derivative wrt ws).</li><li>ws::Array{Float64} : (C, 1) (optional) list of frequencies</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L423-L433">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.FSEVAL"><a class="docstring-binding" href="#juliajim.HARMONIC.FSEVAL"><code>juliajim.HARMONIC.FSEVAL</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>FSEVAL(h::hTypes, t::Union{StepRangeLen{Float64}, VecOrMat{Float64}}, U::Union{Nothing,Matrix{Float64}}=nothing)</p><p><strong>Description</strong></p><p>Evaluates the Fourier series at required time points. If Fourier coefficients are not provided, it returns the mapping matrix.</p><p><strong>Arguments</strong></p><ul><li>h::hTypes                      : </li><li>t::Union{StepRangeLen{Float64} : </li><li>VecOrMat{Float64}}             : </li><li>U::Union{Nothing               : </li><li>Matrix{Float64}}               : (default nothing)</li></ul><p><strong>Outputs</strong></p><ul><li>ut	: In case U is provided, this is outputted first.</li><li>J	: The mapping matrix such that J*U gives the desired temporal evaluates.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L178-L194">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.HARMONICSTIFFNESS!-NTuple{7, Any}"><a class="docstring-binding" href="#juliajim.HARMONIC.HARMONICSTIFFNESS!-NTuple{7, Any}"><code>juliajim.HARMONIC.HARMONICSTIFFNESS!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h)

Bang version of HARMONICSTIFFNESS (preallocate E, dEdw).
Advantage is that nothing can be passed to avoid needless computations.</code></pre><p><strong>Arguments</strong></p><ul><li><code>E</code>: (Nd<em>Nhc, Nd</em>Nhc) Harmonic Stiffness</li><li><code>dEdw</code>: C-Vector of (Nd<em>Nhc, Nd</em>Nhc) Representing Frequency-gradients of E</li><li>&#39;M, D, K&#39;: (Nd,Nd) Mass, Damping, Stiffness Matrices.</li><li>&#39;ws::Array{Float64}&#39;: (C,1) list of frequencies</li><li>&#39;h&#39;: (H, C) harmonic indices</li></ul><p><strong>Examples</strong></p><ul><li>Single Frequency Case</li></ul><pre><code class="language-julia-repl hljs">M = I(2);
K = [2 -1;-1 2];
D = 0.001.*K + 0.01.*M;

h = [0;1;2;3];
Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));
E = zeros(2*Nhc, 2*Nhc);
dEdw = zeros(2*Nhc, 2*Nhc);
ws = 1;
HARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);</code></pre><ul><li>2-Frequency Case</li></ul><pre><code class="language-julia-repl hljs">Nhmax = 3;
ws = [1; π];
h = HSEL(Nhmax, ws);
Nhc = sum(all(h.==0, dims=2) + 2*any(h .!= 0, dims=2));
E = zeros(2*Nhc, 2*Nhc);
dEdw = zeros(2*Nhc, 2*Nhc);
HARMONICSTIFFNESS!(E, dEdw, M, D, K, ws, h);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L291-L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.HARMONICSTIFFNESS-NTuple{5, Any}"><a class="docstring-binding" href="#juliajim.HARMONIC.HARMONICSTIFFNESS-NTuple{5, Any}"><code>juliajim.HARMONIC.HARMONICSTIFFNESS</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">HARMONICSTIFFNESS(M, D, K, ws::Array{Float64}, h)

Computes the harmonic stiffness for HB simulations.</code></pre><p><strong>Arguments</strong></p><ul><li>&#39;M, D, K&#39;: (Nd,Nd) Mass, Damping, Stiffness Matrices.</li><li>&#39;ws::Array{Float64}&#39;: (C,1) list of frequencies</li><li>&#39;h&#39;: (H, C) harmonic indices</li></ul><p><strong>Outputs</strong></p><ul><li><code>E</code>: (Nd<em>Nhc, Nd</em>Nhc) Harmonic Stiffness</li><li><code>dEdw</code>: C-Vector of (Nd<em>Nhc, Nd</em>Nhc) Representing Frequency-gradients of E</li></ul><p><strong>Examples</strong></p><ul><li>Single Frequency Case</li></ul><pre><code class="language-julia-repl hljs">M = I(2);
K = [2 -1;-1 2];
D = 0.001.*K + 0.01.*M;

h = [0;1;2;3];
ws = 1;
E, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);</code></pre><ul><li>2-Frequency Case</li></ul><pre><code class="language-julia-repl hljs">Nhmax = 3;
ws = [1; π];
h = HSEL(Nhmax, ws);
E, dEdw = HARMONICSTIFFNESS(M, D, K, ws, h);</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L229-L259">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><a class="docstring-binding" href="#juliajim.HARMONIC.HINDS-Tuple{Int64, Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><code>juliajim.HARMONIC.HINDS</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>HINDS(Ndofs::Int64, h::hTypes)</p><p><strong>Arguments</strong></p><ul><li>Ndofs::Int64     : </li><li>h::hTypes :</li></ul><p><strong>Outputs</strong></p><ul><li>zinds</li><li>hinds</li><li>rinds0</li><li>rinds</li><li>iinds</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L357-L369">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.HSEL"><a class="docstring-binding" href="#juliajim.HARMONIC.HSEL"><code>juliajim.HARMONIC.HSEL</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">HSEL(Nhmax::Int64, ws::Any=1, hcr::Int=1)</code></pre><p>Selection of Harmonic indices based on different criteria. First C+1 rows are [zeros(1,C); I(C)].</p><p>Implemented criteria are,</p><ul><li><code>hcr=1</code>: Σᵢ |hᵢ| &lt; Nhmax &amp; ∑ᵢ h_i ≥ 0</li></ul><p><strong>Arguments</strong></p><ul><li><code>Nhmax::Int64</code>: Max harmonic for truncation.</li><li><code>ws=1</code>: [opt] List of frequencies</li><li><code>hcr::Int=1</code>: [opt] Truncation criterion. See above.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">C = 2;
Nhmax = 3;

h = HSEL(Nhmax, 1:C)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L129-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.NHC-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><a class="docstring-binding" href="#juliajim.HARMONIC.NHC-Tuple{Union{Int64, AbstractRange{Int64}, VecOrMat{Int64}}}"><code>juliajim.HARMONIC.NHC</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">NHC(h::hTypes)</code></pre><p>Returns the number of harmonics in a chosen harmonic set h. </p><p><strong>Arguments</strong></p><ul><li>h::hTypes : </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L20-L27">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.PRODMAT_CHEB"><a class="docstring-binding" href="#juliajim.HARMONIC.PRODMAT_CHEB"><code>juliajim.HARMONIC.PRODMAT_CHEB</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><strong>Description</strong></p><p><strong>Arguments</strong></p><ul><li>U    : </li><li>h    : </li><li>Hmax : (default nothing)</li><li>D    : (default nonothing)</li><li>L    : (default nonothing)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L616-L625">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.HARMONIC.PRODMAT_FOUR"><a class="docstring-binding" href="#juliajim.HARMONIC.PRODMAT_FOUR"><code>juliajim.HARMONIC.PRODMAT_FOUR</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>PRODMAT_FOUR(U::VecOrMat{Float64}, h::hTypes, Hmax=nothing, D=nothing, L=nothing)</p><p><strong>Description</strong></p><p>Returns the Fourier product matrix. Currently only implemented for C=1.</p><p><strong>Arguments</strong></p><ul><li>U::VecOrMat{Float64}		: </li><li>h::hTypes    			: </li><li>Hmax 				: (default nothing)</li><li>D    				: (default nothing)</li><li>Lb   				: (default nothing)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/HARMONIC.jl#L457-L468">source</a></section></details></article><h3 id="Module-CONTINUATION"><a class="docs-heading-anchor" href="#Module-CONTINUATION">Module CONTINUATION</a><a id="Module-CONTINUATION-1"></a><a class="docs-heading-anchor-permalink" href="#Module-CONTINUATION" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="juliajim.CONTINUATION"><a class="docstring-binding" href="#juliajim.CONTINUATION"><code>juliajim.CONTINUATION</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Useful types and routines for numerical continuation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/juliajim.jl#L9">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.CONTINUATION.myNLSoln"><a class="docstring-binding" href="#juliajim.CONTINUATION.myNLSoln"><code>juliajim.CONTINUATION.myNLSoln</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>myNLSoln(up::nvTypes=nothing; J::nmTypes=nothing, Jp::nvTypes=nothing)</p><p>Constructor for myNLSoln. Can specify one or all the arguments (point, jacobian, paramjac).</p><p><strong>Arguments</strong></p><ul><li><code>up::nvTypes</code>       : (default nothing) Solution point</li><li><code>J::nmTypes</code>        : (default nothing) Jacobian</li><li><code>Jp::nvTypes</code>       : (default nothing) paramjac</li><li><code>save_jacs::Bool</code>   : (default false) Whether or not to store the Jacobians.</li></ul><p>If both J and Jp are provided, the unit tangent dupds is computed using <code>nullspace([J Jp])[:,1]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/CONTINUATION.jl#L38-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.CONTINUATION.myNLSoln"><a class="docstring-binding" href="#juliajim.CONTINUATION.myNLSoln"><code>juliajim.CONTINUATION.myNLSoln</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>myNLSoln</p><p>Struct storing the solution, Jacobian, and (unit) tangent.</p><p><strong>Fields</strong></p><ul><li><code>up::nvTypes</code>: Solution point ([u;p])</li><li><code>J::nmTypes</code>: Jacobian dr/du</li><li><code>Jp::nvTypes</code>: Parameter Jacobian dr/dp</li><li><code>dupds::nvTypes</code>: Tangent vector (has to be vector only)  </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/CONTINUATION.jl#L20-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.:--Tuple{myNLSoln, myNLSoln}"><a class="docstring-binding" href="#Base.:--Tuple{myNLSoln, myNLSoln}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Base.:-(v1::myNLSoln, v2::myNLSoln)</p><p>Overloading the subtraction operator to take the difference between two myNLSoln </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/CONTINUATION.jl#L76-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getproperty-Tuple{Vector{myNLSoln}, Symbol}"><a class="docstring-binding" href="#Base.getproperty-Tuple{Vector{myNLSoln}, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Base.getproperty(sols::Vector{myNLSoln}, sym::Symbol)</strong></p><p>This will allow accessing elements of myNLSoln from vectors of structs.</p><p><strong>Arguments</strong></p><ul><li>sols::Vector{myNLSoln} : </li><li>sym::Symbol            : </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/CONTINUATION.jl#L125-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.getproperty-Tuple{myNLSoln, Symbol}"><a class="docstring-binding" href="#Base.getproperty-Tuple{myNLSoln, Symbol}"><code>Base.getproperty</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Base.getproperty(sol::myNLSoln, sym::Symbol)</strong></p><p>This will allow accessing the solution (u) and parameter (p) from myNLSoln easily</p><p><strong>Arguments</strong></p><ul><li>sol::myNLSoln : </li><li>sym::Symbol   : </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/CONTINUATION.jl#L105-L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="Base.show-Tuple{IO, myNLSoln}"><a class="docstring-binding" href="#Base.show-Tuple{IO, myNLSoln}"><code>Base.show</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Base.show(io::IO, p::myNLSoln)</p><p>Overloading base show function to display myNLSoln object.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/CONTINUATION.jl#L67-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.CONTINUATION.CONTINUATE-Tuple{Vector{Float64}, Any, Vector{Float64}, Float64}"><a class="docstring-binding" href="#juliajim.CONTINUATION.CONTINUATE-Tuple{Vector{Float64}, Any, Vector{Float64}, Float64}"><code>juliajim.CONTINUATION.CONTINUATE</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>CONTINUATE(u0, fun, ps, dp; pkwargs...)</p><p>Continuation routine. Solves the bordered problem with residue drawn from <code>EXTRESFUN!</code>.</p><p><strong>Arguments</strong></p><ul><li><code>u0::Vector{Float64}</code>                          : Initial guess for first point</li><li><code>fun</code>                                          : <code>NonlinearFunction</code> object. Will call:<ul><li><code>fun.f(du, u, p)</code> for residue r. p must be scalar.</li><li><code>fun.jac(J, u, p)</code> for jacobian dr/du. Uses <code>ForwardDiff.jacobian!</code> if <code>fun.jac</code> is <code>nothing</code>.</li><li><code>fun.paramjac(Jp, u, p)</code> for jacobian dr/dp. Uses <code>ForwardDiff.jacobian!</code> if <code>fun.paramjac</code> is <code>nothing</code>.</li></ul></li><li><code>ps::Vector{Float64}</code>                          : Specify range of p for continuation.</li><li><code>dp::Float64</code>                                  : Specify first step in Δp units. (will be rescaled if necessary)</li></ul><p><strong>Optional Arguments</strong></p><ul><li><code>parm::Symbol</code>                                 : (default <code>:arclength</code>) Arclength parameterization. See <code>EXTRESFUN!</code>.</li><li><code>nmax::Int64</code>                                  : (default <code>1000</code>) Maximum number of steps.</li><li><code>dpbnds::Union{Nothing,Vector{Float64}}</code>       : (default <code>[dp/5,5dp]</code>) Bounds for the step length dp. (Rescaled as appropriate)</li><li><code>save_jacs::Bool</code>                              : (default <code>false</code>) Specify whether or not to save the Jacobians in the output. Only solution and (unit) tangent are saved if false.</li><li><code>verbosity::Int</code>                               : (default 1) Verbosity levels:<ul><li>0: Suppress all messages.</li><li>1: Display Steps, Continuation Progress.</li><li>2: Display Iteration Information for each step also.</li></ul></li></ul><p><strong>For Scaling of Unknowns (recommended to get evenly spaced points on response curve)</strong></p><ul><li><p><code>Dsc::Union{Symbol,Nothing,Vector{Float64}}</code>   : (default <code>:none</code>) &quot;Dscaling&quot; used to scale the unknowns. The arc length constraint is applied in the scaled space (<code>uₛ=uₚₕ./Dsc</code>).</p><ul><li>If set to <code>:auto</code>, it uses the absolute of the first converged solution as the initial <code>Dsc</code> vector. Zero entries are replaced with <code>minDsc</code>.</li><li>If set to <code>:none</code>, it fixes Dsc to a vector of ones and doesn&#39;t dynamically adapt it. (this forces <code>DynScale</code> to <code>false</code>).</li><li>If set to <code>:ones</code>, it fixes Dsc to a vector of ones but dynamically continues to scale.</li></ul></li><li><p><code>DynScale::Bool</code>                               : (default <code>true</code>) Whether or not to dynamically adapt the <code>Dsc</code> vector. Each entry is allowed to grow or shrink by a maximum factor of 2 in each step if <code>true</code>.</p></li><li><p><code>minDsc::Float64</code>                              : (default eps()^(4//5)=3e-13) Minimum value for Dscale.</p></li><li><p><code>ndxi::Float64</code>				 : (default 0.5) Dscale update exponent.</p></li></ul><p><strong>For Step Length Adaptation. Currently set as dsₙ = dsₒ * xi, where xi = clamp((itopt/itns)^nxi, xirange[1], xirange[2]).</strong></p><ul><li><code>itopt::Union{Symbol,Int}</code>                     : (default :auto) Optimal number of iterations</li><li><code>angopt::Float64</code>				 : (default deg2rad(20)) Optimal angle change per unit (scaled) arc-length.</li><li><code>nxi::Float64</code>                                 : (default 0.5) Step length adaptation rate.</li></ul><p><strong>For the Solvers</strong></p><ul><li><code>maxiters::Int</code>				 : (default 100) Maximum number of iterations that <code>NonlinearSolve</code> must attempt.</li><li><code>pkwargs</code>					 : (default (;abstol=1e-6, reltol=1e-6)) Parameters to be passed to <code>NonlinearProblem</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>vector{myNLsoln}</code> representing solutions.</li><li><code>vector{Int}</code> representing iterations taken.</li><li><code>vector{Float64}</code> representing step sizes.</li><li><code>vector{Float64}</code> representing adaptation parameter ξ.</li><li><code>vector{Float64}</code> representing the final Dscale matrix.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/CONTINUATION.jl#L294-L344">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.CONTINUATION.EXTRESFUN!-NTuple{4, Any}"><a class="docstring-binding" href="#juliajim.CONTINUATION.EXTRESFUN!-NTuple{4, Any}"><code>juliajim.CONTINUATION.EXTRESFUN!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>EXTRESFUN!(up::nvTypes, fun, sol0::myNLSoln, ds::Float64; parm::Symbol=:riks, Dsc::Vector{Float64}, dup::nvTypes=nothing, Jf::nmTypes=nothing)</p><p>Returns the bordered/extended residue function. Appends residue with required arclength constraint.</p><p><strong>Note</strong></p><p>The function involves very naive autodiff calls. Does not respect or try to detect jacobian sparsity. For now it is best to provide analytical jacobians for very large problems. </p><p><strong>Arguments</strong></p><ul><li><p><code>up::nvTypes</code>: Solution point for evaluation</p></li><li><p><code>fun</code>: Nonlinear function specified in a fashion that can be called as</p><ul><li><p><code>fun.f(du,up[1:end-1],up[end])</code> for the residue.</p></li><li><p><code>fun.jac(J,up[1:end-1],up[end])</code> for the jacobian (uses <code>ForwardDiff.jacobian!</code> if <code>fun.jac</code> is <code>nothing</code>)</p></li><li><p><code>fun.paramjac(Jp,up[1:end-1],up[end])</code> for the parameter jacobian (uses <code>ForwardDiff.jacobian!</code> if <code>fun.paramjac</code> is <code>nothing</code>)</p></li><li><p>Development Done based on <code>NonlinearFunction</code> from <code>NonlinearSolve</code></p></li></ul></li><li><p><code>sol0::myNLSoln</code>: Previous solution point.</p></li><li><p><code>ds::Float64</code>: Step size.</p></li><li><p><code>parm::Symbol=:riks</code>: Arclength parameterization. Defaults to :riks. Possible are:</p><ul><li><p><code>:riks</code>: Riks&#39; or normal parameterization.</p></li><li><p><code>:arclength</code>: Arclength parameterization.</p></li></ul></li><li><p><code>Dsc::Vector{Float64}</code>: Scaling vector. Recommended to be of the order of magnitude of the expected unknowns. Size same as <code>up</code>.</p></li><li><p><code>dup::nvTypes=nothing</code>: Residue vector (for iip evaluation)</p></li><li><p><code>Jf::nmTypes=nothing</code>: Jacobian matrix (for iip evaluation)</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>dup::nvTypes=nothing</code>: Residue vector (for iip evaluation)</p></li><li><p><code>Jf::nmTypes=nothing</code>: Jacobian matrix (for iip evaluation)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/CONTINUATION.jl#L150-L191">source</a></section></details></article><h3 id="Module-MDOFUTILS"><a class="docs-heading-anchor" href="#Module-MDOFUTILS">Module MDOFUTILS</a><a id="Module-MDOFUTILS-1"></a><a class="docs-heading-anchor-permalink" href="#Module-MDOFUTILS" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS"><a class="docstring-binding" href="#juliajim.MDOFUTILS"><code>juliajim.MDOFUTILS</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Useful types and routines for dynamic analyses of MDOF problems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/juliajim.jl#L14">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.MDOFGEN"><a class="docstring-binding" href="#juliajim.MDOFUTILS.MDOFGEN"><code>juliajim.MDOFUTILS.MDOFGEN</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>MDOFGEN</p><p>Struct storing the generic MDOF system.</p><p><strong>Fields</strong></p><ul><li><code>M::Matrix{Float64}</code>: Mass matrix</li><li><code>C::Matrix{Float64}</code>: Damping Matrix</li><li><code>K::Matrix{Float64}</code>: Stiffness Matrix</li><li><code>L</code>: Displacement Transform Matrix (can be empty)</li><li><code>Ndofs::Int64</code>: Number of DOFs</li><li><code>NLTs::Vector{NONLINEARITY}</code>: Vector of nonlinearities present (see <code>NONLINEARITY</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L59-L71">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.NONLINEARITY"><a class="docstring-binding" href="#juliajim.MDOFUTILS.NONLINEARITY"><code>juliajim.MDOFUTILS.NONLINEARITY</code></a> — <span class="docstring-category">Type</span></summary><section><div><p>NONLINEARITY</p><p>Struct storing a nonlinearity.</p><p><strong>Fields</strong></p><ul><li><p><code>type::Symbol</code>: Type of nonlinearity. One of:</p><ol><li><p>:Inst (for instantaneous nonlinearity)</p></li><li><p>:Hyst (for hysteretic nonlinearity)</p></li><li><p>:Fdom (for nonlinearity defined in frequency domain)</p><p>Out of these, only the first 2 can be used for transient simulations.</p></li></ol></li><li><p><code>func::Function</code>: Function handle for evaluating nonlinearity. Has signature</p><ul><li><code>(t, u, udot)</code> for :Inst</li><li><code>(t, u, up, sp)</code> for :Hyst, where <code>s</code> is some internal state (<code>sp</code> is <code>s</code> at <code>t-Δt</code>)</li></ul></li><li><p><code>L::Matrix{Float64}</code>: Selection Matrix</p></li><li><p><code>Lf</code>: Force shape matrix (can be empty)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L23-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.ADDNL"><a class="docstring-binding" href="#juliajim.MDOFUTILS.ADDNL"><code>juliajim.MDOFUTILS.ADDNL</code></a> — <span class="docstring-category">Function</span></summary><section><div><p><strong>Description</strong></p><p>Add a nonlinearity to the MDOFGEN object.</p><p><strong>Arguments</strong></p><ul><li>m::MDOFGEN     : <code>MDOFGEN</code> object</li><li>type::Symbol   : One of <code>:Inst</code> (Instantaneous nonlinearity), <code>:Hyst</code> (Hysteretic nonlinearity), <code>:Fdom</code> (Frequency Domain nonlinearity), <code>:Dla</code> (Dynamic Lagrangian)</li><li>func::Function : Nonlinearity function returning the nonlinear force. Different signatures for different types:<ul><li>:Inst : (t,u,ud) returning (f, dfdu, dfdud)</li><li>:Hyst : (t,u,uprev,fprev) returning (f, dfdu, dfduprev, dfdfprev)</li><li>:Fdom : (Unl, h, N) returning (F, dFdU, dFdw)</li><li>:Dlag : Not implemented yet</li></ul></li><li>L              : </li><li>Lf             : (default nothing)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L96-L110">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.DEFLATEDRES!-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#juliajim.MDOFUTILS.DEFLATEDRES!-Tuple{Any, Any, Any}"><code>juliajim.MDOFUTILS.DEFLATEDRES!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Description</strong></p><p><strong>Arguments</strong></p><ul><li>U  : </li><li>U0 : Vector{Float64} or Vector{Vector{Float64}}</li><li>resfun!     : function!(u, Res, Jac, Jacp)</li><li>R  : (default nothing)</li><li>J  : (default nothing)</li><li>Jp : (default nothing)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L659-L669">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.EPMCRESFUN!-Tuple{Any, MDOFGEN, Any, Any, Int64}"><a class="docstring-binding" href="#juliajim.MDOFUTILS.EPMCRESFUN!-Tuple{Any, MDOFGEN, Any, Any, Int64}"><code>juliajim.MDOFUTILS.EPMCRESFUN!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Description</strong></p><p><strong>Arguments</strong></p><ul><li>Uwxa                : </li><li>m::MDOFGEN          :</li><li>Fl                  : (Nd*Nhc) Forcing vector. Zero harmonics are used as static loads. Harmonic portions are used to provide phase constraint.</li><li>h                   : </li><li>N::Int64            : </li><li>tol::Float64        : (default eps()^(4//5))</li><li>atype::Symbol       : (default :H1)</li><li>ashape::Union{Int64 : </li><li>Vector{Float64}}    : (default 1)</li><li>R                   : (default nothing)</li><li>dRdUwx              : (default nothing)</li><li>dRda                : (default nothing)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L434-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.HBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}"><a class="docstring-binding" href="#juliajim.MDOFUTILS.HBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}"><code>juliajim.MDOFUTILS.HBRESFUN!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Description</strong></p><p>Residue function that can be used for Harmonic Balance forced response analysis.</p><p><strong>Arguments</strong></p><ul><li><code>Uw</code>   : </li><li><code>m</code>    : </li><li><code>Fl</code>   : </li><li><code>h</code>    : </li><li><code>N</code>    : </li><li><code>tol</code>  : </li><li><code>dRdU</code> : </li><li><code>dRdw</code> : </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L308-L321">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.HBRESFUN_A!-Tuple{Any, MDOFGEN, Float64, Any, Any, Int64}"><a class="docstring-binding" href="#juliajim.MDOFUTILS.HBRESFUN_A!-Tuple{Any, MDOFGEN, Float64, Any, Any, Int64}"><code>juliajim.MDOFUTILS.HBRESFUN_A!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Description</strong></p><p>HB residue with amplitude constraint.</p><p><strong>Arguments</strong></p><ul><li><code>Ufw</code>           : </li><li><code>m::MDOFGEN</code>    : </li><li><code>A::Float64</code>    : Amplitude level (also see <code>atype</code> below)</li><li><code>Fl</code>            : </li><li><code>h</code>             : </li><li><code>N::Int64</code>      :</li><li><code>atype::Symbol</code> : (default <code>:H1</code>) One of <code>:H1</code>, <code>:RMS</code>. Type of amplitude measure.</li><li><code>ashape</code>        : (default 1) Shape to dof for applying amplitude. If Integer, interpreted as Dof. If vector, taken as shape.</li><li><code>tol::Float64</code>  : (default <code>eps()^(4//5)</code>)</li><li><code>R</code>             : (default <code>nothing</code>)</li><li><code>dRdUf</code>         : (default <code>nothing</code>)</li><li><code>dRdw</code>          : (default <code>nothing</code>)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L358-L375">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.NEWMARKMARCH-Tuple{MDOFGEN, Vararg{Any, 6}}"><a class="docstring-binding" href="#juliajim.MDOFUTILS.NEWMARKMARCH-Tuple{MDOFGEN, Vararg{Any, 6}}"><code>juliajim.MDOFUTILS.NEWMARKMARCH</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Description</strong></p><p><strong>Arguments</strong></p><ul><li>m::MDOFGEN : </li><li>T0         : </li><li>T1         : </li><li>dt         : </li><li>U0         : </li><li>Ud0        : </li><li>Fex        : </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L784-L795">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.NLEVAL!-Tuple{Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, MDOFGEN, Any, Int64}"><a class="docstring-binding" href="#juliajim.MDOFUTILS.NLEVAL!-Tuple{Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, MDOFGEN, Any, Int64}"><code>juliajim.MDOFUTILS.NLEVAL!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Description</strong></p><p>Evaluate the nonlinearities (and Jacobian) for one period and return the harmonics</p><p><strong>Arguments</strong></p><ul><li><code>Uw</code>         : </li><li><code>m::MDOFGEN</code> :</li><li><code>h</code>          :</li><li><code>N::Int64</code>   : [optional]</li><li><code>tol</code>        :   </li><li><code>FNL</code>        : </li><li><code>dFNLdU</code>     : </li><li><code>dFNLdw</code>     : </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L119-L133">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.NLFORCE-Tuple{MDOFGEN, Any, Any, Any}"><a class="docstring-binding" href="#juliajim.MDOFUTILS.NLFORCE-Tuple{MDOFGEN, Any, Any, Any}"><code>juliajim.MDOFUTILS.NLFORCE</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Description</strong></p><p>Evaluate the nonlinearities in the time domain for a single time instant.</p><p><strong>Arguments</strong></p><ul><li>m::MDOFGEN : MDOFGEN object.</li><li>t          : Time</li><li>U          : (m.Ndofs) Displacements</li><li>Ud         : (m.Ndofs) Velocities</li><li>tp         : (default nothing) Previous instant time</li><li>Up         : (default nothing) (m.Ndofs) Displacements at previous instant.</li><li>Udp        : (default nothing) (m.Ndofs) Velocities at previous instant.</li><li>Sp         : (default nothing) (length(m.NLTs)) Vector of vectors of internal states at previous instant. Each nonlinearity can have its own set of internal states.</li></ul><p><strong>Returns</strong></p><ul><li>F	: (m.Ndofs) force vector</li><li>dFdU	: (m.Ndofs, m.Ndofs) force-displacement derivative matrix</li><li>dFdUd	: (m.Ndofs, m.Ndofs) force-velocity derivative matrix</li><li>S	: (length(m.NLTs)) vector of vectors of internal states</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L708-L727">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.MDOFUTILS.QPHBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}"><a class="docstring-binding" href="#juliajim.MDOFUTILS.QPHBRESFUN!-Tuple{Any, MDOFGEN, Union{Nothing, SparseArrays.SparseMatrixCSC, Matrix, Vector}, Any, Int64}"><code>juliajim.MDOFUTILS.QPHBRESFUN!</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Returns the quasi periodic forced response residue. Also allows for specifying a constrained form. If provided, the matrix cL and vector cLb are interpreted such that the unknown vector gets written as <span>$U = {}^cL Û + {}^cL_b,$</span> where <code>Û</code> is of size <code>(D Nhc+C,1)</code>, containing the frequencies also in the end.</p><p>The matrix <code>{}^cL</code> is used to project the residue vector <code>{}^cL^T R</code>. By choosing its size appropriately, one can make the system square.</p><p>The last element in <code>U</code> is always interpreted as the continuation parameter.</p><p><strong>Arguments</strong></p><ul><li>Uw               : </li><li>m::MDOFGEN       : </li><li>Fl::Union{Vector : </li><li>Matrix           : </li><li>SparseMatrixCSC  : </li><li>Nothing}         : </li><li>h                : </li><li>N::Int64         : </li><li>tol::Float64     : (default eps()^(4//5))</li><li>R                : (default nothing)</li><li>dRdU             : (default nothing)</li><li>dRdw             : (default nothing)</li><li>cL               : (default nothing)</li><li>cLb              : (default nothing)</li><li>U0               : (default nothing) Solution to deflate from. 2-norm is used for deflation.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/MDOFUTILS.jl#L546-L573">source</a></section></details></article><h3 id="Module-NLDYN"><a class="docs-heading-anchor" href="#Module-NLDYN">Module NLDYN</a><a id="Module-NLDYN-1"></a><a class="docs-heading-anchor-permalink" href="#Module-NLDYN" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="juliajim.NLDYN"><a class="docstring-binding" href="#juliajim.NLDYN"><code>juliajim.NLDYN</code></a> — <span class="docstring-category">Module</span></summary><section><div><p>Some routines for Nonlinear Dynamics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/juliajim.jl#L19">source</a></section></details></article><article><details class="docstring" open="true"><summary id="juliajim.NLDYN.NORMALFORMFIT-Tuple{Any, Any, Any}"><a class="docstring-binding" href="#juliajim.NLDYN.NORMALFORMFIT-Tuple{Any, Any, Any}"><code>juliajim.NLDYN.NORMALFORMFIT</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><strong>Description</strong></p><p>NORMALFORMFIT fits a quadratic normal form to the given residue function (in R2) numerically. It starts with a cloud of randomly distributed points with given amplitude standard deviation and fits a general cubic model such that the dynamics may be approximated as:        xdot = A x + B x x + C x x x .   Then the quadratic terms are eliminated by posing a near identity transformation from x to z as 	x = z + H z z .   The simplified normal form equations in terms of z are 	zdot = A z + C3 z z z .</p><p>A good reference for this is sec. 19.10 in Wiggins (1990).   </p><p><strong>Arguments</strong></p><ul><li>xyfun       : (xy) Taking in a 2-vector and returning a 2-residue vector.</li></ul><pre><code class="language-julia hljs">	Must have equilibrium at origin.</code></pre><ul><li>d<em>amp       : If scalar, standard deviation for amplitude.               If vector, [d</em>min, d_max] for the amplitude.</li><li>Npts        : Number of points to be used for fit.</li><li>constrained : (default true)</li></ul><p><strong>Outputs</strong></p><ul><li>A           : (2,2) The linear Jacobian matrix.</li><li>B2n         : (2,3) The quadratic coefficient matrix such that                     the nonlinear influence is written as                        B2<em>[z1^2; z1</em>z2; z2^2]</li><li>C3n         : (2,4) The cubic coefficient matrix such that the                     nonlinear influence is written as                        C3<em>[z1^3; z1^2</em>z2; z1*z2^2; z2^3].</li><li>Hn          : (2,3) The cubic near identity transformation                     matrix such that the near identity                     transformation can be written as                        x = z + Hn [z1^2; z1*z2; z2^2]</li><li>C3          : (2,2,2,2) The cubic coefficient matrix in tensor                         form.</li><li>H           : (2,2,2) The quadratic near identity                       transformation coefficients in tensor form.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Nidish96/juliajim/blob/a8352bdca874b0c920b0687c488b508dffc0fd59/src/NLDYN.jl#L10-L48">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../e_febeam/">« E: Finite Element Beam with Nonlinear Support</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Saturday 10 January 2026 10:53">Saturday 10 January 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
